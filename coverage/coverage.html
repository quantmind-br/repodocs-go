
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>repodocs: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/quantmind-br/repodocs-go/cmd/repodocs/main.go (0.0%)</option>
				
				<option value="file1">github.com/quantmind-br/repodocs-go/internal/app/detector.go (0.0%)</option>
				
				<option value="file2">github.com/quantmind-br/repodocs-go/internal/app/orchestrator.go (0.0%)</option>
				
				<option value="file3">github.com/quantmind-br/repodocs-go/internal/cache/badger.go (0.0%)</option>
				
				<option value="file4">github.com/quantmind-br/repodocs-go/internal/cache/interface.go (0.0%)</option>
				
				<option value="file5">github.com/quantmind-br/repodocs-go/internal/cache/keys.go (0.0%)</option>
				
				<option value="file6">github.com/quantmind-br/repodocs-go/internal/config/config.go (0.0%)</option>
				
				<option value="file7">github.com/quantmind-br/repodocs-go/internal/config/defaults.go (0.0%)</option>
				
				<option value="file8">github.com/quantmind-br/repodocs-go/internal/config/loader.go (0.0%)</option>
				
				<option value="file9">github.com/quantmind-br/repodocs-go/internal/converter/encoding.go (0.0%)</option>
				
				<option value="file10">github.com/quantmind-br/repodocs-go/internal/converter/markdown.go (0.0%)</option>
				
				<option value="file11">github.com/quantmind-br/repodocs-go/internal/converter/pipeline.go (0.0%)</option>
				
				<option value="file12">github.com/quantmind-br/repodocs-go/internal/converter/readability.go (0.0%)</option>
				
				<option value="file13">github.com/quantmind-br/repodocs-go/internal/converter/sanitizer.go (0.0%)</option>
				
				<option value="file14">github.com/quantmind-br/repodocs-go/internal/domain/errors.go (0.0%)</option>
				
				<option value="file15">github.com/quantmind-br/repodocs-go/internal/domain/models.go (0.0%)</option>
				
				<option value="file16">github.com/quantmind-br/repodocs-go/internal/fetcher/client.go (0.0%)</option>
				
				<option value="file17">github.com/quantmind-br/repodocs-go/internal/fetcher/retry.go (0.0%)</option>
				
				<option value="file18">github.com/quantmind-br/repodocs-go/internal/fetcher/stealth.go (0.0%)</option>
				
				<option value="file19">github.com/quantmind-br/repodocs-go/internal/fetcher/transport.go (0.0%)</option>
				
				<option value="file20">github.com/quantmind-br/repodocs-go/internal/output/writer.go (0.0%)</option>
				
				<option value="file21">github.com/quantmind-br/repodocs-go/internal/renderer/detector.go (0.0%)</option>
				
				<option value="file22">github.com/quantmind-br/repodocs-go/internal/renderer/pool.go (0.0%)</option>
				
				<option value="file23">github.com/quantmind-br/repodocs-go/internal/renderer/rod.go (0.0%)</option>
				
				<option value="file24">github.com/quantmind-br/repodocs-go/internal/renderer/stealth.go (0.0%)</option>
				
				<option value="file25">github.com/quantmind-br/repodocs-go/internal/strategies/crawler.go (0.0%)</option>
				
				<option value="file26">github.com/quantmind-br/repodocs-go/internal/strategies/git.go (0.0%)</option>
				
				<option value="file27">github.com/quantmind-br/repodocs-go/internal/strategies/llms.go (0.0%)</option>
				
				<option value="file28">github.com/quantmind-br/repodocs-go/internal/strategies/pkggo.go (0.0%)</option>
				
				<option value="file29">github.com/quantmind-br/repodocs-go/internal/strategies/sitemap.go (77.8%)</option>
				
				<option value="file30">github.com/quantmind-br/repodocs-go/internal/strategies/strategy.go (55.6%)</option>
				
				<option value="file31">github.com/quantmind-br/repodocs-go/internal/utils/fs.go (0.0%)</option>
				
				<option value="file32">github.com/quantmind-br/repodocs-go/internal/utils/logger.go (0.0%)</option>
				
				<option value="file33">github.com/quantmind-br/repodocs-go/internal/utils/url.go (0.0%)</option>
				
				<option value="file34">github.com/quantmind-br/repodocs-go/internal/utils/workerpool.go (0.0%)</option>
				
				<option value="file35">github.com/quantmind-br/repodocs-go/pkg/version/version.go (0.0%)</option>
				
				<option value="file36">github.com/quantmind-br/repodocs-go/tests/mocks/domain.go (0.0%)</option>
				
				<option value="file37">github.com/quantmind-br/repodocs-go/tests/testutil/assertions.go (0.0%)</option>
				
				<option value="file38">github.com/quantmind-br/repodocs-go/tests/testutil/cache.go (0.0%)</option>
				
				<option value="file39">github.com/quantmind-br/repodocs-go/tests/testutil/documents.go (0.0%)</option>
				
				<option value="file40">github.com/quantmind-br/repodocs-go/tests/testutil/http.go (0.0%)</option>
				
				<option value="file41">github.com/quantmind-br/repodocs-go/tests/testutil/logger.go (0.0%)</option>
				
				<option value="file42">github.com/quantmind-br/repodocs-go/tests/testutil/temp.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "fmt"
        "net/http"
        "os"
        "os/exec"
        "os/signal"
        "syscall"
        "time"

        "github.com/quantmind-br/repodocs-go/internal/app"
        "github.com/quantmind-br/repodocs-go/internal/config"
        "github.com/quantmind-br/repodocs-go/internal/utils"
        "github.com/quantmind-br/repodocs-go/pkg/version"
        "github.com/spf13/cobra"
        "github.com/spf13/viper"
)

var (
        cfgFile string
        verbose bool
        log     *utils.Logger
)

func main() <span class="cov0" title="0">{
        if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintln(os.Stderr, err)
                os.Exit(1)
        }</span>
}

var rootCmd = &amp;cobra.Command{
        Use:   "repodocs [url]",
        Short: "Extract documentation from any source",
        Long: `RepoDocs is a CLI tool for extracting documentation from websites,
git repositories, sitemaps, pkg.go.dev, and llms.txt files.

It supports stealth mode for avoiding bot detection and JavaScript rendering
for single-page applications.`,
        Version: version.Short(),
        Args:    cobra.MaximumNArgs(1),
        RunE:    run,
}

func init() <span class="cov0" title="0">{
        cobra.OnInitialize(initConfig)

        // Global flags
        rootCmd.PersistentFlags().StringVar(&amp;cfgFile, "config", "", "config file (default is ~/.repodocs/config.yaml)")
        rootCmd.PersistentFlags().StringP("output", "o", "./docs", "Output directory")
        rootCmd.PersistentFlags().IntP("concurrency", "j", 5, "Number of concurrent workers")
        rootCmd.PersistentFlags().IntP("limit", "l", 0, "Max pages to process (0=unlimited)")
        rootCmd.PersistentFlags().IntP("max-depth", "d", 4, "Max crawl depth")
        rootCmd.PersistentFlags().StringSlice("exclude", nil, "Regex patterns to exclude")
        rootCmd.PersistentFlags().String("filter", "", "Base URL filter (only crawl URLs starting with this path)")
        rootCmd.PersistentFlags().Bool("nofolders", false, "Flat output structure")
        rootCmd.PersistentFlags().Bool("force", false, "Overwrite existing files")
        rootCmd.PersistentFlags().BoolVarP(&amp;verbose, "verbose", "v", false, "Verbose output")

        // Cache flags
        rootCmd.PersistentFlags().Bool("no-cache", false, "Disable caching")
        rootCmd.PersistentFlags().Duration("cache-ttl", 24*time.Hour, "Cache TTL")
        rootCmd.PersistentFlags().Bool("refresh-cache", false, "Force cache refresh")

        // Rendering flags
        rootCmd.PersistentFlags().Bool("render-js", false, "Force JS rendering")
        rootCmd.PersistentFlags().Duration("timeout", 30*time.Second, "Request timeout")

        // Output flags
        rootCmd.PersistentFlags().Bool("json-meta", false, "Generate JSON metadata files")
        rootCmd.PersistentFlags().Bool("dry-run", false, "Simulate without writing files")

        // Specific flags
        rootCmd.PersistentFlags().Bool("split", false, "Split output by sections (pkg.go.dev)")
        rootCmd.PersistentFlags().Bool("include-assets", false, "Include referenced images (git)")
        rootCmd.PersistentFlags().String("user-agent", "", "Custom User-Agent")
        rootCmd.PersistentFlags().String("content-selector", "", "CSS selector for main content")

        // Bind flags to viper
        _ = viper.BindPFlag("output.directory", rootCmd.PersistentFlags().Lookup("output"))
        _ = viper.BindPFlag("concurrency.workers", rootCmd.PersistentFlags().Lookup("concurrency"))
        _ = viper.BindPFlag("concurrency.max_depth", rootCmd.PersistentFlags().Lookup("max-depth"))
        _ = viper.BindPFlag("concurrency.timeout", rootCmd.PersistentFlags().Lookup("timeout"))
        _ = viper.BindPFlag("output.flat", rootCmd.PersistentFlags().Lookup("nofolders"))
        _ = viper.BindPFlag("output.overwrite", rootCmd.PersistentFlags().Lookup("force"))
        _ = viper.BindPFlag("cache.enabled", rootCmd.PersistentFlags().Lookup("no-cache"))
        _ = viper.BindPFlag("cache.ttl", rootCmd.PersistentFlags().Lookup("cache-ttl"))
        _ = viper.BindPFlag("rendering.force_js", rootCmd.PersistentFlags().Lookup("render-js"))
        _ = viper.BindPFlag("output.json_metadata", rootCmd.PersistentFlags().Lookup("json-meta"))
        _ = viper.BindPFlag("stealth.user_agent", rootCmd.PersistentFlags().Lookup("user-agent"))

        // Add subcommands
        rootCmd.AddCommand(doctorCmd)
        rootCmd.AddCommand(versionCmd)
}</span>

func initConfig() <span class="cov0" title="0">{
        if cfgFile != "" </span><span class="cov0" title="0">{
                viper.SetConfigFile(cfgFile)
        }</span>
}

func run(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        // Initialize logger
        logLevel := "info"
        if verbose </span><span class="cov0" title="0">{
                logLevel = "debug"
        }</span>
        <span class="cov0" title="0">log = utils.NewLogger(utils.LoggerOptions{
                Level:   logLevel,
                Format:  "pretty",
                Verbose: verbose,
        })

        // Load configuration
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load config: %w", err)
        }</span>

        // Check if URL was provided
        <span class="cov0" title="0">if len(args) == 0 </span><span class="cov0" title="0">{
                return cmd.Help()
        }</span>

        <span class="cov0" title="0">url := args[0]

        // Handle output directory:
        // 1. If user explicitly provided -o flag, use that value
        // 2. Otherwise, generate from URL
        if cmd.Flags().Changed("output") </span><span class="cov0" title="0">{
                // User explicitly set output directory via -o flag
                cfg.Output.Directory, _ = cmd.Flags().GetString("output")
        }</span> else<span class="cov0" title="0"> {
                // Use URL-based output directory
                cfg.Output.Directory = utils.GenerateOutputDirFromURL(url)
        }</span>

        // Create context with cancellation
        <span class="cov0" title="0">ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        // Handle graceful shutdown
        sigCh := make(chan os.Signal, 1)
        signal.Notify(sigCh, syscall.SIGINT, syscall.SIGTERM)

        go func() </span><span class="cov0" title="0">{
                &lt;-sigCh
                log.Info().Msg("Shutting down gracefully...")
                cancel()
        }</span>()

        // Get flags
        <span class="cov0" title="0">limit, _ := cmd.Flags().GetInt("limit")
        dryRun, _ := cmd.Flags().GetBool("dry-run")
        split, _ := cmd.Flags().GetBool("split")
        includeAssets, _ := cmd.Flags().GetBool("include-assets")
        contentSelector, _ := cmd.Flags().GetString("content-selector")
        excludePatterns, _ := cmd.Flags().GetStringSlice("exclude")
        renderJS, _ := cmd.Flags().GetBool("render-js")
        force, _ := cmd.Flags().GetBool("force")
        filterURL, _ := cmd.Flags().GetString("filter")

        // Create orchestrator options
        orchOpts := app.OrchestratorOptions{
                Config:          cfg,
                Verbose:         verbose,
                DryRun:          dryRun,
                Force:           force,
                RenderJS:        renderJS,
                Split:           split,
                IncludeAssets:   includeAssets,
                Limit:           limit,
                ContentSelector: contentSelector,
                ExcludePatterns: excludePatterns,
                FilterURL:       filterURL,
        }

        // Create orchestrator
        orchestrator, err := app.NewOrchestrator(orchOpts)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create orchestrator: %w", err)
        }</span>
        <span class="cov0" title="0">defer orchestrator.Close()

        // Validate URL
        if err := orchestrator.ValidateURL(url); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Run extraction
        <span class="cov0" title="0">return orchestrator.Run(ctx, url, orchOpts)</span>
}

var doctorCmd = &amp;cobra.Command{
        Use:   "doctor",
        Short: "Check system dependencies",
        Long:  "Verifies that all system dependencies are properly installed and configured.",
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                fmt.Println("Checking system dependencies...")
                allPassed := true

                // Check 1: Internet connection
                fmt.Print("  Internet connection: ")
                if checkInternet() </span><span class="cov0" title="0">{
                        fmt.Println("OK")
                }</span> else<span class="cov0" title="0"> {
                        fmt.Println("FAILED")
                        allPassed = false
                }</span>

                // Check 2: Chrome/Chromium
                <span class="cov0" title="0">fmt.Print("  Chrome/Chromium: ")
                if chromePath := checkChrome(); chromePath != "" </span><span class="cov0" title="0">{
                        fmt.Printf("OK (%s)\n", chromePath)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Println("NOT FOUND (JS rendering will be unavailable)")
                }</span>

                // Check 3: Write permissions for output dir
                <span class="cov0" title="0">fmt.Print("  Write permissions: ")
                if checkWritePermissions() </span><span class="cov0" title="0">{
                        fmt.Println("OK")
                }</span> else<span class="cov0" title="0"> {
                        fmt.Println("FAILED")
                        allPassed = false
                }</span>

                // Check 4: Config file
                <span class="cov0" title="0">fmt.Print("  Config file: ")
                _, err := config.Load()
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("WARN (%v)\n", err)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Println("OK")
                }</span>

                // Check 5: Cache directory
                <span class="cov0" title="0">fmt.Print("  Cache directory: ")
                cacheDir := utils.ExpandPath("~/.repodocs/cache")
                if checkCacheDir(cacheDir) </span><span class="cov0" title="0">{
                        fmt.Printf("OK (%s)\n", cacheDir)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Println("WARN (will be created on first use)")
                }</span>

                <span class="cov0" title="0">fmt.Println()
                if allPassed </span><span class="cov0" title="0">{
                        fmt.Println("All critical checks passed!")
                }</span> else<span class="cov0" title="0"> {
                        fmt.Println("Some checks failed. Please resolve the issues above.")
                }</span>
                <span class="cov0" title="0">return nil</span>
        },
}

// checkInternet checks if there's an internet connection
func checkInternet() bool <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        req, err := http.NewRequestWithContext(ctx, http.MethodHead, "https://www.google.com", nil)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">client := &amp;http.Client{Timeout: 5 * time.Second}
        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">resp.Body.Close()
        return resp.StatusCode &lt; 400</span>
}

// checkChrome checks if Chrome/Chromium is available
func checkChrome() string <span class="cov0" title="0">{
        // Common Chrome/Chromium paths
        paths := []string{
                // Linux
                "/usr/bin/google-chrome",
                "/usr/bin/google-chrome-stable",
                "/usr/bin/chromium",
                "/usr/bin/chromium-browser",
                "/snap/bin/chromium",
                // macOS
                "/Applications/Google Chrome.app/Contents/MacOS/Google Chrome",
                "/Applications/Chromium.app/Contents/MacOS/Chromium",
                // Windows (via PATH)
                "chrome.exe",
                "chromium.exe",
        }

        for _, path := range paths </span><span class="cov0" title="0">{
                if _, err := os.Stat(path); err == nil </span><span class="cov0" title="0">{
                        return path
                }</span>
        }

        // Try to find via which/where command
        <span class="cov0" title="0">if path, err := exec.LookPath("google-chrome"); err == nil </span><span class="cov0" title="0">{
                return path
        }</span>
        <span class="cov0" title="0">if path, err := exec.LookPath("chromium"); err == nil </span><span class="cov0" title="0">{
                return path
        }</span>
        <span class="cov0" title="0">if path, err := exec.LookPath("chromium-browser"); err == nil </span><span class="cov0" title="0">{
                return path
        }</span>

        <span class="cov0" title="0">return ""</span>
}

// checkWritePermissions checks if we can write to the current directory
func checkWritePermissions() bool <span class="cov0" title="0">{
        tmpFile := ".repodocs_test_write"
        f, err := os.Create(tmpFile)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">f.Close()
        os.Remove(tmpFile)
        return true</span>
}

// checkCacheDir checks if the cache directory exists or can be created
func checkCacheDir(path string) bool <span class="cov0" title="0">{
        info, err := os.Stat(path)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return info.IsDir()</span>
}

var versionCmd = &amp;cobra.Command{
        Use:   "version",
        Short: "Print version information",
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                fmt.Println(version.Full())
        }</span>,
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package app

import (
        "strings"

        "github.com/quantmind-br/repodocs-go/internal/strategies"
)

// StrategyType represents the type of extraction strategy
type StrategyType string

const (
        StrategyLLMS    StrategyType = "llms"
        StrategySitemap StrategyType = "sitemap"
        StrategyGit     StrategyType = "git"
        StrategyPkgGo   StrategyType = "pkggo"
        StrategyCrawler StrategyType = "crawler"
        StrategyUnknown StrategyType = "unknown"
)

// DetectStrategy determines the appropriate strategy based on URL patterns
func DetectStrategy(url string) StrategyType <span class="cov0" title="0">{
        lower := strings.ToLower(url)

        // Check for llms.txt first
        if strings.HasSuffix(lower, "/llms.txt") || strings.HasSuffix(lower, "llms.txt") </span><span class="cov0" title="0">{
                return StrategyLLMS
        }</span>

        // Check for pkg.go.dev (before Git, since pkg.go.dev URLs contain github.com paths)
        <span class="cov0" title="0">if strings.Contains(lower, "pkg.go.dev") </span><span class="cov0" title="0">{
                return StrategyPkgGo
        }</span>

        // Check for sitemap
        <span class="cov0" title="0">if strings.HasSuffix(lower, "sitemap.xml") ||
                strings.HasSuffix(lower, "sitemap.xml.gz") ||
                strings.Contains(lower, "sitemap") &amp;&amp; strings.HasSuffix(lower, ".xml") </span><span class="cov0" title="0">{
                return StrategySitemap
        }</span>

        // Check for Git repository
        <span class="cov0" title="0">if strings.HasPrefix(url, "git@") ||
                strings.HasSuffix(lower, ".git") ||
                (strings.Contains(lower, "github.com") &amp;&amp; !strings.Contains(lower, "/blob/") &amp;&amp; !strings.Contains(lower, "/tree/")) ||
                (strings.Contains(lower, "gitlab.com") &amp;&amp; !strings.Contains(lower, "/-/blob/") &amp;&amp; !strings.Contains(lower, "/-/tree/")) ||
                strings.Contains(lower, "bitbucket.org") </span><span class="cov0" title="0">{
                return StrategyGit
        }</span>

        // Default to crawler for HTTP URLs
        <span class="cov0" title="0">if strings.HasPrefix(lower, "http://") || strings.HasPrefix(lower, "https://") </span><span class="cov0" title="0">{
                return StrategyCrawler
        }</span>

        <span class="cov0" title="0">return StrategyUnknown</span>
}

// CreateStrategy creates the appropriate strategy based on detected type
func CreateStrategy(strategyType StrategyType, deps *strategies.Dependencies) strategies.Strategy <span class="cov0" title="0">{
        switch strategyType </span>{
        case StrategyLLMS:<span class="cov0" title="0">
                return strategies.NewLLMSStrategy(deps)</span>
        case StrategySitemap:<span class="cov0" title="0">
                return strategies.NewSitemapStrategy(deps)</span>
        case StrategyGit:<span class="cov0" title="0">
                return strategies.NewGitStrategy(deps)</span>
        case StrategyPkgGo:<span class="cov0" title="0">
                return strategies.NewPkgGoStrategy(deps)</span>
        case StrategyCrawler:<span class="cov0" title="0">
                return strategies.NewCrawlerStrategy(deps)</span>
        default:<span class="cov0" title="0">
                return nil</span>
        }
}

// GetAllStrategies returns all available strategies
func GetAllStrategies(deps *strategies.Dependencies) []strategies.Strategy <span class="cov0" title="0">{
        return []strategies.Strategy{
                strategies.NewLLMSStrategy(deps),
                strategies.NewSitemapStrategy(deps),
                strategies.NewGitStrategy(deps),
                strategies.NewPkgGoStrategy(deps),
                strategies.NewCrawlerStrategy(deps),
        }
}</span>

// FindMatchingStrategy finds the first strategy that can handle the URL
func FindMatchingStrategy(url string, deps *strategies.Dependencies) strategies.Strategy <span class="cov0" title="0">{
        for _, strategy := range GetAllStrategies(deps) </span><span class="cov0" title="0">{
                if strategy.CanHandle(url) </span><span class="cov0" title="0">{
                        return strategy
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package app

import (
        "context"
        "fmt"
        "time"

        "github.com/quantmind-br/repodocs-go/internal/config"
        "github.com/quantmind-br/repodocs-go/internal/strategies"
        "github.com/quantmind-br/repodocs-go/internal/utils"
)

// Orchestrator coordinates the documentation extraction process
type Orchestrator struct {
        config          *config.Config
        deps            *strategies.Dependencies
        logger          *utils.Logger
        strategyFactory func(StrategyType, *strategies.Dependencies) strategies.Strategy
}

// OrchestratorOptions contains options for creating an orchestrator
type OrchestratorOptions struct {
        Config          *config.Config
        Verbose         bool
        DryRun          bool
        Force           bool
        RenderJS        bool
        Split           bool
        IncludeAssets   bool
        Limit           int
        ContentSelector string
        ExcludePatterns []string
        FilterURL       string
        // StrategyFactory allows injecting custom strategy creation logic for testing
        // If nil, uses default strategy creation
        StrategyFactory func(StrategyType, *strategies.Dependencies) strategies.Strategy
}

// NewOrchestrator creates a new orchestrator with the given configuration
func NewOrchestrator(opts OrchestratorOptions) (*Orchestrator, error) <span class="cov0" title="0">{
        cfg := opts.Config

        // Validate config
        if cfg == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("config is required")
        }</span>

        // Create logger
        <span class="cov0" title="0">logLevel := "info"
        logFormat := "pretty"
        if cfg.Logging.Level != "" </span><span class="cov0" title="0">{
                logLevel = cfg.Logging.Level
        }</span>
        <span class="cov0" title="0">if cfg.Logging.Format != "" </span><span class="cov0" title="0">{
                logFormat = cfg.Logging.Format
        }</span>
        <span class="cov0" title="0">if opts.Verbose </span><span class="cov0" title="0">{
                logLevel = "debug"
        }</span>

        <span class="cov0" title="0">logger := utils.NewLogger(utils.LoggerOptions{
                Level:   logLevel,
                Format:  logFormat,
                Verbose: opts.Verbose,
        })

        // Determine cache directory
        cacheDir := cfg.Cache.Directory
        if cacheDir == "" </span><span class="cov0" title="0">{
                cacheDir = "~/.repodocs/cache"
        }</span>
        <span class="cov0" title="0">cacheDir = utils.ExpandPath(cacheDir)

        // Create dependencies
        deps, err := strategies.NewDependencies(strategies.DependencyOptions{
                Timeout:         cfg.Concurrency.Timeout,
                EnableCache:     cfg.Cache.Enabled,
                CacheTTL:        cfg.Cache.TTL,
                CacheDir:        cacheDir,
                UserAgent:       cfg.Stealth.UserAgent,
                EnableRenderer:  cfg.Rendering.ForceJS || opts.RenderJS,
                RendererTimeout: cfg.Rendering.JSTimeout,
                Concurrency:     cfg.Concurrency.Workers,
                ContentSelector: opts.ContentSelector,
                OutputDir:       cfg.Output.Directory,
                Flat:            cfg.Output.Flat,
                JSONMetadata:    cfg.Output.JSONMetadata,
                Force:           opts.Force || cfg.Output.Overwrite,
                DryRun:          opts.DryRun,
                Verbose:         opts.Verbose,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create dependencies: %w", err)
        }</span>

        // Set default strategy factory if none provided
        <span class="cov0" title="0">strategyFactory := opts.StrategyFactory
        if strategyFactory == nil </span><span class="cov0" title="0">{
                strategyFactory = func(st StrategyType, d *strategies.Dependencies) strategies.Strategy </span><span class="cov0" title="0">{
                        return CreateStrategy(st, d)
                }</span>
        }

        <span class="cov0" title="0">return &amp;Orchestrator{
                config:          cfg,
                deps:            deps,
                logger:          logger,
                strategyFactory: strategyFactory,
        }, nil</span>
}

// Run executes the documentation extraction for the given URL
func (o *Orchestrator) Run(ctx context.Context, url string, opts OrchestratorOptions) error <span class="cov0" title="0">{
        startTime := time.Now()

        o.logger.Info().
                Str("url", url).
                Str("output", o.config.Output.Directory).
                Int("concurrency", o.config.Concurrency.Workers).
                Msg("Starting documentation extraction")

        // Detect strategy
        strategyType := DetectStrategy(url)
        o.logger.Debug().
                Str("strategy", string(strategyType)).
                Msg("Detected strategy type")

        if strategyType == StrategyUnknown </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to determine strategy for URL: %s", url)
        }</span>

        // Create strategy using strategy factory (allows injection for testing)
        <span class="cov0" title="0">strategy := o.strategyFactory(strategyType, o.deps)
        if strategy == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create strategy for URL: %s", url)
        }</span>

        <span class="cov0" title="0">o.logger.Info().
                Str("strategy", strategy.Name()).
                Msg("Using extraction strategy")

        // Build strategy options
        strategyOpts := strategies.Options{
                Output:          o.config.Output.Directory,
                Concurrency:     o.config.Concurrency.Workers,
                Limit:           opts.Limit,
                MaxDepth:        o.config.Concurrency.MaxDepth,
                Exclude:         append(o.config.Exclude, opts.ExcludePatterns...),
                NoFolders:       o.config.Output.Flat,
                DryRun:          opts.DryRun,
                Verbose:         opts.Verbose,
                Force:           opts.Force || o.config.Output.Overwrite,
                RenderJS:        opts.RenderJS || o.config.Rendering.ForceJS,
                Split:           opts.Split,
                IncludeAssets:   opts.IncludeAssets,
                ContentSelector: opts.ContentSelector,
                FilterURL:       opts.FilterURL,
        }

        // Execute strategy
        if err := strategy.Execute(ctx, url, strategyOpts); err != nil </span><span class="cov0" title="0">{
                // Check if it was a context cancellation
                if ctx.Err() != nil </span><span class="cov0" title="0">{
                        o.logger.Warn().Msg("Extraction cancelled")
                        return ctx.Err()
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("strategy execution failed: %w", err)</span>
        }

        <span class="cov0" title="0">duration := time.Since(startTime)
        o.logger.Info().
                Dur("duration", duration).
                Msg("Documentation extraction completed")

        return nil</span>
}

// Close releases all resources held by the orchestrator
func (o *Orchestrator) Close() error <span class="cov0" title="0">{
        if o.deps != nil </span><span class="cov0" title="0">{
                return o.deps.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetStrategyName returns the detected strategy name for a URL
func (o *Orchestrator) GetStrategyName(url string) string <span class="cov0" title="0">{
        return string(DetectStrategy(url))
}</span>

// ValidateURL checks if the URL can be processed
func (o *Orchestrator) ValidateURL(url string) error <span class="cov0" title="0">{
        strategyType := DetectStrategy(url)
        if strategyType == StrategyUnknown </span><span class="cov0" title="0">{
                return fmt.Errorf("unsupported URL format: %s", url)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package cache

import (
        "context"
        "os"
        "time"

        "github.com/dgraph-io/badger/v4"
        "github.com/quantmind-br/repodocs-go/internal/domain"
)

// BadgerCache is a cache implementation using BadgerDB
type BadgerCache struct {
        db *badger.DB
}

// NewBadgerCache creates a new BadgerDB cache
func NewBadgerCache(opts Options) (*BadgerCache, error) <span class="cov0" title="0">{
        var badgerOpts badger.Options

        if opts.InMemory </span><span class="cov0" title="0">{
                badgerOpts = badger.DefaultOptions("").WithInMemory(true)
        }</span> else<span class="cov0" title="0"> {
                if opts.Directory == "" </span><span class="cov0" title="0">{
                        homeDir, err := os.UserHomeDir()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">opts.Directory = homeDir + "/.repodocs/cache"</span>
                }

                // Ensure directory exists
                <span class="cov0" title="0">if err := os.MkdirAll(opts.Directory, 0755); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">badgerOpts = badger.DefaultOptions(opts.Directory)</span>
        }

        // Disable logging unless explicitly enabled
        <span class="cov0" title="0">if !opts.Logger </span><span class="cov0" title="0">{
                badgerOpts = badgerOpts.WithLogger(nil)
        }</span>

        <span class="cov0" title="0">db, err := badger.Open(badgerOpts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Start background garbage collection
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                ticker := time.NewTicker(5 * time.Minute)
                defer ticker.Stop()
                for range ticker.C </span><span class="cov0" title="0">{
                        _ = db.RunValueLogGC(0.5)
                }</span>
        }()

        <span class="cov0" title="0">return &amp;BadgerCache{db: db}, nil</span>
}

// Get retrieves a value from cache
func (c *BadgerCache) Get(ctx context.Context, key string) ([]byte, error) <span class="cov0" title="0">{
        // Generate cache key from URL
        cacheKey := GenerateKey(key)

        var value []byte
        err := c.db.View(func(txn *badger.Txn) error </span><span class="cov0" title="0">{
                item, err := txn.Get([]byte(cacheKey))
                if err != nil </span><span class="cov0" title="0">{
                        if err == badger.ErrKeyNotFound </span><span class="cov0" title="0">{
                                return domain.ErrCacheMiss
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }

                <span class="cov0" title="0">value, err = item.ValueCopy(nil)
                return err</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return value, nil</span>
}

// Set stores a value in cache with TTL
func (c *BadgerCache) Set(ctx context.Context, key string, value []byte, ttl time.Duration) error <span class="cov0" title="0">{
        // Generate cache key from URL
        cacheKey := GenerateKey(key)

        return c.db.Update(func(txn *badger.Txn) error </span><span class="cov0" title="0">{
                e := badger.NewEntry([]byte(cacheKey), value)
                if ttl &gt; 0 </span><span class="cov0" title="0">{
                        e = e.WithTTL(ttl)
                }</span>
                <span class="cov0" title="0">return txn.SetEntry(e)</span>
        })
}

// Has checks if a key exists in cache
func (c *BadgerCache) Has(ctx context.Context, key string) bool <span class="cov0" title="0">{
        cacheKey := GenerateKey(key)

        err := c.db.View(func(txn *badger.Txn) error </span><span class="cov0" title="0">{
                _, err := txn.Get([]byte(cacheKey))
                return err
        }</span>)

        <span class="cov0" title="0">return err == nil</span>
}

// Delete removes a key from cache
func (c *BadgerCache) Delete(ctx context.Context, key string) error <span class="cov0" title="0">{
        cacheKey := GenerateKey(key)

        return c.db.Update(func(txn *badger.Txn) error </span><span class="cov0" title="0">{
                return txn.Delete([]byte(cacheKey))
        }</span>)
}

// Close releases cache resources
func (c *BadgerCache) Close() error <span class="cov0" title="0">{
        return c.db.Close()
}</span>

// Clear removes all entries from the cache
func (c *BadgerCache) Clear() error <span class="cov0" title="0">{
        return c.db.DropAll()
}</span>

// Size returns the number of entries in the cache
func (c *BadgerCache) Size() int64 <span class="cov0" title="0">{
        var count int64
        _ = c.db.View(func(txn *badger.Txn) error </span><span class="cov0" title="0">{
                opts := badger.DefaultIteratorOptions
                opts.PrefetchValues = false
                it := txn.NewIterator(opts)
                defer it.Close()

                for it.Rewind(); it.Valid(); it.Next() </span><span class="cov0" title="0">{
                        count++
                }</span>
                <span class="cov0" title="0">return nil</span>
        })
        <span class="cov0" title="0">return count</span>
}

// Stats returns cache statistics
func (c *BadgerCache) Stats() map[string]interface{} <span class="cov0" title="0">{
        lsm, vlog := c.db.Size()
        return map[string]interface{}{
                "entries":   c.Size(),
                "lsm_size":  lsm,
                "vlog_size": vlog,
        }
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package cache

import (
        "time"

        "github.com/quantmind-br/repodocs-go/internal/domain"
)

// Ensure BadgerCache implements domain.Cache
var _ domain.Cache = (*BadgerCache)(nil)

// Entry represents a cached entry with metadata
type Entry struct {
        URL         string    `json:"url"`
        Content     []byte    `json:"content"`
        ContentType string    `json:"content_type"`
        FetchedAt   time.Time `json:"fetched_at"`
        ExpiresAt   time.Time `json:"expires_at"`
}

// IsExpired returns true if the entry has expired
func (e *Entry) IsExpired() bool <span class="cov0" title="0">{
        return time.Now().After(e.ExpiresAt)
}</span>

// TTL returns the remaining time-to-live
func (e *Entry) TTL() time.Duration <span class="cov0" title="0">{
        remaining := time.Until(e.ExpiresAt)
        if remaining &lt; 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return remaining</span>
}

// Options contains cache configuration options
type Options struct {
        Directory string
        InMemory  bool
        Logger    bool
}

// DefaultOptions returns default cache options
func DefaultOptions() Options <span class="cov0" title="0">{
        return Options{
                Directory: "",
                InMemory:  false,
                Logger:    false,
        }
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package cache

import (
        "crypto/sha256"
        "encoding/hex"
        "net/url"
        "path"
        "strings"
)

// GenerateKey generates a cache key from a URL
// The key is a SHA256 hash of the normalized URL
func GenerateKey(rawURL string) string <span class="cov0" title="0">{
        normalized := normalizeForKey(rawURL)
        hash := sha256.Sum256([]byte(normalized))
        return hex.EncodeToString(hash[:])
}</span>

// GenerateKeyWithPrefix generates a cache key with a prefix
func GenerateKeyWithPrefix(prefix, rawURL string) string <span class="cov0" title="0">{
        key := GenerateKey(rawURL)
        return prefix + ":" + key
}</span>

// normalizeForKey normalizes a URL for consistent key generation
func normalizeForKey(rawURL string) string <span class="cov0" title="0">{
        u, err := url.Parse(rawURL)
        if err != nil </span><span class="cov0" title="0">{
                return rawURL
        }</span>

        // Normalize scheme
        <span class="cov0" title="0">if u.Scheme == "" </span><span class="cov0" title="0">{
                u.Scheme = "https"
        }</span>

        // Normalize host
        <span class="cov0" title="0">u.Host = strings.ToLower(u.Host)

        // Remove default ports
        if (u.Scheme == "http" &amp;&amp; u.Port() == "80") ||
                (u.Scheme == "https" &amp;&amp; u.Port() == "443") </span><span class="cov0" title="0">{
                u.Host = u.Hostname()
        }</span>

        // Clean path
        <span class="cov0" title="0">if u.Path == "" </span><span class="cov0" title="0">{
                u.Path = "/"
        }</span> else<span class="cov0" title="0"> {
                u.Path = path.Clean(u.Path)
        }</span>

        // Remove trailing slash except for root
        <span class="cov0" title="0">if u.Path != "/" &amp;&amp; strings.HasSuffix(u.Path, "/") </span><span class="cov0" title="0">{
                u.Path = strings.TrimSuffix(u.Path, "/")
        }</span>

        // Remove fragment
        <span class="cov0" title="0">u.Fragment = ""

        return u.String()</span>
}

// KeyPrefix constants for different cache types
const (
        PrefixPage     = "page"
        PrefixSitemap  = "sitemap"
        PrefixGit      = "git"
        PrefixMetadata = "meta"
)

// PageKey generates a cache key for a page
func PageKey(url string) string <span class="cov0" title="0">{
        return GenerateKeyWithPrefix(PrefixPage, url)
}</span>

// SitemapKey generates a cache key for a sitemap
func SitemapKey(url string) string <span class="cov0" title="0">{
        return GenerateKeyWithPrefix(PrefixSitemap, url)
}</span>

// MetadataKey generates a cache key for metadata
func MetadataKey(url string) string <span class="cov0" title="0">{
        return GenerateKeyWithPrefix(PrefixMetadata, url)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package config

import "time"

// Config represents the application configuration
type Config struct {
        Output      OutputConfig      `mapstructure:"output"`
        Concurrency ConcurrencyConfig `mapstructure:"concurrency"`
        Cache       CacheConfig       `mapstructure:"cache"`
        Rendering   RenderingConfig   `mapstructure:"rendering"`
        Stealth     StealthConfig     `mapstructure:"stealth"`
        Exclude     []string          `mapstructure:"exclude"`
        Logging     LoggingConfig     `mapstructure:"logging"`
}

// OutputConfig contains output-related settings
type OutputConfig struct {
        Directory    string `mapstructure:"directory"`
        Flat         bool   `mapstructure:"flat"`
        JSONMetadata bool   `mapstructure:"json_metadata"`
        Overwrite    bool   `mapstructure:"overwrite"`
}

// ConcurrencyConfig contains concurrency settings
type ConcurrencyConfig struct {
        Workers  int           `mapstructure:"workers"`
        Timeout  time.Duration `mapstructure:"timeout"`
        MaxDepth int           `mapstructure:"max_depth"`
}

// CacheConfig contains cache settings
type CacheConfig struct {
        Enabled   bool          `mapstructure:"enabled"`
        TTL       time.Duration `mapstructure:"ttl"`
        Directory string        `mapstructure:"directory"`
}

// RenderingConfig contains JavaScript rendering settings
type RenderingConfig struct {
        ForceJS     bool          `mapstructure:"force_js"`
        JSTimeout   time.Duration `mapstructure:"js_timeout"`
        ScrollToEnd bool          `mapstructure:"scroll_to_end"`
}

// StealthConfig contains stealth mode settings
type StealthConfig struct {
        UserAgent      string        `mapstructure:"user_agent"`
        RandomDelayMin time.Duration `mapstructure:"random_delay_min"`
        RandomDelayMax time.Duration `mapstructure:"random_delay_max"`
}

// LoggingConfig contains logging settings
type LoggingConfig struct {
        Level  string `mapstructure:"level"`
        Format string `mapstructure:"format"`
}

// Validate validates the configuration
func (c *Config) Validate() error <span class="cov0" title="0">{
        if c.Concurrency.Workers &lt; 1 </span><span class="cov0" title="0">{
                c.Concurrency.Workers = DefaultWorkers
        }</span>
        <span class="cov0" title="0">if c.Concurrency.MaxDepth &lt; 1 </span><span class="cov0" title="0">{
                c.Concurrency.MaxDepth = DefaultMaxDepth
        }</span>
        <span class="cov0" title="0">if c.Concurrency.Timeout &lt; time.Second </span><span class="cov0" title="0">{
                c.Concurrency.Timeout = DefaultTimeout
        }</span>
        <span class="cov0" title="0">if c.Cache.TTL &lt; time.Minute </span><span class="cov0" title="0">{
                c.Cache.TTL = DefaultCacheTTL
        }</span>
        <span class="cov0" title="0">if c.Rendering.JSTimeout &lt; time.Second </span><span class="cov0" title="0">{
                c.Rendering.JSTimeout = DefaultJSTimeout
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package config

import (
        "os"
        "path/filepath"
        "time"
)

// Default values
const (
        // Output defaults
        DefaultOutputDir = "./docs"

        // Concurrency defaults
        DefaultWorkers  = 5
        DefaultTimeout  = 30 * time.Second
        DefaultMaxDepth = 3

        // Cache defaults
        DefaultCacheEnabled = true
        DefaultCacheTTL     = 24 * time.Hour

        // Rendering defaults
        DefaultJSTimeout   = 60 * time.Second
        DefaultScrollToEnd = true

        // Stealth defaults
        DefaultRandomDelayMin = 1 * time.Second
        DefaultRandomDelayMax = 3 * time.Second

        // Logging defaults
        DefaultLogLevel  = "info"
        DefaultLogFormat = "pretty"
)

// Default exclude patterns
var DefaultExcludePatterns = []string{
        `.*\.pdf$`,
        `.*/login.*`,
        `.*/logout.*`,
        `.*/admin.*`,
        `.*/sign-in.*`,
        `.*/sign-up.*`,
}

// ConfigDir returns the config directory path
func ConfigDir() string <span class="cov0" title="0">{
        home, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return ".repodocs"
        }</span>
        <span class="cov0" title="0">return filepath.Join(home, ".repodocs")</span>
}

// CacheDir returns the cache directory path
func CacheDir() string <span class="cov0" title="0">{
        return filepath.Join(ConfigDir(), "cache")
}</span>

// ConfigFilePath returns the config file path
func ConfigFilePath() string <span class="cov0" title="0">{
        return filepath.Join(ConfigDir(), "config.yaml")
}</span>

// Default returns the default configuration
func Default() *Config <span class="cov0" title="0">{
        return &amp;Config{
                Output: OutputConfig{
                        Directory:    DefaultOutputDir,
                        Flat:         false,
                        JSONMetadata: false,
                        Overwrite:    false,
                },
                Concurrency: ConcurrencyConfig{
                        Workers:  DefaultWorkers,
                        Timeout:  DefaultTimeout,
                        MaxDepth: DefaultMaxDepth,
                },
                Cache: CacheConfig{
                        Enabled:   DefaultCacheEnabled,
                        TTL:       DefaultCacheTTL,
                        Directory: CacheDir(),
                },
                Rendering: RenderingConfig{
                        ForceJS:     false,
                        JSTimeout:   DefaultJSTimeout,
                        ScrollToEnd: DefaultScrollToEnd,
                },
                Stealth: StealthConfig{
                        UserAgent:      "",
                        RandomDelayMin: DefaultRandomDelayMin,
                        RandomDelayMax: DefaultRandomDelayMax,
                },
                Exclude: DefaultExcludePatterns,
                Logging: LoggingConfig{
                        Level:  DefaultLogLevel,
                        Format: DefaultLogFormat,
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package config

import (
        "os"
        "strings"

        "github.com/spf13/viper"
)

// Load loads configuration from file, environment, and defaults
// Uses the global viper instance to access CLI flag bindings
func Load() (*Config, error) <span class="cov0" title="0">{
        // Use global viper instance to get CLI flag bindings
        v := viper.GetViper()

        // Set defaults
        setDefaults(v)

        // Config file settings
        v.SetConfigName("config")
        v.SetConfigType("yaml")
        v.AddConfigPath(ConfigDir())
        v.AddConfigPath(".")

        // Read config file (ignore if not found)
        if err := v.ReadInConfig(); err != nil </span><span class="cov0" title="0">{
                if _, ok := err.(viper.ConfigFileNotFoundError); !ok </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        // Environment variables (REPODOCS_*)
        <span class="cov0" title="0">v.SetEnvPrefix("REPODOCS")
        v.SetEnvKeyReplacer(strings.NewReplacer(".", "_"))
        v.AutomaticEnv()

        // Unmarshal config
        var cfg Config
        if err := v.Unmarshal(&amp;cfg); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Validate and apply defaults for invalid values
        <span class="cov0" title="0">if err := cfg.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;cfg, nil</span>
}

// LoadWithViper loads configuration and returns the viper instance
// This is useful for merging CLI flags later
func LoadWithViper() (*Config, *viper.Viper, error) <span class="cov0" title="0">{
        v := viper.New()

        // Set defaults
        setDefaults(v)

        // Config file settings
        v.SetConfigName("config")
        v.SetConfigType("yaml")
        v.AddConfigPath(ConfigDir())
        v.AddConfigPath(".")

        // Read config file (ignore if not found)
        if err := v.ReadInConfig(); err != nil </span><span class="cov0" title="0">{
                if _, ok := err.(viper.ConfigFileNotFoundError); !ok </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>
        }

        // Environment variables (REPODOCS_*)
        <span class="cov0" title="0">v.SetEnvPrefix("REPODOCS")
        v.SetEnvKeyReplacer(strings.NewReplacer(".", "_"))
        v.AutomaticEnv()

        // Unmarshal config
        var cfg Config
        if err := v.Unmarshal(&amp;cfg); err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        // Validate
        <span class="cov0" title="0">if err := cfg.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">return &amp;cfg, v, nil</span>
}

// setDefaults sets default values in viper
func setDefaults(v *viper.Viper) <span class="cov0" title="0">{
        // Output defaults
        v.SetDefault("output.directory", DefaultOutputDir)
        v.SetDefault("output.flat", false)
        v.SetDefault("output.json_metadata", false)
        v.SetDefault("output.overwrite", false)

        // Concurrency defaults
        v.SetDefault("concurrency.workers", DefaultWorkers)
        v.SetDefault("concurrency.timeout", DefaultTimeout)
        v.SetDefault("concurrency.max_depth", DefaultMaxDepth)

        // Cache defaults
        v.SetDefault("cache.enabled", DefaultCacheEnabled)
        v.SetDefault("cache.ttl", DefaultCacheTTL)
        v.SetDefault("cache.directory", CacheDir())

        // Rendering defaults
        v.SetDefault("rendering.force_js", false)
        v.SetDefault("rendering.js_timeout", DefaultJSTimeout)
        v.SetDefault("rendering.scroll_to_end", DefaultScrollToEnd)

        // Stealth defaults
        v.SetDefault("stealth.user_agent", "")
        v.SetDefault("stealth.random_delay_min", DefaultRandomDelayMin)
        v.SetDefault("stealth.random_delay_max", DefaultRandomDelayMax)

        // Exclude defaults
        v.SetDefault("exclude", DefaultExcludePatterns)

        // Logging defaults
        v.SetDefault("logging.level", DefaultLogLevel)
        v.SetDefault("logging.format", DefaultLogFormat)
}</span>

// EnsureConfigDir creates the config directory if it doesn't exist
func EnsureConfigDir() error <span class="cov0" title="0">{
        dir := ConfigDir()
        return os.MkdirAll(dir, 0755)
}</span>

// EnsureCacheDir creates the cache directory if it doesn't exist
func EnsureCacheDir() error <span class="cov0" title="0">{
        dir := CacheDir()
        return os.MkdirAll(dir, 0755)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package converter

import (
        "bytes"
        "io"
        "strings"

        "golang.org/x/net/html/charset"
        "golang.org/x/text/encoding"
        "golang.org/x/text/encoding/htmlindex"
        "golang.org/x/text/transform"
)

// DetectEncoding detects the character encoding of HTML content
func DetectEncoding(content []byte) string <span class="cov0" title="0">{
        // Try to detect from content-type meta tag or charset attribute
        contentStr := string(content[:min(1024, len(content))])

        // Look for charset in meta tag
        if enc := extractCharsetFromMeta(contentStr); enc != "" </span><span class="cov0" title="0">{
                return enc
        }</span>

        // Use golang.org/x/net/html/charset for detection
        <span class="cov0" title="0">_, name, _ := charset.DetermineEncoding(content, "")
        if name != "" </span><span class="cov0" title="0">{
                return name
        }</span>

        // Default to UTF-8
        <span class="cov0" title="0">return "utf-8"</span>
}

// extractCharsetFromMeta extracts charset from meta tag
func extractCharsetFromMeta(html string) string <span class="cov0" title="0">{
        html = strings.ToLower(html)

        // Look for &lt;meta charset="..."&gt;
        if idx := strings.Index(html, "charset="); idx != -1 </span><span class="cov0" title="0">{
                start := idx + 8
                end := start

                // Skip quote if present
                if start &lt; len(html) &amp;&amp; (html[start] == '"' || html[start] == '\'') </span><span class="cov0" title="0">{
                        start++
                }</span>

                // Find end of charset value
                <span class="cov0" title="0">for end = start; end &lt; len(html); end++ </span><span class="cov0" title="0">{
                        c := html[end]
                        if c == '"' || c == '\'' || c == ';' || c == '&gt;' || c == ' ' </span><span class="cov0" title="0">{
                                break</span>
                        }
                }

                <span class="cov0" title="0">if end &gt; start </span><span class="cov0" title="0">{
                        return strings.TrimSpace(html[start:end])
                }</span>
        }

        <span class="cov0" title="0">return ""</span>
}

// ConvertToUTF8 converts content from detected encoding to UTF-8
func ConvertToUTF8(content []byte) ([]byte, error) <span class="cov0" title="0">{
        enc := DetectEncoding(content)

        // Already UTF-8
        if enc == "utf-8" || enc == "utf8" </span><span class="cov0" title="0">{
                return content, nil
        }</span>

        // Get encoder for the detected charset
        <span class="cov0" title="0">e, err := htmlindex.Get(enc)
        if err != nil </span><span class="cov0" title="0">{
                // Unknown encoding, return as-is
                return content, nil
        }</span>

        // Decode to UTF-8
        <span class="cov0" title="0">reader := transform.NewReader(bytes.NewReader(content), e.NewDecoder())
        return io.ReadAll(reader)</span>
}

// IsUTF8 checks if content is valid UTF-8
func IsUTF8(content []byte) bool <span class="cov0" title="0">{
        enc := DetectEncoding(content)
        return enc == "utf-8" || enc == "utf8"
}</span>

// GetEncoder returns the encoding for a charset name
func GetEncoder(charsetName string) (encoding.Encoding, error) <span class="cov0" title="0">{
        return htmlindex.Get(charsetName)
}</span>

// min returns the minimum of two integers
func min(a, b int) int <span class="cov0" title="0">{
        if a &lt; b </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov0" title="0">return b</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package converter

import (
        "fmt"
        "regexp"
        "strings"

        md "github.com/JohannesKaufmann/html-to-markdown/v2"
        "github.com/quantmind-br/repodocs-go/internal/domain"
        "gopkg.in/yaml.v3"
)

// MarkdownConverter converts HTML to Markdown
type MarkdownConverter struct {
        domain string
}

// MarkdownOptions contains options for Markdown conversion
type MarkdownOptions struct {
        Domain          string
        CodeBlockStyle  string // "fenced" or "indented"
        HeadingStyle    string // "atx" or "setext"
        BulletListStyle string // "-", "*", or "+"
}

// DefaultMarkdownOptions returns default Markdown options
func DefaultMarkdownOptions() MarkdownOptions <span class="cov0" title="0">{
        return MarkdownOptions{
                CodeBlockStyle:  "fenced",
                HeadingStyle:    "atx",
                BulletListStyle: "-",
        }
}</span>

// NewMarkdownConverter creates a new Markdown converter
func NewMarkdownConverter(opts MarkdownOptions) *MarkdownConverter <span class="cov0" title="0">{
        return &amp;MarkdownConverter{
                domain: opts.Domain,
        }
}</span>

// Convert converts HTML to Markdown
func (c *MarkdownConverter) Convert(html string) (string, error) <span class="cov0" title="0">{
        // html-to-markdown v2 uses ConvertString directly
        markdown, err := md.ConvertString(html)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to convert HTML to Markdown: %w", err)
        }</span>

        // Clean up the markdown
        <span class="cov0" title="0">markdown = c.cleanMarkdown(markdown)

        return markdown, nil</span>
}

// cleanMarkdown cleans up the converted markdown
func (c *MarkdownConverter) cleanMarkdown(markdown string) string <span class="cov0" title="0">{
        // Remove excessive blank lines (more than 2 consecutive)
        for strings.Contains(markdown, "\n\n\n\n") </span><span class="cov0" title="0">{
                markdown = strings.ReplaceAll(markdown, "\n\n\n\n", "\n\n\n")
        }</span>

        // Trim leading/trailing whitespace
        <span class="cov0" title="0">markdown = strings.TrimSpace(markdown)

        return markdown</span>
}

// GenerateFrontmatter generates YAML frontmatter for a document
func GenerateFrontmatter(doc *domain.Document) (string, error) <span class="cov0" title="0">{
        fm := doc.ToFrontmatter()
        data, err := yaml.Marshal(fm)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("---\n%s---\n\n", string(data)), nil</span>
}

// AddFrontmatter adds YAML frontmatter to markdown content
func AddFrontmatter(markdown string, doc *domain.Document) (string, error) <span class="cov0" title="0">{
        frontmatter, err := GenerateFrontmatter(doc)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return frontmatter + markdown, nil</span>
}

// CountWords counts words in text
func CountWords(text string) int <span class="cov0" title="0">{
        words := strings.Fields(text)
        return len(words)
}</span>

// CountChars counts characters in text
func CountChars(text string) int <span class="cov0" title="0">{
        return len(text)
}</span>

// StripMarkdown removes markdown formatting to get plain text
func StripMarkdown(markdown string) string <span class="cov0" title="0">{
        // Remove code blocks
        markdown = removeCodeBlocks(markdown)

        // Remove links but keep text: [text](url) -&gt; text
        linkRegex := regexp.MustCompile(`\[([^\]]+)\]\([^)]+\)`)
        markdown = linkRegex.ReplaceAllString(markdown, "$1")

        // Remove images: ![alt](url) -&gt; alt
        imageRegex := regexp.MustCompile(`!\[([^\]]*)\]\([^)]+\)`)
        markdown = imageRegex.ReplaceAllString(markdown, "$1")

        // Remove emphasis: **bold** -&gt; bold, *italic* -&gt; italic
        markdown = regexp.MustCompile(`\*\*([^*]+)\*\*`).ReplaceAllString(markdown, "$1")
        markdown = regexp.MustCompile(`\*([^*]+)\*`).ReplaceAllString(markdown, "$1")
        markdown = regexp.MustCompile(`__([^_]+)__`).ReplaceAllString(markdown, "$1")
        markdown = regexp.MustCompile(`_([^_]+)_`).ReplaceAllString(markdown, "$1")

        // Remove headers: # Header -&gt; Header
        markdown = regexp.MustCompile(`(?m)^#{1,6}\s+`).ReplaceAllString(markdown, "")

        // Remove horizontal rules
        markdown = regexp.MustCompile(`(?m)^[\-*_]{3,}$`).ReplaceAllString(markdown, "")

        // Remove blockquotes
        markdown = regexp.MustCompile(`(?m)^&gt;\s+`).ReplaceAllString(markdown, "")

        // Remove list markers
        markdown = regexp.MustCompile(`(?m)^[\s]*[\-*+]\s+`).ReplaceAllString(markdown, "")
        markdown = regexp.MustCompile(`(?m)^[\s]*\d+\.\s+`).ReplaceAllString(markdown, "")

        return strings.TrimSpace(markdown)
}</span>

// removeCodeBlocks removes fenced code blocks
func removeCodeBlocks(markdown string) string <span class="cov0" title="0">{
        // Remove fenced code blocks
        fenced := regexp.MustCompile("(?s)```[^`]*```")
        markdown = fenced.ReplaceAllString(markdown, "")

        // Remove indented code blocks (lines starting with 4 spaces or tab)
        indented := regexp.MustCompile(`(?m)^(    |\t).*$`)
        markdown = indented.ReplaceAllString(markdown, "")

        return markdown
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package converter

import (
        "context"
        "crypto/sha256"
        "encoding/hex"
        "strings"
        "time"

        "github.com/PuerkitoBio/goquery"
        "github.com/quantmind-br/repodocs-go/internal/domain"
)

// Pipeline orchestrates the HTML to Markdown conversion process
type Pipeline struct {
        sanitizer   *Sanitizer
        extractor   *ExtractContent
        mdConverter *MarkdownConverter
}

// PipelineOptions contains options for the conversion pipeline
type PipelineOptions struct {
        BaseURL         string
        ContentSelector string
}

// NewPipeline creates a new conversion pipeline
func NewPipeline(opts PipelineOptions) *Pipeline <span class="cov0" title="0">{
        sanitizer := NewSanitizer(SanitizerOptions{
                BaseURL:          opts.BaseURL,
                RemoveNavigation: true,
                RemoveComments:   true,
        })

        extractor := NewExtractContent(opts.ContentSelector)

        mdConverter := NewMarkdownConverter(MarkdownOptions{
                Domain:          opts.BaseURL,
                CodeBlockStyle:  "fenced",
                HeadingStyle:    "atx",
                BulletListStyle: "-",
        })

        return &amp;Pipeline{
                sanitizer:   sanitizer,
                extractor:   extractor,
                mdConverter: mdConverter,
        }
}</span>

// Convert processes HTML content and returns a Document
func (p *Pipeline) Convert(ctx context.Context, html string, sourceURL string) (*domain.Document, error) <span class="cov0" title="0">{
        // Step 1: Convert encoding to UTF-8
        htmlBytes, err := ConvertToUTF8([]byte(html))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">html = string(htmlBytes)

        // Step 2: Extract main content
        content, title, err := p.extractor.Extract(html, sourceURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Step 3: Sanitize HTML
        <span class="cov0" title="0">sanitized, err := p.sanitizer.Sanitize(content)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Step 4: Convert to Markdown
        <span class="cov0" title="0">markdown, err := p.mdConverter.Convert(sanitized)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Step 5: Extract metadata
        <span class="cov0" title="0">doc, err := goquery.NewDocumentFromReader(strings.NewReader(html))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">description := ExtractDescription(doc)
        headers := ExtractHeaders(sanitized)
        links := ExtractLinks(sanitized, sourceURL)

        // Step 6: Calculate statistics
        plainText := StripMarkdown(markdown)
        wordCount := CountWords(plainText)
        charCount := CountChars(plainText)
        contentHash := calculateHash(markdown)

        // Step 7: Build document
        document := &amp;domain.Document{
                URL:            sourceURL,
                Title:          title,
                Description:    description,
                Content:        markdown,
                HTMLContent:    html,
                FetchedAt:      time.Now(),
                ContentHash:    contentHash,
                WordCount:      wordCount,
                CharCount:      charCount,
                Links:          links,
                Headers:        headers,
                RenderedWithJS: false,
                SourceStrategy: "",
                CacheHit:       false,
        }

        return document, nil</span>
}

// calculateHash calculates SHA256 hash of content
func calculateHash(content string) string <span class="cov0" title="0">{
        hash := sha256.Sum256([]byte(content))
        return hex.EncodeToString(hash[:])
}</span>

// ConvertHTML is a convenience function for simple HTML to Markdown conversion
func ConvertHTML(html, sourceURL string) (*domain.Document, error) <span class="cov0" title="0">{
        pipeline := NewPipeline(PipelineOptions{
                BaseURL: sourceURL,
        })
        return pipeline.Convert(context.Background(), html, sourceURL)
}</span>

// ConvertHTMLWithSelector converts HTML with a specific content selector
func ConvertHTMLWithSelector(html, sourceURL, selector string) (*domain.Document, error) <span class="cov0" title="0">{
        pipeline := NewPipeline(PipelineOptions{
                BaseURL:         sourceURL,
                ContentSelector: selector,
        })
        return pipeline.Convert(context.Background(), html, sourceURL)
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package converter

import (
        "net/url"
        "strings"

        "github.com/PuerkitoBio/goquery"
        "github.com/go-shiori/go-readability"
)

// ExtractContent extracts the main content from HTML
type ExtractContent struct {
        selector string
}

// ExtractOptions contains options for content extraction
type ExtractOptions struct {
        Selector string // CSS selector for main content
        URL      string // Source URL for resolving relative links
}

// NewExtractContent creates a new content extractor
func NewExtractContent(selector string) *ExtractContent <span class="cov0" title="0">{
        return &amp;ExtractContent{selector: selector}
}</span>

// Extract extracts main content from HTML
func (e *ExtractContent) Extract(html, sourceURL string) (string, string, error) <span class="cov0" title="0">{
        // If a selector is provided, use it directly
        if e.selector != "" </span><span class="cov0" title="0">{
                return e.extractWithSelector(html, sourceURL)
        }</span>

        // Otherwise, use readability algorithm
        <span class="cov0" title="0">return e.extractWithReadability(html, sourceURL)</span>
}

// extractWithSelector extracts content using a CSS selector
func (e *ExtractContent) extractWithSelector(html, sourceURL string) (string, string, error) <span class="cov0" title="0">{
        doc, err := goquery.NewDocumentFromReader(strings.NewReader(html))
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        // Find the content element
        <span class="cov0" title="0">content := doc.Find(e.selector).First()
        if content.Length() == 0 </span><span class="cov0" title="0">{
                // Fallback to readability if selector doesn't match
                return e.extractWithReadability(html, sourceURL)
        }</span>

        // Get title
        <span class="cov0" title="0">title := extractTitle(doc)

        // Get content HTML
        contentHTML, err := content.Html()
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        <span class="cov0" title="0">return contentHTML, title, nil</span>
}

// extractWithReadability extracts content using the readability algorithm
func (e *ExtractContent) extractWithReadability(html, sourceURL string) (string, string, error) <span class="cov0" title="0">{
        parsedURL, err := url.Parse(sourceURL)
        if err != nil </span><span class="cov0" title="0">{
                parsedURL = &amp;url.URL{Scheme: "https", Host: "example.com"}
        }</span>

        <span class="cov0" title="0">article, err := readability.FromReader(strings.NewReader(html), parsedURL)
        if err != nil </span><span class="cov0" title="0">{
                // If readability fails, try to extract the body
                return e.extractBody(html)
        }</span>

        <span class="cov0" title="0">return article.Content, article.Title, nil</span>
}

// extractBody extracts the body content as a fallback
func (e *ExtractContent) extractBody(html string) (string, string, error) <span class="cov0" title="0">{
        doc, err := goquery.NewDocumentFromReader(strings.NewReader(html))
        if err != nil </span><span class="cov0" title="0">{
                return html, "", nil
        }</span>

        <span class="cov0" title="0">title := extractTitle(doc)

        // Get body content
        body := doc.Find("body")
        if body.Length() == 0 </span><span class="cov0" title="0">{
                return html, title, nil
        }</span>

        <span class="cov0" title="0">bodyHTML, err := body.Html()
        if err != nil </span><span class="cov0" title="0">{
                return html, title, nil
        }</span>

        <span class="cov0" title="0">return bodyHTML, title, nil</span>
}

// extractTitle extracts the page title
func extractTitle(doc *goquery.Document) string <span class="cov0" title="0">{
        // Try &lt;title&gt; tag
        title := strings.TrimSpace(doc.Find("title").First().Text())
        if title != "" </span><span class="cov0" title="0">{
                return title
        }</span>

        // Try &lt;h1&gt; tag
        <span class="cov0" title="0">h1 := strings.TrimSpace(doc.Find("h1").First().Text())
        if h1 != "" </span><span class="cov0" title="0">{
                return h1
        }</span>

        // Try og:title meta tag
        <span class="cov0" title="0">ogTitle, exists := doc.Find("meta[property='og:title']").Attr("content")
        if exists &amp;&amp; ogTitle != "" </span><span class="cov0" title="0">{
                return ogTitle
        }</span>

        <span class="cov0" title="0">return ""</span>
}

// ExtractDescription extracts the page description
func ExtractDescription(doc *goquery.Document) string <span class="cov0" title="0">{
        // Try meta description
        desc, exists := doc.Find("meta[name='description']").Attr("content")
        if exists &amp;&amp; desc != "" </span><span class="cov0" title="0">{
                return strings.TrimSpace(desc)
        }</span>

        // Try og:description
        <span class="cov0" title="0">ogDesc, exists := doc.Find("meta[property='og:description']").Attr("content")
        if exists &amp;&amp; ogDesc != "" </span><span class="cov0" title="0">{
                return strings.TrimSpace(ogDesc)
        }</span>

        <span class="cov0" title="0">return ""</span>
}

// ExtractHeaders extracts all headers from HTML
func ExtractHeaders(html string) map[string][]string <span class="cov0" title="0">{
        headers := make(map[string][]string)

        doc, err := goquery.NewDocumentFromReader(strings.NewReader(html))
        if err != nil </span><span class="cov0" title="0">{
                return headers
        }</span>

        <span class="cov0" title="0">for i := 1; i &lt;= 6; i++ </span><span class="cov0" title="0">{
                tag := string('h') + string('0'+byte(i)) // h1, h2, ..., h6
                doc.Find(tag).Each(func(_ int, sel *goquery.Selection) </span><span class="cov0" title="0">{
                        text := strings.TrimSpace(sel.Text())
                        if text != "" </span><span class="cov0" title="0">{
                                headers[tag] = append(headers[tag], text)
                        }</span>
                })
        }

        <span class="cov0" title="0">return headers</span>
}

// ExtractLinks extracts all links from HTML
func ExtractLinks(html, baseURL string) []string <span class="cov0" title="0">{
        var links []string

        doc, err := goquery.NewDocumentFromReader(strings.NewReader(html))
        if err != nil </span><span class="cov0" title="0">{
                return links
        }</span>

        <span class="cov0" title="0">base, _ := url.Parse(baseURL)

        doc.Find("a[href]").Each(func(_ int, sel *goquery.Selection) </span><span class="cov0" title="0">{
                href, exists := sel.Attr("href")
                if !exists || href == "" </span><span class="cov0" title="0">{
                        return
                }</span>

                // Skip anchors, javascript, mailto
                <span class="cov0" title="0">if strings.HasPrefix(href, "#") ||
                        strings.HasPrefix(href, "javascript:") ||
                        strings.HasPrefix(href, "mailto:") ||
                        strings.HasPrefix(href, "tel:") </span><span class="cov0" title="0">{
                        return
                }</span>

                // Resolve relative URLs
                <span class="cov0" title="0">if base != nil &amp;&amp; !strings.HasPrefix(href, "http") </span><span class="cov0" title="0">{
                        refURL, err := url.Parse(href)
                        if err == nil </span><span class="cov0" title="0">{
                                href = base.ResolveReference(refURL).String()
                        }</span>
                }

                <span class="cov0" title="0">links = append(links, href)</span>
        })

        <span class="cov0" title="0">return links</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package converter

import (
        "net/url"
        "regexp"
        "strings"

        "github.com/PuerkitoBio/goquery"
)

// TagsToRemove are HTML tags that should be completely removed
var TagsToRemove = []string{
        "script",
        "style",
        "noscript",
        "iframe",
        "object",
        "embed",
        "applet",
        "form",
        "input",
        "button",
        "select",
        "textarea",
        "nav",
        "footer",
        "header",
        "aside",
        "advertisement",
        "banner",
}

// ClassesToRemove are CSS classes that indicate non-content elements
var ClassesToRemove = []string{
        "sidebar",
        "navigation",
        "nav",
        "menu",
        "footer",
        "header",
        "banner",
        "advertisement",
        "ad",
        "social",
        "share",
        "comment",
        "comments",
        "related",
        "recommended",
}

// IDsToRemove are element IDs that indicate non-content elements
var IDsToRemove = []string{
        "sidebar",
        "navigation",
        "nav",
        "menu",
        "footer",
        "header",
        "banner",
        "advertisement",
        "comments",
}

// Sanitizer cleans HTML content for conversion
type Sanitizer struct {
        baseURL          string
        removeNavigation bool
        removeComments   bool
}

// SanitizerOptions contains options for the sanitizer
type SanitizerOptions struct {
        BaseURL          string
        RemoveNavigation bool
        RemoveComments   bool
}

// NewSanitizer creates a new sanitizer
func NewSanitizer(opts SanitizerOptions) *Sanitizer <span class="cov0" title="0">{
        return &amp;Sanitizer{
                baseURL:          opts.BaseURL,
                removeNavigation: opts.RemoveNavigation,
                removeComments:   opts.RemoveComments,
        }
}</span>

// Sanitize cleans HTML content
func (s *Sanitizer) Sanitize(html string) (string, error) <span class="cov0" title="0">{
        doc, err := goquery.NewDocumentFromReader(strings.NewReader(html))
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Remove unwanted tags
        <span class="cov0" title="0">for _, tag := range TagsToRemove </span><span class="cov0" title="0">{
                doc.Find(tag).Remove()
        }</span>

        // Remove elements by class
        <span class="cov0" title="0">if s.removeNavigation </span><span class="cov0" title="0">{
                for _, class := range ClassesToRemove </span><span class="cov0" title="0">{
                        doc.Find("." + class).Remove()
                        doc.Find("[class*='" + class + "']").Remove()
                }</span>

                // Remove elements by ID
                <span class="cov0" title="0">for _, id := range IDsToRemove </span><span class="cov0" title="0">{
                        doc.Find("#" + id).Remove()
                }</span>
        }

        // Remove hidden elements
        <span class="cov0" title="0">doc.Find("[style*='display:none']").Remove()
        doc.Find("[style*='display: none']").Remove()
        doc.Find("[hidden]").Remove()

        // Normalize URLs if base URL is provided
        if s.baseURL != "" </span><span class="cov0" title="0">{
                s.normalizeURLs(doc)
        }</span>

        // Remove empty paragraphs and divs
        <span class="cov0" title="0">s.removeEmptyElements(doc)

        // Get cleaned HTML
        result, err := doc.Html()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// normalizeURLs converts relative URLs to absolute URLs
func (s *Sanitizer) normalizeURLs(doc *goquery.Document) <span class="cov0" title="0">{
        base, err := url.Parse(s.baseURL)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Normalize href attributes
        <span class="cov0" title="0">doc.Find("a[href]").Each(func(_ int, sel *goquery.Selection) </span><span class="cov0" title="0">{
                if href, exists := sel.Attr("href"); exists </span><span class="cov0" title="0">{
                        if absoluteURL := resolveURL(base, href); absoluteURL != "" </span><span class="cov0" title="0">{
                                sel.SetAttr("href", absoluteURL)
                        }</span>
                }
        })

        // Normalize src attributes
        <span class="cov0" title="0">doc.Find("[src]").Each(func(_ int, sel *goquery.Selection) </span><span class="cov0" title="0">{
                if src, exists := sel.Attr("src"); exists </span><span class="cov0" title="0">{
                        if absoluteURL := resolveURL(base, src); absoluteURL != "" </span><span class="cov0" title="0">{
                                sel.SetAttr("src", absoluteURL)
                        }</span>
                }
        })

        // Normalize srcset attributes
        <span class="cov0" title="0">doc.Find("[srcset]").Each(func(_ int, sel *goquery.Selection) </span><span class="cov0" title="0">{
                if srcset, exists := sel.Attr("srcset"); exists </span><span class="cov0" title="0">{
                        sel.SetAttr("srcset", normalizeSrcset(base, srcset))
                }</span>
        })
}

// resolveURL resolves a relative URL against a base URL
func resolveURL(base *url.URL, ref string) string <span class="cov0" title="0">{
        // Skip empty, fragment, javascript, mailto, and data URLs
        if ref == "" || strings.HasPrefix(ref, "#") ||
                strings.HasPrefix(ref, "javascript:") ||
                strings.HasPrefix(ref, "mailto:") ||
                strings.HasPrefix(ref, "data:") </span><span class="cov0" title="0">{
                return ref
        }</span>

        <span class="cov0" title="0">refURL, err := url.Parse(ref)
        if err != nil </span><span class="cov0" title="0">{
                return ref
        }</span>

        <span class="cov0" title="0">return base.ResolveReference(refURL).String()</span>
}

// normalizeSrcset normalizes URLs in srcset attribute
func normalizeSrcset(base *url.URL, srcset string) string <span class="cov0" title="0">{
        parts := strings.Split(srcset, ",")
        for i, part := range parts </span><span class="cov0" title="0">{
                part = strings.TrimSpace(part)
                tokens := strings.Fields(part)
                if len(tokens) &gt; 0 </span><span class="cov0" title="0">{
                        tokens[0] = resolveURL(base, tokens[0])
                        parts[i] = strings.Join(tokens, " ")
                }</span>
        }
        <span class="cov0" title="0">return strings.Join(parts, ", ")</span>
}

// removeEmptyElements removes empty block elements
func (s *Sanitizer) removeEmptyElements(doc *goquery.Document) <span class="cov0" title="0">{
        emptyTags := []string{"p", "div", "span", "section", "article"}
        whitespaceRegex := regexp.MustCompile(`^\s*$`)

        for _, tag := range emptyTags </span><span class="cov0" title="0">{
                doc.Find(tag).Each(func(_ int, sel *goquery.Selection) </span><span class="cov0" title="0">{
                        text := strings.TrimSpace(sel.Text())
                        if whitespaceRegex.MatchString(text) &amp;&amp; sel.Children().Length() == 0 </span><span class="cov0" title="0">{
                                sel.Remove()
                        }</span>
                })
        }
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package domain

import (
        "errors"
        "fmt"
)

// Sentinel errors
var (
        // ErrNotFound indicates a resource was not found
        ErrNotFound = errors.New("not found")

        // ErrCacheMiss indicates a cache miss
        ErrCacheMiss = errors.New("cache miss")

        // ErrCacheExpired indicates the cached entry has expired
        ErrCacheExpired = errors.New("cache entry expired")

        // ErrRateLimited indicates rate limiting was encountered
        ErrRateLimited = errors.New("rate limited")

        // ErrBlocked indicates the request was blocked (e.g., by Cloudflare)
        ErrBlocked = errors.New("request blocked")

        // ErrTimeout indicates a timeout occurred
        ErrTimeout = errors.New("timeout")

        // ErrInvalidURL indicates an invalid URL was provided
        ErrInvalidURL = errors.New("invalid URL")

        // ErrNoStrategy indicates no strategy can handle the URL
        ErrNoStrategy = errors.New("no strategy found for URL")

        // ErrRenderFailed indicates JavaScript rendering failed
        ErrRenderFailed = errors.New("render failed")

        // ErrConversionFailed indicates HTML to Markdown conversion failed
        ErrConversionFailed = errors.New("conversion failed")

        // ErrWriteFailed indicates writing output failed
        ErrWriteFailed = errors.New("write failed")

        // ErrBrowserNotFound indicates Chrome/Chromium was not found
        ErrBrowserNotFound = errors.New("browser not found")
)

// FetchError represents an error during fetching
type FetchError struct {
        URL        string
        StatusCode int
        Err        error
}

func (e *FetchError) Error() string <span class="cov0" title="0">{
        if e.StatusCode &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Sprintf("fetch error for %s: status %d: %v", e.URL, e.StatusCode, e.Err)
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("fetch error for %s: %v", e.URL, e.Err)</span>
}

func (e *FetchError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

// NewFetchError creates a new FetchError
func NewFetchError(url string, statusCode int, err error) *FetchError <span class="cov0" title="0">{
        return &amp;FetchError{
                URL:        url,
                StatusCode: statusCode,
                Err:        err,
        }
}</span>

// RetryableError indicates an error that can be retried
type RetryableError struct {
        Err        error
        RetryAfter int // Seconds to wait before retry, 0 if unknown
}

func (e *RetryableError) Error() string <span class="cov0" title="0">{
        if e.RetryAfter &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Sprintf("retryable error (retry after %ds): %v", e.RetryAfter, e.Err)
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("retryable error: %v", e.Err)</span>
}

func (e *RetryableError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

// IsRetryable checks if an error should be retried
func IsRetryable(err error) bool <span class="cov0" title="0">{
        var retryable *RetryableError
        if errors.As(err, &amp;retryable) </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">var fetchErr *FetchError
        if errors.As(err, &amp;fetchErr) </span><span class="cov0" title="0">{
                // Retry on specific status codes
                switch fetchErr.StatusCode </span>{
                case 429, 503, 502, 504:<span class="cov0" title="0">
                        return true</span>
                }
                // Retry on Cloudflare errors
                <span class="cov0" title="0">if fetchErr.StatusCode &gt;= 520 &amp;&amp; fetchErr.StatusCode &lt;= 530 </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return errors.Is(err, ErrRateLimited) || errors.Is(err, ErrTimeout)</span>
}

// ValidationError represents a validation error
type ValidationError struct {
        Field   string
        Message string
}

func (e *ValidationError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("validation error for %s: %s", e.Field, e.Message)
}</span>

// NewValidationError creates a new ValidationError
func NewValidationError(field, message string) *ValidationError <span class="cov0" title="0">{
        return &amp;ValidationError{
                Field:   field,
                Message: message,
        }
}</span>

// StrategyError represents an error in strategy execution
type StrategyError struct {
        Strategy string
        URL      string
        Err      error
}

func (e *StrategyError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("strategy %s failed for %s: %v", e.Strategy, e.URL, e.Err)
}</span>

func (e *StrategyError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

// NewStrategyError creates a new StrategyError
func NewStrategyError(strategy, url string, err error) *StrategyError <span class="cov0" title="0">{
        return &amp;StrategyError{
                Strategy: strategy,
                URL:      url,
                Err:      err,
        }
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package domain

import "time"

// Document represents a processed documentation page
type Document struct {
        URL            string              `json:"url"`
        Title          string              `json:"title"`
        Description    string              `json:"description,omitempty"`
        Content        string              `json:"-"` // Markdown content (not in JSON)
        HTMLContent    string              `json:"-"` // Original HTML (not in JSON)
        FetchedAt      time.Time           `json:"fetched_at"`
        ContentHash    string              `json:"content_hash"`
        WordCount      int                 `json:"word_count"`
        CharCount      int                 `json:"char_count"`
        Links          []string            `json:"links,omitempty"`
        Headers        map[string][]string `json:"headers,omitempty"` // h1, h2, h3...
        RenderedWithJS bool                `json:"rendered_with_js"`
        SourceStrategy string              `json:"source_strategy"`
        CacheHit       bool                `json:"cache_hit"`
        RelativePath   string              `json:"-"` // Relative path for Git-sourced files (used for output structure)
}

// Page represents a raw fetched page before conversion
type Page struct {
        URL         string
        Content     []byte
        ContentType string
        StatusCode  int
        FetchedAt   time.Time
        FromCache   bool
        RenderedJS  bool
}

// CacheEntry represents a cached page entry
type CacheEntry struct {
        URL         string    `json:"url"`
        Content     []byte    `json:"content"`
        ContentType string    `json:"content_type"`
        FetchedAt   time.Time `json:"fetched_at"`
        ExpiresAt   time.Time `json:"expires_at"`
}

// SitemapURL represents a URL entry in a sitemap
type SitemapURL struct {
        Loc        string    `xml:"loc"`
        LastMod    time.Time `xml:"-"`
        LastModStr string    `xml:"lastmod"`
        ChangeFreq string    `xml:"changefreq"`
        Priority   float64   `xml:"priority"`
}

// Sitemap represents a parsed sitemap
type Sitemap struct {
        URLs      []SitemapURL
        Sitemaps  []string // For sitemap index files
        IsIndex   bool
        SourceURL string
}

// LLMSLink represents a link parsed from llms.txt
type LLMSLink struct {
        Title string
        URL   string
}

// Metadata represents document metadata for JSON output
type Metadata struct {
        URL            string              `json:"url"`
        Title          string              `json:"title"`
        Description    string              `json:"description,omitempty"`
        FetchedAt      time.Time           `json:"fetched_at"`
        ContentHash    string              `json:"content_hash"`
        WordCount      int                 `json:"word_count"`
        CharCount      int                 `json:"char_count"`
        Links          []string            `json:"links,omitempty"`
        Headers        map[string][]string `json:"headers,omitempty"`
        RenderedWithJS bool                `json:"rendered_with_js"`
        SourceStrategy string              `json:"source_strategy"`
        CacheHit       bool                `json:"cache_hit"`
}

// ToMetadata converts a Document to Metadata
func (d *Document) ToMetadata() *Metadata <span class="cov0" title="0">{
        return &amp;Metadata{
                URL:            d.URL,
                Title:          d.Title,
                Description:    d.Description,
                FetchedAt:      d.FetchedAt,
                ContentHash:    d.ContentHash,
                WordCount:      d.WordCount,
                CharCount:      d.CharCount,
                Links:          d.Links,
                Headers:        d.Headers,
                RenderedWithJS: d.RenderedWithJS,
                SourceStrategy: d.SourceStrategy,
                CacheHit:       d.CacheHit,
        }
}</span>

// Frontmatter represents YAML frontmatter for markdown files
type Frontmatter struct {
        Title      string    `yaml:"title"`
        URL        string    `yaml:"url"`
        Source     string    `yaml:"source"`
        FetchedAt  time.Time `yaml:"fetched_at"`
        RenderedJS bool      `yaml:"rendered_js"`
        WordCount  int       `yaml:"word_count"`
}

// ToFrontmatter converts a Document to Frontmatter
func (d *Document) ToFrontmatter() *Frontmatter <span class="cov0" title="0">{
        return &amp;Frontmatter{
                Title:      d.Title,
                URL:        d.URL,
                Source:     d.SourceStrategy,
                FetchedAt:  d.FetchedAt,
                RenderedJS: d.RenderedWithJS,
                WordCount:  d.WordCount,
        }
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package fetcher

import (
        "context"
        "fmt"
        "io"
        "net/http"
        "net/url"
        "time"

        fhttp "github.com/bogdanfinn/fhttp"
        tls_client "github.com/bogdanfinn/tls-client"
        "github.com/bogdanfinn/tls-client/profiles"
        "github.com/quantmind-br/repodocs-go/internal/domain"
)

// Client is a stealth HTTP client using tls-client
type Client struct {
        tlsClient    tls_client.HttpClient
        userAgent    string
        retrier      *Retrier
        cache        domain.Cache
        cacheEnabled bool
        cacheTTL     time.Duration
}

// ClientOptions contains options for creating a Client
type ClientOptions struct {
        Timeout     time.Duration
        MaxRetries  int
        EnableCache bool
        CacheTTL    time.Duration
        Cache       domain.Cache
        UserAgent   string
        ProxyURL    string
}

// DefaultClientOptions returns default client options
func DefaultClientOptions() ClientOptions <span class="cov0" title="0">{
        return ClientOptions{
                Timeout:     30 * time.Second,
                MaxRetries:  3,
                EnableCache: true,
                CacheTTL:    24 * time.Hour,
                UserAgent:   "",
                ProxyURL:    "",
        }
}</span>

// NewClient creates a new stealth HTTP client
func NewClient(opts ClientOptions) (*Client, error) <span class="cov0" title="0">{
        if opts.Timeout &lt;= 0 </span><span class="cov0" title="0">{
                opts.Timeout = 30 * time.Second
        }</span>

        // TLS client options
        <span class="cov0" title="0">tlsOpts := []tls_client.HttpClientOption{
                tls_client.WithTimeoutSeconds(int(opts.Timeout.Seconds())),
                tls_client.WithClientProfile(profiles.Chrome_131),
                tls_client.WithRandomTLSExtensionOrder(),
                tls_client.WithNotFollowRedirects(),
        }

        if opts.ProxyURL != "" </span><span class="cov0" title="0">{
                tlsOpts = append(tlsOpts, tls_client.WithProxyUrl(opts.ProxyURL))
        }</span>

        <span class="cov0" title="0">tlsClient, err := tls_client.NewHttpClient(tls_client.NewNoopLogger(), tlsOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create tls client: %w", err)
        }</span>

        // Create retrier
        <span class="cov0" title="0">retrier := NewRetrier(RetrierOptions{
                MaxRetries:      opts.MaxRetries,
                InitialInterval: 1 * time.Second,
                MaxInterval:     30 * time.Second,
                Multiplier:      2.0,
        })

        return &amp;Client{
                tlsClient:    tlsClient,
                userAgent:    opts.UserAgent,
                retrier:      retrier,
                cache:        opts.Cache,
                cacheEnabled: opts.EnableCache,
                cacheTTL:     opts.CacheTTL,
        }, nil</span>
}

// Get fetches content from a URL
func (c *Client) Get(ctx context.Context, url string) (*domain.Response, error) <span class="cov0" title="0">{
        return c.GetWithHeaders(ctx, url, nil)
}</span>

// GetWithHeaders fetches content with custom headers
func (c *Client) GetWithHeaders(ctx context.Context, url string, extraHeaders map[string]string) (*domain.Response, error) <span class="cov0" title="0">{
        // Check cache first
        if c.cacheEnabled &amp;&amp; c.cache != nil </span><span class="cov0" title="0">{
                cached, err := c.getFromCache(ctx, url)
                if err == nil &amp;&amp; cached != nil </span><span class="cov0" title="0">{
                        return cached, nil
                }</span>
        }

        // Perform request with retry
        <span class="cov0" title="0">var resp *domain.Response
        err := c.retrier.Retry(ctx, func() error </span><span class="cov0" title="0">{
                var err error
                resp, err = c.doRequest(ctx, url, extraHeaders)
                return err
        }</span>)

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Cache the response
        <span class="cov0" title="0">if c.cacheEnabled &amp;&amp; c.cache != nil &amp;&amp; resp != nil </span><span class="cov0" title="0">{
                _ = c.saveToCache(ctx, url, resp)
        }</span>

        <span class="cov0" title="0">return resp, nil</span>
}

// doRequest performs the actual HTTP request
func (c *Client) doRequest(ctx context.Context, targetURL string, extraHeaders map[string]string) (*domain.Response, error) <span class="cov0" title="0">{
        // Create request using fhttp (tls-client's http package)
        req, err := fhttp.NewRequest(fhttp.MethodGet, targetURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        // Apply stealth headers
        <span class="cov0" title="0">headers := StealthHeaders(c.userAgent)
        for k, v := range headers </span><span class="cov0" title="0">{
                req.Header.Set(k, v)
        }</span>

        // Apply extra headers
        <span class="cov0" title="0">for k, v := range extraHeaders </span><span class="cov0" title="0">{
                req.Header.Set(k, v)
        }</span>

        // Perform request
        <span class="cov0" title="0">resp, err := c.tlsClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, &amp;domain.FetchError{
                        URL: targetURL,
                        Err: fmt.Errorf("request failed: %w", err),
                }
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        // Check for error status codes
        if resp.StatusCode &gt;= 400 </span><span class="cov0" title="0">{
                if ShouldRetryStatus(resp.StatusCode) </span><span class="cov0" title="0">{
                        return nil, &amp;domain.RetryableError{
                                Err:        &amp;domain.FetchError{URL: targetURL, StatusCode: resp.StatusCode, Err: fmt.Errorf("HTTP %d", resp.StatusCode)},
                                RetryAfter: int(ParseRetryAfter(resp.Header.Get("Retry-After")).Seconds()),
                        }
                }</span>
                <span class="cov0" title="0">return nil, &amp;domain.FetchError{
                        URL:        targetURL,
                        StatusCode: resp.StatusCode,
                        Err:        fmt.Errorf("HTTP %d", resp.StatusCode),
                }</span>
        }

        // Read body
        <span class="cov0" title="0">body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response body: %w", err)
        }</span>

        // Convert fhttp.Header to http.Header
        <span class="cov0" title="0">httpHeaders := make(http.Header)
        for k, v := range resp.Header </span><span class="cov0" title="0">{
                httpHeaders[k] = v
        }</span>

        <span class="cov0" title="0">return &amp;domain.Response{
                StatusCode:  resp.StatusCode,
                Body:        body,
                Headers:     httpHeaders,
                ContentType: resp.Header.Get("Content-Type"),
                URL:         targetURL,
                FromCache:   false,
        }, nil</span>
}

// GetCookies returns cookies for a URL (for sharing with renderer)
func (c *Client) GetCookies(rawURL string) []*http.Cookie <span class="cov0" title="0">{
        parsedURL, err := url.Parse(rawURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">cookies := c.tlsClient.GetCookies(parsedURL)
        result := make([]*http.Cookie, len(cookies))
        for i, cookie := range cookies </span><span class="cov0" title="0">{
                result[i] = &amp;http.Cookie{
                        Name:     cookie.Name,
                        Value:    cookie.Value,
                        Path:     cookie.Path,
                        Domain:   cookie.Domain,
                        Expires:  cookie.Expires,
                        Secure:   cookie.Secure,
                        HttpOnly: cookie.HttpOnly,
                }
        }</span>
        <span class="cov0" title="0">return result</span>
}

// Close releases client resources
func (c *Client) Close() error <span class="cov0" title="0">{
        // TLS client doesn't have a Close method, but we keep this for interface compliance
        return nil
}</span>

// getFromCache retrieves a response from cache
func (c *Client) getFromCache(ctx context.Context, url string) (*domain.Response, error) <span class="cov0" title="0">{
        if c.cache == nil </span><span class="cov0" title="0">{
                return nil, domain.ErrCacheMiss
        }</span>

        <span class="cov0" title="0">data, err := c.cache.Get(ctx, url)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;domain.Response{
                StatusCode:  200,
                Body:        data,
                ContentType: "text/html",
                URL:         url,
                FromCache:   true,
        }, nil</span>
}

// saveToCache saves a response to cache
func (c *Client) saveToCache(ctx context.Context, url string, resp *domain.Response) error <span class="cov0" title="0">{
        if c.cache == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return c.cache.Set(ctx, url, resp.Body, c.cacheTTL)</span>
}

// SetCache sets the cache implementation
func (c *Client) SetCache(cache domain.Cache) <span class="cov0" title="0">{
        c.cache = cache
}</span>

// SetCacheEnabled enables or disables caching
func (c *Client) SetCacheEnabled(enabled bool) <span class="cov0" title="0">{
        c.cacheEnabled = enabled
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package fetcher

import (
        "context"
        "time"

        "github.com/cenkalti/backoff/v4"
        "github.com/quantmind-br/repodocs-go/internal/domain"
)

// Retrier handles retry logic with exponential backoff
type Retrier struct {
        maxRetries      int
        initialInterval time.Duration
        maxInterval     time.Duration
        multiplier      float64
}

// RetrierOptions contains options for creating a Retrier
type RetrierOptions struct {
        MaxRetries      int
        InitialInterval time.Duration
        MaxInterval     time.Duration
        Multiplier      float64
}

// DefaultRetrierOptions returns default retrier options
func DefaultRetrierOptions() RetrierOptions <span class="cov0" title="0">{
        return RetrierOptions{
                MaxRetries:      3,
                InitialInterval: 1 * time.Second,
                MaxInterval:     30 * time.Second,
                Multiplier:      2.0,
        }
}</span>

// NewRetrier creates a new Retrier with the given options
func NewRetrier(opts RetrierOptions) *Retrier <span class="cov0" title="0">{
        if opts.MaxRetries &lt;= 0 </span><span class="cov0" title="0">{
                opts.MaxRetries = 3
        }</span>
        <span class="cov0" title="0">if opts.InitialInterval &lt;= 0 </span><span class="cov0" title="0">{
                opts.InitialInterval = 1 * time.Second
        }</span>
        <span class="cov0" title="0">if opts.MaxInterval &lt;= 0 </span><span class="cov0" title="0">{
                opts.MaxInterval = 30 * time.Second
        }</span>
        <span class="cov0" title="0">if opts.Multiplier &lt;= 0 </span><span class="cov0" title="0">{
                opts.Multiplier = 2.0
        }</span>

        <span class="cov0" title="0">return &amp;Retrier{
                maxRetries:      opts.MaxRetries,
                initialInterval: opts.InitialInterval,
                maxInterval:     opts.MaxInterval,
                multiplier:      opts.Multiplier,
        }</span>
}

// newBackoff creates a new exponential backoff
func (r *Retrier) newBackoff() backoff.BackOff <span class="cov0" title="0">{
        b := backoff.NewExponentialBackOff()
        b.InitialInterval = r.initialInterval
        b.MaxInterval = r.maxInterval
        b.Multiplier = r.multiplier
        b.RandomizationFactor = 0.5
        b.Reset()

        return backoff.WithMaxRetries(b, uint64(r.maxRetries))
}</span>

// Retry executes an operation with exponential backoff
func (r *Retrier) Retry(ctx context.Context, operation func() error) error <span class="cov0" title="0">{
        b := r.newBackoff()
        b = backoff.WithContext(b, ctx)

        return backoff.Retry(func() error </span><span class="cov0" title="0">{
                err := operation()
                if err == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>

                // Check if error is retryable
                <span class="cov0" title="0">if !domain.IsRetryable(err) </span><span class="cov0" title="0">{
                        return backoff.Permanent(err)
                }</span>

                <span class="cov0" title="0">return err</span>
        }, b)
}

// RetryWithValue executes an operation with exponential backoff and returns a value
func RetryWithValue[T any](ctx context.Context, r *Retrier, operation func() (T, error)) (T, error) <span class="cov0" title="0">{
        var result T
        var lastErr error

        b := r.newBackoff()
        b = backoff.WithContext(b, ctx)

        err := backoff.Retry(func() error </span><span class="cov0" title="0">{
                var err error
                result, err = operation()
                if err == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">lastErr = err

                // Check if error is retryable
                if !domain.IsRetryable(err) </span><span class="cov0" title="0">{
                        return backoff.Permanent(err)
                }</span>

                <span class="cov0" title="0">return err</span>
        }, b)

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return result, lastErr
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// ShouldRetryStatus returns true if the HTTP status code should be retried
func ShouldRetryStatus(statusCode int) bool <span class="cov0" title="0">{
        switch statusCode </span>{
        case 429:<span class="cov0" title="0"> // Too Many Requests
                return true</span>
        case 502:<span class="cov0" title="0"> // Bad Gateway
                return true</span>
        case 503:<span class="cov0" title="0"> // Service Unavailable
                return true</span>
        case 504:<span class="cov0" title="0"> // Gateway Timeout
                return true</span>
        }

        // Cloudflare errors (520-530)
        <span class="cov0" title="0">if statusCode &gt;= 520 &amp;&amp; statusCode &lt;= 530 </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}

// ParseRetryAfter parses the Retry-After header value
func ParseRetryAfter(retryAfter string) time.Duration <span class="cov0" title="0">{
        if retryAfter == "" </span><span class="cov0" title="0">{
                return 0
        }</span>

        // Try to parse as seconds
        <span class="cov0" title="0">var seconds int
        if _, err := parseRetryAfterInt(retryAfter, &amp;seconds); err == nil &amp;&amp; seconds &gt; 0 </span><span class="cov0" title="0">{
                return time.Duration(seconds) * time.Second
        }</span>

        // Try to parse as HTTP date (simplified)
        // Full parsing would use time.Parse with HTTP date format
        <span class="cov0" title="0">return 0</span>
}

// parseRetryAfterInt is a helper to parse retry-after as int
func parseRetryAfterInt(s string, result *int) (int, error) <span class="cov0" title="0">{
        n := 0
        for _, c := range s </span><span class="cov0" title="0">{
                if c &lt; '0' || c &gt; '9' </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">n = n*10 + int(c-'0')</span>
        }
        <span class="cov0" title="0">*result = n
        return n, nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package fetcher

import (
        "math/rand"
        "time"
)

// UserAgents is a pool of real Chrome/Firefox/Safari user agents
var UserAgents = []string{
        // Chrome on Windows
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Safari/537.36",
        // Chrome on macOS
        "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36",
        "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36",
        // Chrome on Linux
        "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36",
        "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36",
        // Firefox on Windows
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:132.0) Gecko/20100101 Firefox/132.0",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:131.0) Gecko/20100101 Firefox/131.0",
        // Firefox on macOS
        "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:132.0) Gecko/20100101 Firefox/132.0",
        "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:131.0) Gecko/20100101 Firefox/131.0",
        // Firefox on Linux
        "Mozilla/5.0 (X11; Linux x86_64; rv:132.0) Gecko/20100101 Firefox/132.0",
        "Mozilla/5.0 (X11; Linux x86_64; rv:131.0) Gecko/20100101 Firefox/131.0",
        // Safari on macOS
        "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.6 Safari/605.1.15",
        "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.5 Safari/605.1.15",
        // Edge on Windows
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36 Edg/131.0.0.0",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36 Edg/130.0.0.0",
}

// AcceptLanguages are common Accept-Language header values
var AcceptLanguages = []string{
        "en-US,en;q=0.9",
        "en-GB,en;q=0.9,en-US;q=0.8",
        "en-US,en;q=0.9,es;q=0.8",
        "en-US,en;q=0.9,de;q=0.8",
        "en-US,en;q=0.9,fr;q=0.8",
        "en,en-US;q=0.9",
}

// SecChUaPlatforms are Sec-CH-UA-Platform header values
var SecChUaPlatforms = []string{
        `"Windows"`,
        `"macOS"`,
        `"Linux"`,
}

// init seeds the random number generator
func init() <span class="cov0" title="0">{
        rand.Seed(time.Now().UnixNano())
}</span>

// RandomUserAgent returns a random user agent from the pool
func RandomUserAgent() string <span class="cov0" title="0">{
        return UserAgents[rand.Intn(len(UserAgents))]
}</span>

// RandomAcceptLanguage returns a random Accept-Language header value
func RandomAcceptLanguage() string <span class="cov0" title="0">{
        return AcceptLanguages[rand.Intn(len(AcceptLanguages))]
}</span>

// RandomSecChUaPlatform returns a random Sec-CH-UA-Platform header value
func RandomSecChUaPlatform() string <span class="cov0" title="0">{
        return SecChUaPlatforms[rand.Intn(len(SecChUaPlatforms))]
}</span>

// StealthHeaders returns a map of stealth headers for HTTP requests
func StealthHeaders(userAgent string) map[string]string <span class="cov0" title="0">{
        if userAgent == "" </span><span class="cov0" title="0">{
                userAgent = RandomUserAgent()
        }</span>

        <span class="cov0" title="0">headers := map[string]string{
                "User-Agent":                userAgent,
                "Accept":                    "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8",
                "Accept-Language":           RandomAcceptLanguage(),
                "Accept-Encoding":           "gzip, deflate, br",
                "Cache-Control":             "no-cache",
                "Pragma":                    "no-cache",
                "Sec-Fetch-Dest":            "document",
                "Sec-Fetch-Mode":            "navigate",
                "Sec-Fetch-Site":            "none",
                "Sec-Fetch-User":            "?1",
                "Upgrade-Insecure-Requests": "1",
        }

        // Add Chrome-specific headers if using Chrome UA
        if isChrome(userAgent) </span><span class="cov0" title="0">{
                headers["Sec-CH-UA"] = `"Google Chrome";v="131", "Chromium";v="131", "Not_A Brand";v="24"`
                headers["Sec-CH-UA-Mobile"] = "?0"
                headers["Sec-CH-UA-Platform"] = RandomSecChUaPlatform()
        }</span>

        <span class="cov0" title="0">return headers</span>
}

// isChrome checks if the user agent is Chrome
func isChrome(userAgent string) bool <span class="cov0" title="0">{
        return len(userAgent) &gt; 0 &amp;&amp; (contains(userAgent, "Chrome") || contains(userAgent, "Chromium"))
}</span>

// contains is a simple string contains check
func contains(s, substr string) bool <span class="cov0" title="0">{
        for i := 0; i &lt;= len(s)-len(substr); i++ </span><span class="cov0" title="0">{
                if s[i:i+len(substr)] == substr </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// RandomDelay returns a random delay between min and max duration
func RandomDelay(min, max time.Duration) time.Duration <span class="cov0" title="0">{
        if min &gt;= max </span><span class="cov0" title="0">{
                return min
        }</span>
        <span class="cov0" title="0">delta := max - min
        return min + time.Duration(rand.Int63n(int64(delta)))</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package fetcher

import (
        "bytes"
        "io"
        "net/http"
)

// StealthTransport is an http.RoundTripper that uses the stealth client
// This allows integration with Colly and other HTTP client libraries
type StealthTransport struct {
        client *Client
}

// NewStealthTransport creates a new StealthTransport
func NewStealthTransport(client *Client) *StealthTransport <span class="cov0" title="0">{
        return &amp;StealthTransport{client: client}
}</span>

// RoundTrip implements http.RoundTripper
func (t *StealthTransport) RoundTrip(req *http.Request) (*http.Response, error) <span class="cov0" title="0">{
        // Extract headers from request
        extraHeaders := make(map[string]string)
        for k, v := range req.Header </span><span class="cov0" title="0">{
                if len(v) &gt; 0 </span><span class="cov0" title="0">{
                        extraHeaders[k] = v[0]
                }</span>
        }

        // Use the stealth client to make the request
        <span class="cov0" title="0">resp, err := t.client.GetWithHeaders(req.Context(), req.URL.String(), extraHeaders)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Convert domain.Response to http.Response
        <span class="cov0" title="0">return &amp;http.Response{
                Status:        http.StatusText(resp.StatusCode),
                StatusCode:    resp.StatusCode,
                Proto:         "HTTP/1.1",
                ProtoMajor:    1,
                ProtoMinor:    1,
                Header:        resp.Headers,
                Body:          io.NopCloser(bytes.NewReader(resp.Body)),
                ContentLength: int64(len(resp.Body)),
                Request:       req,
        }, nil</span>
}

// Transport returns the StealthTransport as http.RoundTripper
func (c *Client) Transport() http.RoundTripper <span class="cov0" title="0">{
        return NewStealthTransport(c)
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package output

import (
        "context"
        "encoding/json"
        "os"
        "path/filepath"

        "github.com/quantmind-br/repodocs-go/internal/converter"
        "github.com/quantmind-br/repodocs-go/internal/domain"
        "github.com/quantmind-br/repodocs-go/internal/utils"
)

// Writer handles writing documents to the filesystem
type Writer struct {
        baseDir      string
        flat         bool
        jsonMetadata bool
        force        bool
        dryRun       bool
}

// WriterOptions contains options for the writer
type WriterOptions struct {
        BaseDir      string
        Flat         bool
        JSONMetadata bool
        Force        bool
        DryRun       bool
}

// NewWriter creates a new output writer
func NewWriter(opts WriterOptions) *Writer <span class="cov0" title="0">{
        if opts.BaseDir == "" </span><span class="cov0" title="0">{
                opts.BaseDir = "./docs"
        }</span>

        <span class="cov0" title="0">return &amp;Writer{
                baseDir:      opts.BaseDir,
                flat:         opts.Flat,
                jsonMetadata: opts.JSONMetadata,
                force:        opts.Force,
                dryRun:       opts.DryRun,
        }</span>
}

// Write saves a document to the output directory
func (w *Writer) Write(ctx context.Context, doc *domain.Document) error <span class="cov0" title="0">{
        // Generate path
        var path string
        if doc.RelativePath != "" </span><span class="cov0" title="0">{
                // For Git-sourced files, use the relative path directly
                path = utils.GeneratePathFromRelative(w.baseDir, doc.RelativePath, w.flat)
        }</span> else<span class="cov0" title="0"> {
                // For other sources, generate path from URL
                path = utils.GeneratePath(w.baseDir, doc.URL, w.flat)
        }</span>

        // Check if file exists
        <span class="cov0" title="0">if !w.force </span><span class="cov0" title="0">{
                if _, err := os.Stat(path); err == nil </span><span class="cov0" title="0">{
                        // File exists, skip
                        return nil
                }</span>
        }

        // Dry run - just return
        <span class="cov0" title="0">if w.dryRun </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Ensure directory exists
        <span class="cov0" title="0">if err := utils.EnsureDir(path); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Add frontmatter
        <span class="cov0" title="0">content, err := converter.AddFrontmatter(doc.Content, doc)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Write markdown file
        <span class="cov0" title="0">if err := os.WriteFile(path, []byte(content), 0644); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Write JSON metadata if enabled
        <span class="cov0" title="0">if w.jsonMetadata </span><span class="cov0" title="0">{
                jsonPath := utils.JSONPath(path)
                if err := w.writeJSON(jsonPath, doc); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// writeJSON writes JSON metadata
func (w *Writer) writeJSON(path string, doc *domain.Document) error <span class="cov0" title="0">{
        metadata := doc.ToMetadata()

        data, err := json.MarshalIndent(metadata, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// WriteMultiple writes multiple documents
func (w *Writer) WriteMultiple(ctx context.Context, docs []*domain.Document) error <span class="cov0" title="0">{
        for _, doc := range docs </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                default:<span class="cov0" title="0">
                        if err := w.Write(ctx, doc); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// GetPath returns the output path for a URL
func (w *Writer) GetPath(url string) string <span class="cov0" title="0">{
        return utils.GeneratePath(w.baseDir, url, w.flat)
}</span>

// Exists checks if a document already exists
func (w *Writer) Exists(url string) bool <span class="cov0" title="0">{
        path := w.GetPath(url)
        _, err := os.Stat(path)
        return err == nil
}</span>

// EnsureBaseDir creates the base directory if it doesn't exist
func (w *Writer) EnsureBaseDir() error <span class="cov0" title="0">{
        return os.MkdirAll(w.baseDir, 0755)
}</span>

// Clean removes the output directory
func (w *Writer) Clean() error <span class="cov0" title="0">{
        return os.RemoveAll(w.baseDir)
}</span>

// Stats returns statistics about the output directory
func (w *Writer) Stats() (int, int64, error) <span class="cov0" title="0">{
        var count int
        var size int64

        err := filepath.Walk(w.baseDir, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if !info.IsDir() &amp;&amp; filepath.Ext(path) == ".md" </span><span class="cov0" title="0">{
                        count++
                        size += info.Size()
                }</span>
                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">return count, size, err</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package renderer

import (
        "regexp"
        "strings"
)

// SPA detection patterns
var (
        // React patterns
        reactPatterns = []string{
                `&lt;div id="root"&gt;&lt;/div&gt;`,
                `&lt;div id="root"/&gt;`,
                `&lt;div id="app"&gt;&lt;/div&gt;`,
                `&lt;div id="app"/&gt;`,
                `data-reactroot`,
                `__REACT_DEVTOOLS_GLOBAL_HOOK__`,
        }

        // Vue patterns
        vuePatterns = []string{
                `&lt;div id="app"&gt;&lt;/div&gt;`,
                `&lt;div id="app"/&gt;`,
                `__VUE__`,
                `v-cloak`,
                `Vue.createApp`,
        }

        // Next.js patterns
        nextPatterns = []string{
                `&lt;div id="__next"&gt;&lt;/div&gt;`,
                `&lt;div id="__next"/&gt;`,
                `__NEXT_DATA__`,
                `_next/static`,
        }

        // Nuxt patterns
        nuxtPatterns = []string{
                `__NUXT__`,
                `window.__NUXT__`,
                `&lt;div id="__nuxt"&gt;`,
        }

        // Angular patterns
        angularPatterns = []string{
                `ng-version`,
                `ng-app`,
                `ng-controller`,
                `&lt;app-root&gt;`,
        }

        // Svelte patterns
        sveltePatterns = []string{
                `__svelte`,
                `svelte-`,
        }

        // Generic SPA indicators
        spaIndicators = []string{
                `window.__INITIAL_STATE__`,
                `window.__STATE__`,
                `window.__PRELOADED_STATE__`,
        }
)

// contentMinLength is the minimum content length to consider a page as rendered
const contentMinLength = 500

// scriptTagRegex matches script tags
var scriptTagRegex = regexp.MustCompile(`&lt;script[^&gt;]*&gt;[\s\S]*?&lt;/script&gt;`)

// htmlTagRegex matches HTML tags
var htmlTagRegex = regexp.MustCompile(`&lt;[^&gt;]+&gt;`)

// NeedsJSRendering detects if a page needs JavaScript rendering
func NeedsJSRendering(html string) bool <span class="cov0" title="0">{
        // Check for SPA framework patterns
        if hasSPAPattern(html) </span><span class="cov0" title="0">{
                return true
        }</span>

        // Check content length without scripts
        <span class="cov0" title="0">contentWithoutScripts := scriptTagRegex.ReplaceAllString(html, "")
        textContent := htmlTagRegex.ReplaceAllString(contentWithoutScripts, "")
        textContent = strings.TrimSpace(textContent)

        // If there's very little content but many scripts, likely a SPA
        if len(textContent) &lt; contentMinLength </span><span class="cov0" title="0">{
                scriptCount := strings.Count(strings.ToLower(html), "&lt;script")
                if scriptCount &gt; 3 </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// hasSPAPattern checks if the HTML contains any SPA framework patterns
func hasSPAPattern(html string) bool <span class="cov0" title="0">{
        htmlLower := strings.ToLower(html)

        allPatterns := append([]string{}, reactPatterns...)
        allPatterns = append(allPatterns, vuePatterns...)
        allPatterns = append(allPatterns, nextPatterns...)
        allPatterns = append(allPatterns, nuxtPatterns...)
        allPatterns = append(allPatterns, angularPatterns...)
        allPatterns = append(allPatterns, sveltePatterns...)
        allPatterns = append(allPatterns, spaIndicators...)

        for _, pattern := range allPatterns </span><span class="cov0" title="0">{
                if strings.Contains(htmlLower, strings.ToLower(pattern)) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// DetectFramework attempts to detect which SPA framework is being used
func DetectFramework(html string) string <span class="cov0" title="0">{
        htmlLower := strings.ToLower(html)

        for _, pattern := range nextPatterns </span><span class="cov0" title="0">{
                if strings.Contains(htmlLower, strings.ToLower(pattern)) </span><span class="cov0" title="0">{
                        return "Next.js"
                }</span>
        }

        <span class="cov0" title="0">for _, pattern := range nuxtPatterns </span><span class="cov0" title="0">{
                if strings.Contains(htmlLower, strings.ToLower(pattern)) </span><span class="cov0" title="0">{
                        return "Nuxt"
                }</span>
        }

        <span class="cov0" title="0">for _, pattern := range reactPatterns </span><span class="cov0" title="0">{
                if strings.Contains(htmlLower, strings.ToLower(pattern)) </span><span class="cov0" title="0">{
                        return "React"
                }</span>
        }

        <span class="cov0" title="0">for _, pattern := range vuePatterns </span><span class="cov0" title="0">{
                if strings.Contains(htmlLower, strings.ToLower(pattern)) </span><span class="cov0" title="0">{
                        return "Vue"
                }</span>
        }

        <span class="cov0" title="0">for _, pattern := range angularPatterns </span><span class="cov0" title="0">{
                if strings.Contains(htmlLower, strings.ToLower(pattern)) </span><span class="cov0" title="0">{
                        return "Angular"
                }</span>
        }

        <span class="cov0" title="0">for _, pattern := range sveltePatterns </span><span class="cov0" title="0">{
                if strings.Contains(htmlLower, strings.ToLower(pattern)) </span><span class="cov0" title="0">{
                        return "Svelte"
                }</span>
        }

        <span class="cov0" title="0">return "Unknown"</span>
}

// HasDynamicContent checks for indicators of dynamic content loading
func HasDynamicContent(html string) bool <span class="cov0" title="0">{
        indicators := []string{
                "loading...",
                "loading",
                "please wait",
                "spinner",
                "skeleton",
                "lazy-load",
                "lazyload",
                "infinite-scroll",
        }

        htmlLower := strings.ToLower(html)
        for _, indicator := range indicators </span><span class="cov0" title="0">{
                if strings.Contains(htmlLower, indicator) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package renderer

import (
        "context"
        "sync"

        "github.com/go-rod/rod"
)

// TabPool manages a pool of browser tabs for concurrent rendering
type TabPool struct {
        browser    *rod.Browser
        maxTabs    int
        activeTabs chan *rod.Page
        mu         sync.Mutex
        closed     bool
}

// NewTabPool creates a new tab pool
func NewTabPool(browser *rod.Browser, maxTabs int) (*TabPool, error) <span class="cov0" title="0">{
        if maxTabs &lt;= 0 </span><span class="cov0" title="0">{
                maxTabs = 5
        }</span>

        <span class="cov0" title="0">pool := &amp;TabPool{
                browser:    browser,
                maxTabs:    maxTabs,
                activeTabs: make(chan *rod.Page, maxTabs),
        }

        // Pre-create tabs
        for i := 0; i &lt; maxTabs; i++ </span><span class="cov0" title="0">{
                page, err := StealthPage(browser)
                if err != nil </span><span class="cov0" title="0">{
                        pool.Close()
                        return nil, err
                }</span>
                <span class="cov0" title="0">pool.activeTabs &lt;- page</span>
        }

        <span class="cov0" title="0">return pool, nil</span>
}

// Acquire gets a page from the pool, blocking if none available
func (p *TabPool) Acquire(ctx context.Context) (*rod.Page, error) <span class="cov0" title="0">{
        p.mu.Lock()
        if p.closed </span><span class="cov0" title="0">{
                p.mu.Unlock()
                return nil, ErrPoolClosed
        }</span>
        <span class="cov0" title="0">p.mu.Unlock()

        select </span>{
        case page := &lt;-p.activeTabs:<span class="cov0" title="0">
                return page, nil</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return nil, ctx.Err()</span>
        }
}

// Release returns a page to the pool after cleaning up
func (p *TabPool) Release(page *rod.Page) <span class="cov0" title="0">{
        p.mu.Lock()
        if p.closed </span><span class="cov0" title="0">{
                p.mu.Unlock()
                page.Close()
                return
        }</span>
        <span class="cov0" title="0">p.mu.Unlock()

        // Clean up the page before returning to pool
        _ = page.Navigate("about:blank")

        select </span>{
        case p.activeTabs &lt;- page:<span class="cov0" title="0"></span>
                // Successfully returned to pool
        default:<span class="cov0" title="0">
                // Pool is full (shouldn't happen normally)
                page.Close()</span>
        }
}

// Close closes all tabs and the pool
func (p *TabPool) Close() error <span class="cov0" title="0">{
        p.mu.Lock()
        if p.closed </span><span class="cov0" title="0">{
                p.mu.Unlock()
                return nil
        }</span>
        <span class="cov0" title="0">p.closed = true
        p.mu.Unlock()

        close(p.activeTabs)

        // Close remaining pages
        for page := range p.activeTabs </span><span class="cov0" title="0">{
                page.Close()
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Size returns the current number of available tabs
func (p *TabPool) Size() int <span class="cov0" title="0">{
        return len(p.activeTabs)
}</span>

// MaxSize returns the maximum pool size
func (p *TabPool) MaxSize() int <span class="cov0" title="0">{
        return p.maxTabs
}</span>

// ErrPoolClosed is returned when trying to acquire from a closed pool
var ErrPoolClosed = &amp;poolError{message: "pool is closed"}

type poolError struct {
        message string
}

func (e *poolError) Error() string <span class="cov0" title="0">{
        return e.message
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package renderer

import (
        "context"
        "fmt"
        "net/http"
        "net/url"
        "time"

        "github.com/go-rod/rod"
        "github.com/go-rod/rod/lib/launcher"
        "github.com/go-rod/rod/lib/proto"
        "github.com/quantmind-br/repodocs-go/internal/domain"
)

// Renderer provides JavaScript rendering using headless Chrome
type Renderer struct {
        browser  *rod.Browser
        pool     *TabPool
        timeout  time.Duration
        stealth  bool
        headless bool
}

// RendererOptions contains options for creating a Renderer
type RendererOptions struct {
        Timeout     time.Duration
        MaxTabs     int
        Stealth     bool
        Headless    bool
        BrowserPath string
}

// DefaultRendererOptions returns default renderer options
func DefaultRendererOptions() RendererOptions <span class="cov0" title="0">{
        return RendererOptions{
                Timeout:     60 * time.Second,
                MaxTabs:     5,
                Stealth:     true,
                Headless:    true,
                BrowserPath: "",
        }
}</span>

// NewRenderer creates a new headless browser renderer
func NewRenderer(opts RendererOptions) (*Renderer, error) <span class="cov0" title="0">{
        if opts.Timeout &lt;= 0 </span><span class="cov0" title="0">{
                opts.Timeout = 60 * time.Second
        }</span>
        <span class="cov0" title="0">if opts.MaxTabs &lt;= 0 </span><span class="cov0" title="0">{
                opts.MaxTabs = 5
        }</span>

        // Create launcher
        <span class="cov0" title="0">l := launcher.New()

        if opts.BrowserPath != "" </span><span class="cov0" title="0">{
                l = l.Bin(opts.BrowserPath)
        }</span>

        <span class="cov0" title="0">if opts.Headless </span><span class="cov0" title="0">{
                l = l.Headless(true)
        }</span>

        // Additional flags for stealth
        <span class="cov0" title="0">if opts.Stealth </span><span class="cov0" title="0">{
                l = l.Set("disable-blink-features", "AutomationControlled")
        }</span>

        // Launch browser
        <span class="cov0" title="0">controlURL, err := l.Launch()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to launch browser: %w", err)
        }</span>

        <span class="cov0" title="0">browser := rod.New().ControlURL(controlURL)
        if err := browser.Connect(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to browser: %w", err)
        }</span>

        // Create tab pool
        <span class="cov0" title="0">pool, err := NewTabPool(browser, opts.MaxTabs)
        if err != nil </span><span class="cov0" title="0">{
                browser.Close()
                return nil, fmt.Errorf("failed to create tab pool: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;Renderer{
                browser:  browser,
                pool:     pool,
                timeout:  opts.Timeout,
                stealth:  opts.Stealth,
                headless: opts.Headless,
        }, nil</span>
}

// Render fetches and renders a page with JavaScript
func (r *Renderer) Render(ctx context.Context, url string, opts domain.RenderOptions) (string, error) <span class="cov0" title="0">{
        if opts.Timeout &lt;= 0 </span><span class="cov0" title="0">{
                opts.Timeout = r.timeout
        }</span>

        // Create context with timeout
        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, opts.Timeout)
        defer cancel()

        // Acquire a page from the pool
        page, err := r.pool.Acquire(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to acquire page: %w", err)
        }</span>
        <span class="cov0" title="0">defer r.pool.Release(page)

        // Apply context to page so all operations respect the timeout
        page = page.Context(ctx)

        // Apply stealth mode
        if r.stealth </span><span class="cov0" title="0">{
                if err := ApplyStealthMode(page); err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to apply stealth mode: %w", err)
                }</span>
        }

        // Set cookies if provided
        <span class="cov0" title="0">if len(opts.Cookies) &gt; 0 </span><span class="cov0" title="0">{
                if err := r.setCookies(page, url, opts.Cookies); err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to set cookies: %w", err)
                }</span>
        }

        // Navigate to URL
        <span class="cov0" title="0">if err := page.Navigate(url); err != nil </span><span class="cov0" title="0">{
                return "", domain.NewFetchError(url, 0, fmt.Errorf("navigation failed: %w", err))
        }</span>

        // Wait for page to load
        <span class="cov0" title="0">if err := page.WaitLoad(); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed waiting for load: %w", err)
        }</span>

        // Wait for specific selector if provided
        <span class="cov0" title="0">if opts.WaitFor != "" </span><span class="cov0" title="0">{
                if err := page.Timeout(opts.Timeout).MustElement(opts.WaitFor).WaitVisible(); err != nil </span>{<span class="cov0" title="0">
                        // Don't fail, just continue
                }</span>
        }

        // Wait for network to be idle
        <span class="cov0" title="0">if opts.WaitStable &gt; 0 </span><span class="cov0" title="0">{
                if err := page.WaitRequestIdle(opts.WaitStable, nil, nil, nil); err != nil </span>{<span class="cov0" title="0">
                        // Don't fail, just continue
                }</span>
        }

        // Scroll to bottom to load lazy content
        <span class="cov0" title="0">if opts.ScrollToEnd </span><span class="cov0" title="0">{
                if err := r.scrollToEnd(page); err != nil </span>{<span class="cov0" title="0">
                        // Don't fail, just continue
                }</span>
        }

        // Get rendered HTML
        <span class="cov0" title="0">html, err := page.HTML()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get HTML: %w", err)
        }</span>

        <span class="cov0" title="0">return html, nil</span>
}

// setCookies sets cookies on a page
func (r *Renderer) setCookies(page *rod.Page, pageURL string, cookies []*http.Cookie) error <span class="cov0" title="0">{
        // Parse URL to extract domain if cookie domain is empty
        parsedURL, err := url.Parse(pageURL)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse URL for cookies: %w", err)
        }</span>

        <span class="cov0" title="0">for _, cookie := range cookies </span><span class="cov0" title="0">{
                // Use cookie domain if set, otherwise extract from URL
                domain := cookie.Domain
                if domain == "" </span><span class="cov0" title="0">{
                        domain = parsedURL.Hostname()
                }</span>

                // Use cookie path if set, otherwise default to "/"
                <span class="cov0" title="0">path := cookie.Path
                if path == "" </span><span class="cov0" title="0">{
                        path = "/"
                }</span>

                <span class="cov0" title="0">err := page.SetCookies([]*proto.NetworkCookieParam{
                        {
                                Name:     cookie.Name,
                                Value:    cookie.Value,
                                Domain:   domain,
                                Path:     path,
                                Secure:   cookie.Secure,
                                HTTPOnly: cookie.HttpOnly,
                        },
                })
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// scrollToEnd scrolls to the bottom of the page to trigger lazy loading
func (r *Renderer) scrollToEnd(page *rod.Page) error <span class="cov0" title="0">{
        // Get initial scroll height
        result, err := page.Eval(`() =&gt; document.body.scrollHeight`)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">lastHeight := result.Value.Int()

        for i := 0; i &lt; 10; i++ </span><span class="cov0" title="0">{ // Max 10 scroll iterations
                // Scroll to bottom
                _, err := page.Eval(`() =&gt; window.scrollTo(0, document.body.scrollHeight)`)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Wait for content to load
                <span class="cov0" title="0">time.Sleep(500 * time.Millisecond)

                // Check new scroll height
                result, err := page.Eval(`() =&gt; document.body.scrollHeight`)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">newHeight := result.Value.Int()

                // If height hasn't changed, we've reached the bottom
                if newHeight == lastHeight </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">lastHeight = newHeight</span>
        }

        // Scroll back to top
        <span class="cov0" title="0">_, _ = page.Eval(`() =&gt; window.scrollTo(0, 0)`)

        return nil</span>
}

// DefaultRenderOptions returns default render options
func DefaultRenderOptions() domain.RenderOptions <span class="cov0" title="0">{
        return domain.RenderOptions{
                Timeout:     60 * time.Second,
                WaitStable:  2 * time.Second,
                ScrollToEnd: true,
        }
}</span>

// Close releases browser resources
func (r *Renderer) Close() error <span class="cov0" title="0">{
        if r.pool != nil </span><span class="cov0" title="0">{
                r.pool.Close()
        }</span>
        <span class="cov0" title="0">if r.browser != nil </span><span class="cov0" title="0">{
                return r.browser.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// IsAvailable checks if the browser is available
func IsAvailable() bool <span class="cov0" title="0">{
        path, exists := launcher.LookPath()
        return exists &amp;&amp; path != ""
}</span>

// GetBrowserPath returns the detected browser path
func GetBrowserPath() (string, bool) <span class="cov0" title="0">{
        return launcher.LookPath()
}</span>

// GetTabPool returns the tab pool for testing purposes
func (r *Renderer) GetTabPool() (*TabPool, error) <span class="cov0" title="0">{
        if r.pool == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("pool not initialized")
        }</span>
        <span class="cov0" title="0">return r.pool, nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package renderer

import (
        "github.com/go-rod/rod"
        "github.com/go-rod/rod/lib/proto"
        "github.com/go-rod/stealth"
)

// StealthPage creates a new stealth page that's harder to detect as automated
func StealthPage(browser *rod.Browser) (*rod.Page, error) <span class="cov0" title="0">{
        page, err := stealth.Page(browser)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return page, nil</span>
}

// ApplyStealthMode applies stealth mode configurations to a page
// This includes removing webdriver flags and emulating real browser behavior
func ApplyStealthMode(page *rod.Page) error <span class="cov0" title="0">{
        // The stealth package already handles most of this, but we can add extra measures

        // Set a realistic viewport using proto.EmulationSetDeviceMetricsOverride
        err := page.SetViewport(&amp;proto.EmulationSetDeviceMetricsOverride{
                Width:  1920,
                Height: 1080,
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Simple stealth: just hide webdriver flag
        // Rod expects arrow function format: () =&gt; expression
        <span class="cov0" title="0">js := `() =&gt; { Object.defineProperty(navigator, 'webdriver', { get: () =&gt; undefined }); return true; }`
        _, err = page.Eval(js)
        return err</span>
}

// StealthOptions contains options for stealth mode
type StealthOptions struct {
        // HideWebdriver hides the webdriver property
        HideWebdriver bool
        // EmulatePlugins emulates real browser plugins
        EmulatePlugins bool
        // RandomizeViewport randomizes the viewport size
        RandomizeViewport bool
        // DisableAutomationFlags disables Chrome automation flags
        DisableAutomationFlags bool
}

// DefaultStealthOptions returns default stealth options
func DefaultStealthOptions() StealthOptions <span class="cov0" title="0">{
        return StealthOptions{
                HideWebdriver:          true,
                EmulatePlugins:         true,
                RandomizeViewport:      false,
                DisableAutomationFlags: true,
        }
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package strategies

import (
        "context"
        "regexp"
        "strings"
        "sync"
        "time"

        "github.com/gocolly/colly/v2"
        "github.com/quantmind-br/repodocs-go/internal/converter"
        "github.com/quantmind-br/repodocs-go/internal/domain"
        "github.com/quantmind-br/repodocs-go/internal/fetcher"
        "github.com/quantmind-br/repodocs-go/internal/output"
        "github.com/quantmind-br/repodocs-go/internal/renderer"
        "github.com/quantmind-br/repodocs-go/internal/utils"
        "github.com/schollz/progressbar/v3"
)

// CrawlerStrategy crawls websites to extract documentation
type CrawlerStrategy struct {
        fetcher   *fetcher.Client
        renderer  domain.Renderer
        converter *converter.Pipeline
        writer    *output.Writer
        logger    *utils.Logger
}

// NewCrawlerStrategy creates a new crawler strategy
func NewCrawlerStrategy(deps *Dependencies) *CrawlerStrategy <span class="cov0" title="0">{
        return &amp;CrawlerStrategy{
                fetcher:   deps.Fetcher,
                renderer:  deps.Renderer,
                converter: deps.Converter,
                writer:    deps.Writer,
                logger:    deps.Logger,
        }
}</span>

// Name returns the strategy name
func (s *CrawlerStrategy) Name() string <span class="cov0" title="0">{
        return "crawler"
}</span>

// CanHandle returns true if this strategy can handle the given URL
func (s *CrawlerStrategy) CanHandle(url string) bool <span class="cov0" title="0">{
        return utils.IsHTTPURL(url)
}</span>

// Execute runs the crawler extraction strategy
func (s *CrawlerStrategy) Execute(ctx context.Context, url string, opts Options) error <span class="cov0" title="0">{
        s.logger.Info().Str("url", url).Msg("Starting web crawl")

        // Log filter if set
        if opts.FilterURL != "" </span><span class="cov0" title="0">{
                s.logger.Info().Str("filter", opts.FilterURL).Msg("URL filter active - only crawling URLs under this path")
        }</span>

        // Create visited URL tracker
        <span class="cov0" title="0">visited := sync.Map{}
        var processedCount int
        var mu sync.Mutex

        // Compile exclude patterns
        var excludeRegexps []*regexp.Regexp
        for _, pattern := range opts.Exclude </span><span class="cov0" title="0">{
                if re, err := regexp.Compile(pattern); err == nil </span><span class="cov0" title="0">{
                        excludeRegexps = append(excludeRegexps, re)
                }</span>
        }

        // Create colly collector
        <span class="cov0" title="0">c := colly.NewCollector(
                colly.Async(true),
                colly.MaxDepth(opts.MaxDepth),
        )

        // Set transport from fetcher for stealth
        c.WithTransport(s.fetcher.Transport())

        // Configure rate limiting
        _ = c.Limit(&amp;colly.LimitRule{
                DomainGlob:  "*",
                Parallelism: opts.Concurrency,
                RandomDelay: 2 * time.Second,
        })

        // Create progress bar (unknown total)
        bar := progressbar.NewOptions(-1,
                progressbar.OptionSetDescription("Crawling"),
                progressbar.OptionShowCount(),
                progressbar.OptionSpinnerType(14),
        )

        // Handle links
        c.OnHTML("a[href]", func(e *colly.HTMLElement) </span><span class="cov0" title="0">{
                link := e.Request.AbsoluteURL(e.Attr("href"))
                if link == "" </span><span class="cov0" title="0">{
                        return
                }</span>

                // Check if within same domain
                <span class="cov0" title="0">if !utils.IsSameDomain(link, url) </span><span class="cov0" title="0">{
                        return
                }</span>

                // Check base URL filter - only crawl URLs that start with the filter path
                <span class="cov0" title="0">if opts.FilterURL != "" &amp;&amp; !utils.HasBaseURL(link, opts.FilterURL) </span><span class="cov0" title="0">{
                        return
                }</span>

                // Check exclude patterns
                <span class="cov0" title="0">for _, re := range excludeRegexps </span><span class="cov0" title="0">{
                        if re.MatchString(link) </span><span class="cov0" title="0">{
                                return
                        }</span>
                }

                // Check limit
                <span class="cov0" title="0">mu.Lock()
                if opts.Limit &gt; 0 &amp;&amp; processedCount &gt;= opts.Limit </span><span class="cov0" title="0">{
                        mu.Unlock()
                        return
                }</span>
                <span class="cov0" title="0">mu.Unlock()

                // Check if already visited
                if _, exists := visited.LoadOrStore(link, true); exists </span><span class="cov0" title="0">{
                        return
                }</span>

                // Visit the link
                <span class="cov0" title="0">_ = e.Request.Visit(link)</span>
        })

        // Handle page responses
        <span class="cov0" title="0">c.OnResponse(func(r *colly.Response) </span><span class="cov0" title="0">{
                // Check context cancellation
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                default:<span class="cov0" title="0"></span>
                }

                // Check content type
                <span class="cov0" title="0">contentType := r.Headers.Get("Content-Type")
                if !isHTMLContentType(contentType) </span><span class="cov0" title="0">{
                        return
                }</span>

                // Check limit
                <span class="cov0" title="0">mu.Lock()
                if opts.Limit &gt; 0 &amp;&amp; processedCount &gt;= opts.Limit </span><span class="cov0" title="0">{
                        mu.Unlock()
                        return
                }</span>
                <span class="cov0" title="0">processedCount++
                mu.Unlock()

                bar.Add(1)

                // Check if already exists
                if !opts.Force &amp;&amp; s.writer.Exists(r.Request.URL.String()) </span><span class="cov0" title="0">{
                        return
                }</span>

                // Get HTML content
                <span class="cov0" title="0">html := string(r.Body)

                // Check if JS rendering is needed
                if opts.RenderJS || renderer.NeedsJSRendering(html) </span><span class="cov0" title="0">{
                        if s.renderer != nil </span><span class="cov0" title="0">{
                                rendered, err := s.renderer.Render(ctx, r.Request.URL.String(), domain.RenderOptions{
                                        Timeout:     60 * time.Second,
                                        WaitStable:  2 * time.Second,
                                        ScrollToEnd: true,
                                })
                                if err == nil </span><span class="cov0" title="0">{
                                        html = rendered
                                }</span>
                        }
                }

                // Convert to document
                <span class="cov0" title="0">doc, err := s.converter.Convert(ctx, html, r.Request.URL.String())
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn().Err(err).Str("url", r.Request.URL.String()).Msg("Failed to convert page")
                        return
                }</span>

                // Set metadata
                <span class="cov0" title="0">doc.SourceStrategy = s.Name()
                doc.FetchedAt = time.Now()

                // Write document
                if !opts.DryRun </span><span class="cov0" title="0">{
                        if err := s.writer.Write(ctx, doc); err != nil </span><span class="cov0" title="0">{
                                s.logger.Warn().Err(err).Str("url", r.Request.URL.String()).Msg("Failed to write document")
                        }</span>
                }
        })

        // Handle errors
        <span class="cov0" title="0">c.OnError(func(r *colly.Response, err error) </span><span class="cov0" title="0">{
                s.logger.Debug().Err(err).Str("url", r.Request.URL.String()).Msg("Request failed")
        }</span>)

        // Start crawling
        <span class="cov0" title="0">if err := c.Visit(url); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Handle context cancellation
        <span class="cov0" title="0">done := make(chan struct{})
        go func() </span><span class="cov0" title="0">{
                c.Wait()
                close(done)
        }</span>()

        <span class="cov0" title="0">select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return ctx.Err()</span>
        case &lt;-done:<span class="cov0" title="0"></span>
        }

        <span class="cov0" title="0">s.logger.Info().Int("pages", processedCount).Msg("Crawl completed")
        return nil</span>
}

// isHTMLContentType checks if content type is HTML
func isHTMLContentType(contentType string) bool <span class="cov0" title="0">{
        if contentType == "" </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">lower := strings.ToLower(contentType)
        return strings.Contains(lower, "text/html") ||
                strings.Contains(lower, "application/xhtml")</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package strategies

import (
        "archive/tar"
        "bufio"
        "compress/gzip"
        "context"
        "fmt"
        "io"
        "io/fs"
        "net/http"
        "os"
        "os/exec"
        "path/filepath"
        "regexp"
        "strings"
        "time"

        "github.com/go-git/go-git/v5"
        githttp "github.com/go-git/go-git/v5/plumbing/transport/http"
        "github.com/quantmind-br/repodocs-go/internal/domain"
        "github.com/quantmind-br/repodocs-go/internal/output"
        "github.com/quantmind-br/repodocs-go/internal/utils"
        "github.com/schollz/progressbar/v3"
)

// DocumentExtensions are file extensions to process
var DocumentExtensions = map[string]bool{
        ".md":       true,
        ".txt":      true,
        ".rst":      true,
        ".adoc":     true,
        ".asciidoc": true,
}

// IgnoreDirs are directories to skip
var IgnoreDirs = map[string]bool{
        ".git":         true,
        "node_modules": true,
        "vendor":       true,
        "__pycache__":  true,
        ".venv":        true,
        "venv":         true,
        "dist":         true,
        "build":        true,
        ".next":        true,
        ".nuxt":        true,
}

// GitStrategy extracts documentation from git repositories
// Uses archive download as primary method (faster) with git clone as fallback
type GitStrategy struct {
        writer     *output.Writer
        logger     *utils.Logger
        httpClient *http.Client
}

// NewGitStrategy creates a new git strategy
func NewGitStrategy(deps *Dependencies) *GitStrategy <span class="cov0" title="0">{
        return &amp;GitStrategy{
                writer: deps.Writer,
                logger: deps.Logger,
                httpClient: &amp;http.Client{
                        Timeout: 10 * time.Minute,
                        CheckRedirect: func(req *http.Request, via []*http.Request) error </span><span class="cov0" title="0">{
                                if len(via) &gt;= 10 </span><span class="cov0" title="0">{
                                        return fmt.Errorf("too many redirects")
                                }</span>
                                <span class="cov0" title="0">return nil</span>
                        },
                },
        }
}

// Name returns the strategy name
func (s *GitStrategy) Name() string <span class="cov0" title="0">{
        return "git"
}</span>

// CanHandle returns true if this strategy can handle the given URL
func (s *GitStrategy) CanHandle(url string) bool <span class="cov0" title="0">{
        return strings.HasPrefix(url, "git@") ||
                strings.HasSuffix(url, ".git") ||
                strings.Contains(url, "github.com") ||
                strings.Contains(url, "gitlab.com") ||
                strings.Contains(url, "bitbucket.org")
}</span>

// Execute runs the git extraction strategy
// It tries archive download first (faster), falls back to git clone if needed
func (s *GitStrategy) Execute(ctx context.Context, url string, opts Options) error <span class="cov0" title="0">{
        s.logger.Info().Str("url", url).Msg("Starting git extraction")

        // Create temporary directory
        tmpDir, err := os.MkdirTemp("", "repodocs-git-*")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create temp dir: %w", err)
        }</span>
        <span class="cov0" title="0">defer os.RemoveAll(tmpDir)

        // Try archive download first (faster)
        branch, method, err := s.tryArchiveDownload(ctx, url, tmpDir)
        if err != nil </span><span class="cov0" title="0">{
                // Fallback to git clone
                s.logger.Info().Err(err).Msg("Archive download failed, using git clone")
                branch, err = s.cloneRepository(ctx, url, tmpDir)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to acquire repository: %w", err)
                }</span>
                <span class="cov0" title="0">method = "clone"</span>
        }

        <span class="cov0" title="0">s.logger.Info().
                Str("method", method).
                Str("branch", branch).
                Msg("Repository acquired successfully")

        // Find documentation files
        files, err := s.findDocumentationFiles(tmpDir)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">s.logger.Info().Int("count", len(files)).Msg("Found documentation files")

        // Apply limit
        if opts.Limit &gt; 0 &amp;&amp; len(files) &gt; opts.Limit </span><span class="cov0" title="0">{
                files = files[:opts.Limit]
        }</span>

        // Process files in parallel
        <span class="cov0" title="0">return s.processFiles(ctx, files, tmpDir, url, branch, opts)</span>
}

// repoInfo contains parsed repository information
type repoInfo struct {
        platform string // github, gitlab, bitbucket
        owner    string
        repo     string
}

// tryArchiveDownload attempts to download and extract repository as archive
// Returns branch name, method used ("archive"), and error if failed
func (s *GitStrategy) tryArchiveDownload(ctx context.Context, url, destDir string) (branch, method string, err error) <span class="cov0" title="0">{
        // SSH URLs not supported for archive download
        if strings.HasPrefix(url, "git@") </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("SSH URLs not supported for archive download")
        }</span>

        // Parse URL
        <span class="cov0" title="0">info, err := s.parseGitURL(url)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        // Detect default branch
        <span class="cov0" title="0">branch, err = s.detectDefaultBranch(ctx, url)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Warn().Err(err).Msg("Failed to detect branch, using 'main'")
                branch = "main"
        }</span>

        // Build archive URL
        <span class="cov0" title="0">archiveURL := s.buildArchiveURL(info, branch)
        s.logger.Debug().Str("archive_url", archiveURL).Msg("Downloading archive")

        // Download and extract
        if err := s.downloadAndExtract(ctx, archiveURL, destDir); err != nil </span><span class="cov0" title="0">{
                // If failed with 'main', try 'master'
                if branch == "main" </span><span class="cov0" title="0">{
                        s.logger.Debug().Msg("Trying 'master' branch")
                        archiveURL = s.buildArchiveURL(info, "master")
                        if err2 := s.downloadAndExtract(ctx, archiveURL, destDir); err2 == nil </span><span class="cov0" title="0">{
                                return "master", "archive", nil
                        }</span>
                }
                <span class="cov0" title="0">return "", "", err</span>
        }

        <span class="cov0" title="0">return branch, "archive", nil</span>
}

// parseGitURL extracts owner and repo from various git URL formats
func (s *GitStrategy) parseGitURL(url string) (*repoInfo, error) <span class="cov0" title="0">{
        patterns := []struct {
                platform string
                regex    *regexp.Regexp
        }{
                {"github", regexp.MustCompile(`github\.com[:/]([^/]+)/([^/.]+)`)},
                {"gitlab", regexp.MustCompile(`gitlab\.com[:/]([^/]+)/([^/.]+)`)},
                {"bitbucket", regexp.MustCompile(`bitbucket\.org[:/]([^/]+)/([^/.]+)`)},
        }

        for _, p := range patterns </span><span class="cov0" title="0">{
                if matches := p.regex.FindStringSubmatch(url); len(matches) == 3 </span><span class="cov0" title="0">{
                        return &amp;repoInfo{
                                platform: p.platform,
                                owner:    matches[1],
                                repo:     strings.TrimSuffix(matches[2], ".git"),
                        }, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("unsupported git URL format: %s", url)</span>
}

// detectDefaultBranch uses git ls-remote to find the default branch
func (s *GitStrategy) detectDefaultBranch(ctx context.Context, url string) (string, error) <span class="cov0" title="0">{
        cmd := exec.CommandContext(ctx, "git", "ls-remote", "--symref", url, "HEAD")
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("git ls-remote failed: %w", err)
        }</span>

        // Output format: "ref: refs/heads/master\tHEAD"
        <span class="cov0" title="0">scanner := bufio.NewScanner(strings.NewReader(string(output)))
        for scanner.Scan() </span><span class="cov0" title="0">{
                line := scanner.Text()
                if strings.HasPrefix(line, "ref: refs/heads/") </span><span class="cov0" title="0">{
                        // Split by tab first, then extract branch from first part
                        parts := strings.Split(line, "\t")
                        if len(parts) &gt;= 1 </span><span class="cov0" title="0">{
                                // parts[0] = "ref: refs/heads/master"
                                branch := strings.TrimPrefix(parts[0], "ref: refs/heads/")
                                return branch, nil
                        }</span>
                }
        }

        <span class="cov0" title="0">return "", fmt.Errorf("could not determine default branch")</span>
}

// buildArchiveURL constructs the archive download URL for the platform
func (s *GitStrategy) buildArchiveURL(info *repoInfo, branch string) string <span class="cov0" title="0">{
        switch info.platform </span>{
        case "github":<span class="cov0" title="0">
                return fmt.Sprintf("https://github.com/%s/%s/archive/refs/heads/%s.tar.gz",
                        info.owner, info.repo, branch)</span>
        case "gitlab":<span class="cov0" title="0">
                return fmt.Sprintf("https://gitlab.com/%s/%s/-/archive/%s/%s-%s.tar.gz",
                        info.owner, info.repo, branch, info.repo, branch)</span>
        case "bitbucket":<span class="cov0" title="0">
                return fmt.Sprintf("https://bitbucket.org/%s/%s/get/%s.tar.gz",
                        info.owner, info.repo, branch)</span>
        default:<span class="cov0" title="0">
                // Fallback to GitHub format
                return fmt.Sprintf("https://github.com/%s/%s/archive/refs/heads/%s.tar.gz",
                        info.owner, info.repo, branch)</span>
        }
}

// downloadAndExtract downloads a tar.gz archive and extracts it
func (s *GitStrategy) downloadAndExtract(ctx context.Context, archiveURL, destDir string) error <span class="cov0" title="0">{
        req, err := http.NewRequestWithContext(ctx, "GET", archiveURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Add authentication if available
        <span class="cov0" title="0">if token := os.Getenv("GITHUB_TOKEN"); token != "" </span><span class="cov0" title="0">{
                req.Header.Set("Authorization", "token "+token)
        }</span>

        <span class="cov0" title="0">resp, err := s.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("download request failed: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode == http.StatusNotFound </span><span class="cov0" title="0">{
                return fmt.Errorf("archive not found (404)")
        }</span>
        <span class="cov0" title="0">if resp.StatusCode == http.StatusUnauthorized </span><span class="cov0" title="0">{
                return fmt.Errorf("authentication required (401)")
        }</span>
        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return fmt.Errorf("download failed with status: %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">return s.extractTarGz(resp.Body, destDir)</span>
}

// extractTarGz extracts a tar.gz archive to destDir
func (s *GitStrategy) extractTarGz(r io.Reader, destDir string) error <span class="cov0" title="0">{
        gzr, err := gzip.NewReader(r)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("gzip reader failed: %w", err)
        }</span>
        <span class="cov0" title="0">defer gzr.Close()

        tr := tar.NewReader(gzr)

        for </span><span class="cov0" title="0">{
                header, err := tr.Next()
                if err == io.EOF </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("tar read failed: %w", err)
                }</span>

                // Skip the root directory (GitHub adds repo-branch/ prefix)
                <span class="cov0" title="0">parts := strings.SplitN(header.Name, "/", 2)
                if len(parts) &lt; 2 || parts[1] == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">relativePath := parts[1]

                targetPath := filepath.Join(destDir, relativePath)

                // Security check: prevent path traversal
                if !strings.HasPrefix(filepath.Clean(targetPath), filepath.Clean(destDir)) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">switch header.Typeflag </span>{
                case tar.TypeDir:<span class="cov0" title="0">
                        if err := os.MkdirAll(targetPath, 0755); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("mkdir failed: %w", err)
                        }</span>
                case tar.TypeReg:<span class="cov0" title="0">
                        if err := os.MkdirAll(filepath.Dir(targetPath), 0755); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("mkdir failed: %w", err)
                        }</span>

                        <span class="cov0" title="0">f, err := os.OpenFile(targetPath, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, os.FileMode(header.Mode))
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("create file failed: %w", err)
                        }</span>

                        <span class="cov0" title="0">if _, err := io.Copy(f, tr); err != nil </span><span class="cov0" title="0">{
                                f.Close()
                                return fmt.Errorf("copy failed: %w", err)
                        }</span>
                        <span class="cov0" title="0">f.Close()</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// cloneRepository clones the repository using git (fallback method)
func (s *GitStrategy) cloneRepository(ctx context.Context, url, destDir string) (string, error) <span class="cov0" title="0">{
        s.logger.Info().Str("url", url).Msg("Cloning repository")

        cloneOpts := &amp;git.CloneOptions{
                URL:      url,
                Depth:    1, // Shallow clone
                Progress: os.Stdout,
        }

        // Use HTTPS auth if available
        if token := os.Getenv("GITHUB_TOKEN"); token != "" </span><span class="cov0" title="0">{
                cloneOpts.Auth = &amp;githttp.BasicAuth{
                        Username: "token",
                        Password: token,
                }
        }</span>

        <span class="cov0" title="0">repo, err := git.PlainCloneContext(ctx, destDir, false, cloneOpts)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Get default branch name
        <span class="cov0" title="0">head, err := repo.Head()
        if err == nil </span><span class="cov0" title="0">{
                refName := head.Name().String()
                if strings.HasPrefix(refName, "refs/heads/") </span><span class="cov0" title="0">{
                        return strings.TrimPrefix(refName, "refs/heads/"), nil
                }</span>
        }

        <span class="cov0" title="0">return "main", nil</span>
}

// findDocumentationFiles walks the directory and finds all documentation files
func (s *GitStrategy) findDocumentationFiles(dir string) ([]string, error) <span class="cov0" title="0">{
        var files []string
        err := filepath.WalkDir(dir, func(path string, d fs.DirEntry, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Skip ignored directories
                <span class="cov0" title="0">if d.IsDir() </span><span class="cov0" title="0">{
                        if IgnoreDirs[d.Name()] </span><span class="cov0" title="0">{
                                return fs.SkipDir
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }

                // Check file extension
                <span class="cov0" title="0">ext := strings.ToLower(filepath.Ext(path))
                if DocumentExtensions[ext] </span><span class="cov0" title="0">{
                        files = append(files, path)
                }</span>

                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">return files, err</span>
}

// processFiles processes all documentation files in parallel
func (s *GitStrategy) processFiles(ctx context.Context, files []string, tmpDir, repoURL, branch string, opts Options) error <span class="cov0" title="0">{
        // Create progress bar
        bar := progressbar.NewOptions(len(files),
                progressbar.OptionSetDescription("Processing"),
                progressbar.OptionShowCount(),
        )

        // Process files in parallel using existing infrastructure
        errors := utils.ParallelForEach(ctx, files, opts.Concurrency, func(ctx context.Context, file string) error </span><span class="cov0" title="0">{
                defer bar.Add(1)

                if err := s.processFile(ctx, file, tmpDir, repoURL, branch, opts); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn().Err(err).Str("file", file).Msg("Failed to process file")
                }</span>
                <span class="cov0" title="0">return nil</span>
        })

        // Check for critical errors (context cancellation)
        <span class="cov0" title="0">if err := utils.FirstError(errors); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">s.logger.Info().Msg("Git extraction completed")
        return nil</span>
}

// processFile processes a single documentation file
func (s *GitStrategy) processFile(ctx context.Context, path, tmpDir, repoURL, branch string, opts Options) error <span class="cov0" title="0">{
        // Read file content
        content, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Skip large files (&gt; 10MB)
        <span class="cov0" title="0">if len(content) &gt; 10*1024*1024 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Get relative path for URL
        <span class="cov0" title="0">relPath, _ := filepath.Rel(tmpDir, path)
        // Convert Windows backslashes to forward slashes for URL
        relPathURL := strings.ReplaceAll(relPath, "\\", "/")
        fileURL := repoURL + "/blob/" + branch + "/" + relPathURL

        // Create document
        doc := &amp;domain.Document{
                URL:            fileURL,
                Title:          extractTitleFromPath(relPath),
                Content:        string(content),
                FetchedAt:      time.Now(),
                WordCount:      len(strings.Fields(string(content))),
                CharCount:      len(content),
                SourceStrategy: s.Name(),
                RelativePath:   relPath,
        }

        // For markdown files, the content is already markdown
        ext := strings.ToLower(filepath.Ext(path))
        if ext != ".md" </span><span class="cov0" title="0">{
                // For other formats, wrap in code block
                doc.Content = "```\n" + string(content) + "\n```"
        }</span>

        // Write document
        <span class="cov0" title="0">if !opts.DryRun </span><span class="cov0" title="0">{
                return s.writer.Write(ctx, doc)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// extractTitleFromPath extracts a title from a file path
func extractTitleFromPath(path string) string <span class="cov0" title="0">{
        // Get filename without extension
        base := filepath.Base(path)
        ext := filepath.Ext(base)
        name := strings.TrimSuffix(base, ext)

        // Convert common formats to title case
        name = strings.ReplaceAll(name, "-", " ")
        name = strings.ReplaceAll(name, "_", " ")

        // Capitalize first letter
        if len(name) &gt; 0 </span><span class="cov0" title="0">{
                name = strings.ToUpper(name[:1]) + name[1:]
        }</span>

        <span class="cov0" title="0">return name</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package strategies

import (
        "context"
        "regexp"
        "strings"
        "time"

        "github.com/quantmind-br/repodocs-go/internal/converter"
        "github.com/quantmind-br/repodocs-go/internal/domain"
        "github.com/quantmind-br/repodocs-go/internal/fetcher"
        "github.com/quantmind-br/repodocs-go/internal/output"
        "github.com/quantmind-br/repodocs-go/internal/utils"
        "github.com/schollz/progressbar/v3"
)

// LLMSStrategy extracts documentation from llms.txt files
type LLMSStrategy struct {
        fetcher   *fetcher.Client
        converter *converter.Pipeline
        writer    *output.Writer
        logger    *utils.Logger
}

// NewLLMSStrategy creates a new LLMS strategy
func NewLLMSStrategy(deps *Dependencies) *LLMSStrategy <span class="cov0" title="0">{
        return &amp;LLMSStrategy{
                fetcher:   deps.Fetcher,
                converter: deps.Converter,
                writer:    deps.Writer,
                logger:    deps.Logger,
        }
}</span>

// Name returns the strategy name
func (s *LLMSStrategy) Name() string <span class="cov0" title="0">{
        return "llms"
}</span>

// CanHandle returns true if this strategy can handle the given URL
func (s *LLMSStrategy) CanHandle(url string) bool <span class="cov0" title="0">{
        return strings.HasSuffix(url, "/llms.txt") || strings.HasSuffix(url, "llms.txt")
}</span>

// Execute runs the LLMS extraction strategy
func (s *LLMSStrategy) Execute(ctx context.Context, url string, opts Options) error <span class="cov0" title="0">{
        s.logger.Info().Str("url", url).Msg("Fetching llms.txt")

        // Fetch llms.txt content
        resp, err := s.fetcher.Get(ctx, url)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Parse links from llms.txt
        <span class="cov0" title="0">links := parseLLMSLinks(string(resp.Body))
        s.logger.Info().Int("count", len(links)).Msg("Found links in llms.txt")

        // Apply limit
        if opts.Limit &gt; 0 &amp;&amp; len(links) &gt; opts.Limit </span><span class="cov0" title="0">{
                links = links[:opts.Limit]
        }</span>

        // Create progress bar
        <span class="cov0" title="0">bar := progressbar.NewOptions(len(links),
                progressbar.OptionSetDescription("Downloading"),
                progressbar.OptionShowCount(),
                progressbar.OptionShowIts(),
        )

        // Process links concurrently
        errors := utils.ParallelForEach(ctx, links, opts.Concurrency, func(ctx context.Context, link domain.LLMSLink) error </span><span class="cov0" title="0">{
                defer bar.Add(1)

                // Check if already exists
                if !opts.Force &amp;&amp; s.writer.Exists(link.URL) </span><span class="cov0" title="0">{
                        return nil
                }</span>

                // Fetch page
                <span class="cov0" title="0">pageResp, err := s.fetcher.Get(ctx, link.URL)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn().Err(err).Str("url", link.URL).Msg("Failed to fetch page")
                        return nil // Continue with other pages
                }</span>

                // Convert to document
                <span class="cov0" title="0">doc, err := s.converter.Convert(ctx, string(pageResp.Body), link.URL)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn().Err(err).Str("url", link.URL).Msg("Failed to convert page")
                        return nil
                }</span>

                // Set metadata
                <span class="cov0" title="0">doc.SourceStrategy = s.Name()
                doc.CacheHit = pageResp.FromCache
                doc.FetchedAt = time.Now()

                // Use title from llms.txt if document title is empty
                if doc.Title == "" &amp;&amp; link.Title != "" </span><span class="cov0" title="0">{
                        doc.Title = link.Title
                }</span>

                // Write document
                <span class="cov0" title="0">if !opts.DryRun </span><span class="cov0" title="0">{
                        if err := s.writer.Write(ctx, doc); err != nil </span><span class="cov0" title="0">{
                                s.logger.Warn().Err(err).Str("url", link.URL).Msg("Failed to write document")
                                return nil
                        }</span>
                }

                <span class="cov0" title="0">return nil</span>
        })

        // Check for errors
        <span class="cov0" title="0">if err := utils.FirstError(errors); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">s.logger.Info().Msg("LLMS extraction completed")
        return nil</span>
}

// linkRegex matches markdown links: [Title](url)
var linkRegex = regexp.MustCompile(`\[([^\]]+)\]\(([^)]+)\)`)

// parseLLMSLinks parses markdown links from llms.txt content
func parseLLMSLinks(content string) []domain.LLMSLink <span class="cov0" title="0">{
        var links []domain.LLMSLink

        matches := linkRegex.FindAllStringSubmatch(content, -1)
        for _, match := range matches </span><span class="cov0" title="0">{
                if len(match) == 3 </span><span class="cov0" title="0">{
                        title := strings.TrimSpace(match[1])
                        url := strings.TrimSpace(match[2])

                        // Skip empty URLs or anchors
                        if url == "" || strings.HasPrefix(url, "#") </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">links = append(links, domain.LLMSLink{
                                Title: title,
                                URL:   url,
                        })</span>
                }
        }

        <span class="cov0" title="0">return links</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package strategies

import (
        "context"
        "strings"
        "time"

        "github.com/PuerkitoBio/goquery"
        "github.com/quantmind-br/repodocs-go/internal/converter"
        "github.com/quantmind-br/repodocs-go/internal/fetcher"
        "github.com/quantmind-br/repodocs-go/internal/output"
        "github.com/quantmind-br/repodocs-go/internal/utils"
)

// PkgGoStrategy extracts documentation from pkg.go.dev
type PkgGoStrategy struct {
        fetcher   *fetcher.Client
        converter *converter.Pipeline
        writer    *output.Writer
        logger    *utils.Logger
}

// NewPkgGoStrategy creates a new pkg.go.dev strategy
func NewPkgGoStrategy(deps *Dependencies) *PkgGoStrategy <span class="cov0" title="0">{
        return &amp;PkgGoStrategy{
                fetcher:   deps.Fetcher,
                converter: deps.Converter,
                writer:    deps.Writer,
                logger:    deps.Logger,
        }
}</span>

// Name returns the strategy name
func (s *PkgGoStrategy) Name() string <span class="cov0" title="0">{
        return "pkggo"
}</span>

// CanHandle returns true if this strategy can handle the given URL
func (s *PkgGoStrategy) CanHandle(url string) bool <span class="cov0" title="0">{
        return strings.Contains(url, "pkg.go.dev")
}</span>

// Execute runs the pkg.go.dev extraction strategy
func (s *PkgGoStrategy) Execute(ctx context.Context, url string, opts Options) error <span class="cov0" title="0">{
        s.logger.Info().Str("url", url).Msg("Fetching pkg.go.dev documentation")

        // Fetch page
        resp, err := s.fetcher.Get(ctx, url)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Parse HTML
        <span class="cov0" title="0">doc, err := goquery.NewDocumentFromReader(strings.NewReader(string(resp.Body)))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Extract package name
        <span class="cov0" title="0">packageName := doc.Find("h1.UnitHeader-title").First().Text()
        packageName = strings.TrimSpace(packageName)

        // If split option is enabled, extract sections separately
        if opts.Split </span><span class="cov0" title="0">{
                return s.extractSections(ctx, doc, url, packageName, opts)
        }</span>

        // Extract main documentation content
        <span class="cov0" title="0">content := doc.Find("div.Documentation-content").First()
        if content.Length() == 0 </span><span class="cov0" title="0">{
                // Fallback to main content area
                content = doc.Find("main").First()
        }</span>

        <span class="cov0" title="0">contentHTML, err := content.Html()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Convert to document
        <span class="cov0" title="0">document, err := s.converter.Convert(ctx, contentHTML, url)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Set metadata
        <span class="cov0" title="0">document.Title = packageName
        document.SourceStrategy = s.Name()
        document.CacheHit = resp.FromCache
        document.FetchedAt = time.Now()

        // Write document
        if !opts.DryRun </span><span class="cov0" title="0">{
                return s.writer.Write(ctx, document)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// extractSections extracts documentation split by sections
func (s *PkgGoStrategy) extractSections(ctx context.Context, doc *goquery.Document, baseURL, packageName string, opts Options) error <span class="cov0" title="0">{
        sections := []struct {
                selector string
                name     string
        }{
                {"#pkg-overview", "Overview"},
                {"#pkg-index", "Index"},
                {"#pkg-constants", "Constants"},
                {"#pkg-variables", "Variables"},
                {"#pkg-functions", "Functions"},
                {"#pkg-types", "Types"},
        }

        for _, section := range sections </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                default:<span class="cov0" title="0"></span>
                }

                <span class="cov0" title="0">content := doc.Find(section.selector).First()
                if content.Length() == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Get section HTML
                <span class="cov0" title="0">sectionHTML, err := content.Html()
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Skip empty sections
                <span class="cov0" title="0">if strings.TrimSpace(sectionHTML) == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Create section URL
                <span class="cov0" title="0">sectionURL := baseURL + section.selector

                // Convert to document
                document, err := s.converter.Convert(ctx, sectionHTML, sectionURL)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn().Err(err).Str("section", section.name).Msg("Failed to convert section")
                        continue</span>
                }

                // Set metadata
                <span class="cov0" title="0">document.Title = packageName + " - " + section.name
                document.SourceStrategy = s.Name()
                document.FetchedAt = time.Now()

                // Write document
                if !opts.DryRun </span><span class="cov0" title="0">{
                        if err := s.writer.Write(ctx, document); err != nil </span><span class="cov0" title="0">{
                                s.logger.Warn().Err(err).Str("section", section.name).Msg("Failed to write section")
                        }</span>
                }
        }

        <span class="cov0" title="0">s.logger.Info().Msg("pkg.go.dev extraction completed")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package strategies

import (
        "compress/gzip"
        "context"
        "encoding/xml"
        "io"
        "sort"
        "strings"
        "time"

        "github.com/quantmind-br/repodocs-go/internal/converter"
        "github.com/quantmind-br/repodocs-go/internal/domain"
        "github.com/quantmind-br/repodocs-go/internal/fetcher"
        "github.com/quantmind-br/repodocs-go/internal/output"
        "github.com/quantmind-br/repodocs-go/internal/renderer"
        "github.com/quantmind-br/repodocs-go/internal/utils"
        "github.com/schollz/progressbar/v3"
)

// SitemapStrategy extracts documentation from sitemap XML files
type SitemapStrategy struct {
        fetcher   *fetcher.Client
        renderer  domain.Renderer
        converter *converter.Pipeline
        writer    *output.Writer
        logger    *utils.Logger
}

// NewSitemapStrategy creates a new sitemap strategy
func NewSitemapStrategy(deps *Dependencies) *SitemapStrategy <span class="cov8" title="1">{
        return &amp;SitemapStrategy{
                fetcher:   deps.Fetcher,
                renderer:  deps.Renderer,
                converter: deps.Converter,
                writer:    deps.Writer,
                logger:    deps.Logger,
        }
}</span>

// Name returns the strategy name
func (s *SitemapStrategy) Name() string <span class="cov8" title="1">{
        return "sitemap"
}</span>

// CanHandle returns true if this strategy can handle the given URL
func (s *SitemapStrategy) CanHandle(url string) bool <span class="cov0" title="0">{
        lower := strings.ToLower(url)
        return strings.HasSuffix(lower, "sitemap.xml") ||
                strings.HasSuffix(lower, "sitemap.xml.gz") ||
                strings.Contains(lower, "sitemap")
}</span>

// Execute runs the sitemap extraction strategy
func (s *SitemapStrategy) Execute(ctx context.Context, url string, opts Options) error <span class="cov8" title="1">{
        s.logger.Info().Str("url", url).Msg("Fetching sitemap")

        // Fetch sitemap
        resp, err := s.fetcher.Get(ctx, url)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Decompress if gzipped
        <span class="cov8" title="1">content := resp.Body
        if strings.HasSuffix(strings.ToLower(url), ".gz") </span><span class="cov0" title="0">{
                content, err = decompressGzip(resp.Body)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Parse sitemap
        <span class="cov8" title="1">sitemap, err := parseSitemap(content, url)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // If it's a sitemap index, process each sitemap
        <span class="cov8" title="1">if sitemap.IsIndex </span><span class="cov8" title="1">{
                return s.processSitemapIndex(ctx, sitemap, opts)
        }</span>

        // Sort by lastmod (most recent first)
        <span class="cov8" title="1">sortURLsByLastMod(sitemap.URLs)

        // Apply limit
        urls := sitemap.URLs
        if opts.Limit &gt; 0 &amp;&amp; len(urls) &gt; opts.Limit </span><span class="cov0" title="0">{
                urls = urls[:opts.Limit]
        }</span>

        <span class="cov8" title="1">s.logger.Info().Int("count", len(urls)).Msg("Processing URLs from sitemap")

        // Create progress bar
        bar := progressbar.NewOptions(len(urls),
                progressbar.OptionSetDescription("Downloading"),
                progressbar.OptionShowCount(),
                progressbar.OptionShowIts(),
        )

        // Process URLs concurrently
        errors := utils.ParallelForEach(ctx, urls, opts.Concurrency, func(ctx context.Context, sitemapURL domain.SitemapURL) error </span><span class="cov8" title="1">{
                defer bar.Add(1)

                // Check if already exists
                if !opts.Force &amp;&amp; s.writer.Exists(sitemapURL.Loc) </span><span class="cov0" title="0">{
                        return nil
                }</span>

                // Fetch page
                <span class="cov8" title="1">var html string
                var fromCache bool

                pageResp, err := s.fetcher.Get(ctx, sitemapURL.Loc)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn().Err(err).Str("url", sitemapURL.Loc).Msg("Failed to fetch page")
                        return nil
                }</span>
                <span class="cov8" title="1">html = string(pageResp.Body)
                fromCache = pageResp.FromCache

                // Check if JS rendering is needed
                if opts.RenderJS || renderer.NeedsJSRendering(html) </span><span class="cov0" title="0">{
                        if s.renderer != nil </span><span class="cov0" title="0">{
                                rendered, err := s.renderer.Render(ctx, sitemapURL.Loc, domain.RenderOptions{
                                        Timeout:     60 * time.Second,
                                        WaitStable:  2 * time.Second,
                                        ScrollToEnd: true,
                                })
                                if err == nil </span><span class="cov0" title="0">{
                                        html = rendered
                                }</span>
                        }
                }

                // Convert to document
                <span class="cov8" title="1">doc, err := s.converter.Convert(ctx, html, sitemapURL.Loc)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn().Err(err).Str("url", sitemapURL.Loc).Msg("Failed to convert page")
                        return nil
                }</span>

                // Set metadata
                <span class="cov8" title="1">doc.SourceStrategy = s.Name()
                doc.CacheHit = fromCache
                doc.FetchedAt = time.Now()

                // Write document
                if !opts.DryRun </span><span class="cov8" title="1">{
                        if err := s.writer.Write(ctx, doc); err != nil </span><span class="cov0" title="0">{
                                s.logger.Warn().Err(err).Str("url", sitemapURL.Loc).Msg("Failed to write document")
                                return nil
                        }</span>
                }

                <span class="cov8" title="1">return nil</span>
        })

        <span class="cov8" title="1">if err := utils.FirstError(errors); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">s.logger.Info().Msg("Sitemap extraction completed")
        return nil</span>
}

// processSitemapIndex processes a sitemap index file
func (s *SitemapStrategy) processSitemapIndex(ctx context.Context, sitemap *domain.Sitemap, opts Options) error <span class="cov8" title="1">{
        s.logger.Info().Int("count", len(sitemap.Sitemaps)).Msg("Processing sitemap index")

        for _, sitemapURL := range sitemap.Sitemaps </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        return ctx.Err()</span>
                default:<span class="cov8" title="1"></span>
                }

                <span class="cov8" title="1">if err := s.Execute(ctx, sitemapURL, opts); err != nil </span><span class="cov8" title="1">{
                        s.logger.Warn().Err(err).Str("url", sitemapURL).Msg("Failed to process nested sitemap")
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// sitemapXML represents the XML structure of a sitemap
type sitemapXML struct {
        XMLName xml.Name     `xml:"urlset"`
        URLs    []sitemapURL `xml:"url"`
}

type sitemapURL struct {
        Loc        string `xml:"loc"`
        LastMod    string `xml:"lastmod"`
        ChangeFreq string `xml:"changefreq"`
        Priority   string `xml:"priority"`
}

// sitemapIndexXML represents the XML structure of a sitemap index
type sitemapIndexXML struct {
        XMLName  xml.Name          `xml:"sitemapindex"`
        Sitemaps []sitemapLocation `xml:"sitemap"`
}

type sitemapLocation struct {
        Loc     string `xml:"loc"`
        LastMod string `xml:"lastmod"`
}

// parseSitemap parses sitemap XML content
func parseSitemap(content []byte, sourceURL string) (*domain.Sitemap, error) <span class="cov8" title="1">{
        // Try to parse as sitemap index first
        var index sitemapIndexXML
        if err := xml.Unmarshal(content, &amp;index); err == nil &amp;&amp; len(index.Sitemaps) &gt; 0 </span><span class="cov8" title="1">{
                var sitemaps []string
                for _, sm := range index.Sitemaps </span><span class="cov8" title="1">{
                        sitemaps = append(sitemaps, sm.Loc)
                }</span>
                <span class="cov8" title="1">return &amp;domain.Sitemap{
                        IsIndex:   true,
                        Sitemaps:  sitemaps,
                        SourceURL: sourceURL,
                }, nil</span>
        }

        // Parse as regular sitemap
        <span class="cov8" title="1">var sitemap sitemapXML
        if err := xml.Unmarshal(content, &amp;sitemap); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var urls []domain.SitemapURL
        for _, u := range sitemap.URLs </span><span class="cov8" title="1">{
                lastMod, _ := parseLastMod(u.LastMod)
                urls = append(urls, domain.SitemapURL{
                        Loc:        u.Loc,
                        LastMod:    lastMod,
                        LastModStr: u.LastMod,
                        ChangeFreq: u.ChangeFreq,
                })
        }</span>

        <span class="cov8" title="1">return &amp;domain.Sitemap{
                URLs:      urls,
                IsIndex:   false,
                SourceURL: sourceURL,
        }, nil</span>
}

// parseLastMod parses a lastmod date string
func parseLastMod(s string) (time.Time, error) <span class="cov8" title="1">{
        formats := []string{
                time.RFC3339,
                "2006-01-02T15:04:05-07:00",
                "2006-01-02T15:04:05Z",
                "2006-01-02",
        }

        for _, format := range formats </span><span class="cov8" title="1">{
                if t, err := time.Parse(format, s); err == nil </span><span class="cov8" title="1">{
                        return t, nil
                }</span>
        }

        <span class="cov8" title="1">return time.Time{}, nil</span>
}

// sortURLsByLastMod sorts URLs by lastmod date (most recent first)
func sortURLsByLastMod(urls []domain.SitemapURL) <span class="cov8" title="1">{
        sort.Slice(urls, func(i, j int) bool </span><span class="cov0" title="0">{
                return urls[i].LastMod.After(urls[j].LastMod)
        }</span>)
}

// decompressGzip decompresses gzip content
func decompressGzip(data []byte) ([]byte, error) <span class="cov8" title="1">{
        reader, err := gzip.NewReader(strings.NewReader(string(data)))
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer reader.Close()

        return io.ReadAll(reader)</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package strategies

import (
        "context"
        "time"

        "github.com/quantmind-br/repodocs-go/internal/cache"
        "github.com/quantmind-br/repodocs-go/internal/converter"
        "github.com/quantmind-br/repodocs-go/internal/domain"
        "github.com/quantmind-br/repodocs-go/internal/fetcher"
        "github.com/quantmind-br/repodocs-go/internal/output"
        "github.com/quantmind-br/repodocs-go/internal/renderer"
        "github.com/quantmind-br/repodocs-go/internal/utils"
)

// Strategy defines the interface for documentation extraction strategies
type Strategy interface {
        // Name returns the strategy name
        Name() string
        // CanHandle returns true if this strategy can handle the given URL
        CanHandle(url string) bool
        // Execute runs the extraction strategy
        Execute(ctx context.Context, url string, opts Options) error
}

// Options contains common options for all strategies
type Options struct {
        Output          string
        Concurrency     int
        Limit           int
        MaxDepth        int
        Exclude         []string
        NoFolders       bool
        DryRun          bool
        Verbose         bool
        Force           bool
        RenderJS        bool
        Split           bool
        IncludeAssets   bool
        ContentSelector string
        CacheTTL        string
        FilterURL       string // Base URL filter - only crawl URLs starting with this path
}

// DefaultOptions returns default strategy options
func DefaultOptions() Options <span class="cov0" title="0">{
        return Options{
                Output:      "./docs",
                Concurrency: 5,
                Limit:       0,
                MaxDepth:    3,
                NoFolders:   false,
                DryRun:      false,
                Verbose:     false,
                Force:       false,
                RenderJS:    false,
                Split:       false,
        }
}</span>

// Dependencies contains shared dependencies for all strategies
type Dependencies struct {
        Fetcher   *fetcher.Client
        Renderer  domain.Renderer
        Cache     domain.Cache
        Converter *converter.Pipeline
        Writer    *output.Writer
        Logger    *utils.Logger
}

// NewDependencies creates new dependencies for strategies
func NewDependencies(opts DependencyOptions) (*Dependencies, error) <span class="cov8" title="1">{
        // Create fetcher
        fetcherClient, err := fetcher.NewClient(fetcher.ClientOptions{
                Timeout:     opts.Timeout,
                MaxRetries:  3,
                EnableCache: opts.EnableCache,
                CacheTTL:    opts.CacheTTL,
                UserAgent:   opts.UserAgent,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Create cache if enabled
        <span class="cov8" title="1">var cacheImpl domain.Cache
        if opts.EnableCache </span><span class="cov0" title="0">{
                cacheImpl, err = cache.NewBadgerCache(cache.Options{
                        Directory: opts.CacheDir,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">fetcherClient.SetCache(cacheImpl)</span>
        }

        // Create renderer if needed
        <span class="cov8" title="1">var rendererImpl domain.Renderer
        if opts.EnableRenderer </span><span class="cov0" title="0">{
                r, err := renderer.NewRenderer(renderer.RendererOptions{
                        Timeout:  opts.RendererTimeout,
                        MaxTabs:  opts.Concurrency,
                        Stealth:  true,
                        Headless: true,
                })
                if err != nil </span><span class="cov0" title="0">{
                        // Renderer is optional, continue without it
                        rendererImpl = nil
                }</span> else<span class="cov0" title="0"> {
                        rendererImpl = r
                }</span>
        }

        // Create converter
        <span class="cov8" title="1">converterPipeline := converter.NewPipeline(converter.PipelineOptions{
                BaseURL:         "",
                ContentSelector: opts.ContentSelector,
        })

        // Create writer
        writer := output.NewWriter(output.WriterOptions{
                BaseDir:      opts.OutputDir,
                Flat:         opts.Flat,
                JSONMetadata: opts.JSONMetadata,
                Force:        opts.Force,
                DryRun:       opts.DryRun,
        })

        // Create logger
        logger := utils.NewLogger(utils.LoggerOptions{
                Level:   "info",
                Format:  "pretty",
                Verbose: opts.Verbose,
        })

        return &amp;Dependencies{
                Fetcher:   fetcherClient,
                Renderer:  rendererImpl,
                Cache:     cacheImpl,
                Converter: converterPipeline,
                Writer:    writer,
                Logger:    logger,
        }, nil</span>
}

// Close releases all resources
func (d *Dependencies) Close() error <span class="cov8" title="1">{
        if d.Fetcher != nil </span><span class="cov8" title="1">{
                d.Fetcher.Close()
        }</span>
        <span class="cov8" title="1">if d.Renderer != nil </span><span class="cov0" title="0">{
                d.Renderer.Close()
        }</span>
        <span class="cov8" title="1">if d.Cache != nil </span><span class="cov0" title="0">{
                d.Cache.Close()
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// DependencyOptions contains options for creating dependencies
type DependencyOptions struct {
        Timeout         time.Duration
        EnableCache     bool
        CacheTTL        time.Duration
        CacheDir        string
        UserAgent       string
        EnableRenderer  bool
        RendererTimeout time.Duration
        Concurrency     int
        ContentSelector string
        OutputDir       string
        Flat            bool
        JSONMetadata    bool
        Force           bool
        DryRun          bool
        Verbose         bool
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package utils

import (
        "net/url"
        "os"
        "path/filepath"
        "regexp"
        "strings"
        "unicode"
)

// MaxFilenameLength is the maximum length for a filename
const MaxFilenameLength = 200

// Windows reserved names
var windowsReserved = map[string]bool{
        "CON": true, "PRN": true, "AUX": true, "NUL": true,
        "COM1": true, "COM2": true, "COM3": true, "COM4": true,
        "COM5": true, "COM6": true, "COM7": true, "COM8": true, "COM9": true,
        "LPT1": true, "LPT2": true, "LPT3": true, "LPT4": true,
        "LPT5": true, "LPT6": true, "LPT7": true, "LPT8": true, "LPT9": true,
}

// invalidCharsRegex matches invalid filename characters
var invalidCharsRegex = regexp.MustCompile(`[&lt;&gt;:"|?*\\/]`)

// multipleSpacesRegex matches multiple consecutive spaces/dashes
var multipleSpacesRegex = regexp.MustCompile(`[-_\s]+`)

// SanitizeFilename sanitizes a string for use as a filename
func SanitizeFilename(name string) string <span class="cov0" title="0">{
        // Remove invalid characters
        name = invalidCharsRegex.ReplaceAllString(name, "-")

        // Replace multiple spaces/dashes with single dash
        name = multipleSpacesRegex.ReplaceAllString(name, "-")

        // Trim leading/trailing dashes and spaces
        name = strings.Trim(name, "- ")

        // Check for Windows reserved names
        upper := strings.ToUpper(name)
        baseName := strings.TrimSuffix(upper, filepath.Ext(upper))
        if windowsReserved[baseName] </span><span class="cov0" title="0">{
                name = "_" + name
        }</span>

        // Limit length
        <span class="cov0" title="0">if len(name) &gt; MaxFilenameLength </span><span class="cov0" title="0">{
                ext := filepath.Ext(name)
                name = name[:MaxFilenameLength-len(ext)] + ext
        }</span>

        // Ensure the name is not empty
        <span class="cov0" title="0">if name == "" </span><span class="cov0" title="0">{
                name = "untitled"
        }</span>

        <span class="cov0" title="0">return name</span>
}

// URLToFilename converts a URL to a safe filename
func URLToFilename(rawURL string) string <span class="cov0" title="0">{
        u, err := url.Parse(rawURL)
        if err != nil </span><span class="cov0" title="0">{
                return SanitizeFilename(rawURL)
        }</span>

        // Get path and remove leading/trailing slashes
        <span class="cov0" title="0">path := strings.Trim(u.Path, "/")
        if path == "" </span><span class="cov0" title="0">{
                path = "index"
        }</span>

        // Replace path separators with dashes for flat structure
        <span class="cov0" title="0">path = strings.ReplaceAll(path, "/", "-")

        // Remove common file extensions
        path = strings.TrimSuffix(path, ".html")
        path = strings.TrimSuffix(path, ".htm")
        path = strings.TrimSuffix(path, ".php")

        // Sanitize and add .md extension
        filename := SanitizeFilename(path)
        if !strings.HasSuffix(filename, ".md") </span><span class="cov0" title="0">{
                filename += ".md"
        }</span>

        <span class="cov0" title="0">return filename</span>
}

// URLToPath converts a URL to a nested directory path
func URLToPath(rawURL string) string <span class="cov0" title="0">{
        u, err := url.Parse(rawURL)
        if err != nil </span><span class="cov0" title="0">{
                return SanitizeFilename(rawURL) + ".md"
        }</span>

        // Get path and remove leading/trailing slashes
        <span class="cov0" title="0">path := strings.Trim(u.Path, "/")
        if path == "" </span><span class="cov0" title="0">{
                path = "index"
        }</span>

        // Remove common file extensions
        <span class="cov0" title="0">path = strings.TrimSuffix(path, ".html")
        path = strings.TrimSuffix(path, ".htm")
        path = strings.TrimSuffix(path, ".php")

        // Split path and sanitize each component
        parts := strings.Split(path, "/")
        for i, part := range parts </span><span class="cov0" title="0">{
                parts[i] = SanitizeFilename(part)
        }</span>

        // Join with OS-specific separator
        <span class="cov0" title="0">result := filepath.Join(parts...)

        // Add .md extension if not present
        if !strings.HasSuffix(result, ".md") </span><span class="cov0" title="0">{
                result += ".md"
        }</span>

        <span class="cov0" title="0">return result</span>
}

// GeneratePath generates the output path for a URL
func GeneratePath(baseDir, rawURL string, flat bool) string <span class="cov0" title="0">{
        var relativePath string
        if flat </span><span class="cov0" title="0">{
                relativePath = URLToFilename(rawURL)
        }</span> else<span class="cov0" title="0"> {
                relativePath = URLToPath(rawURL)
        }</span>
        <span class="cov0" title="0">return filepath.Join(baseDir, relativePath)</span>
}

// GeneratePathFromRelative generates the output path from a relative file path
// Used for Git-sourced files to preserve the repository's directory structure
func GeneratePathFromRelative(baseDir, relPath string, flat bool) string <span class="cov0" title="0">{
        if flat </span><span class="cov0" title="0">{
                // For flat mode, use only the filename
                filename := filepath.Base(relPath)
                // Remove extension and add .md if needed
                ext := filepath.Ext(filename)
                name := strings.TrimSuffix(filename, ext)
                name = SanitizeFilename(name)
                if !strings.HasSuffix(name, ".md") </span><span class="cov0" title="0">{
                        name += ".md"
                }</span>
                <span class="cov0" title="0">return filepath.Join(baseDir, name)</span>
        }

        // For nested mode, preserve directory structure
        // Ensure path uses OS-specific separators
        <span class="cov0" title="0">relPath = filepath.FromSlash(relPath)

        // Sanitize each component
        parts := strings.Split(relPath, string(filepath.Separator))
        for i, part := range parts </span><span class="cov0" title="0">{
                parts[i] = SanitizeFilename(part)
        }</span>
        <span class="cov0" title="0">result := filepath.Join(parts...)

        // Add .md extension if not present
        if !strings.HasSuffix(result, ".md") </span><span class="cov0" title="0">{
                result += ".md"
        }</span>

        <span class="cov0" title="0">return filepath.Join(baseDir, result)</span>
}

// JSONPath returns the corresponding JSON metadata path for a markdown file
func JSONPath(mdPath string) string <span class="cov0" title="0">{
        return strings.TrimSuffix(mdPath, ".md") + ".json"
}</span>

// IsValidFilename checks if a filename is valid
func IsValidFilename(name string) bool <span class="cov0" title="0">{
        if name == "" || name == "." || name == ".." </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check for invalid characters
        <span class="cov0" title="0">if invalidCharsRegex.MatchString(name) </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check for Windows reserved names
        <span class="cov0" title="0">upper := strings.ToUpper(name)
        baseName := strings.TrimSuffix(upper, filepath.Ext(upper))
        if windowsReserved[baseName] </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check for control characters
        <span class="cov0" title="0">for _, r := range name </span><span class="cov0" title="0">{
                if unicode.IsControl(r) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

// EnsureDir ensures a directory exists, creating it if necessary
func EnsureDir(path string) error <span class="cov0" title="0">{
        dir := filepath.Dir(path)
        return os.MkdirAll(dir, 0755)
}</span>

// ExpandPath expands ~ to the user's home directory
func ExpandPath(path string) string <span class="cov0" title="0">{
        if strings.HasPrefix(path, "~/") </span><span class="cov0" title="0">{
                home, err := os.UserHomeDir()
                if err != nil </span><span class="cov0" title="0">{
                        return path
                }</span>
                <span class="cov0" title="0">return filepath.Join(home, path[2:])</span>
        }
        <span class="cov0" title="0">if path == "~" </span><span class="cov0" title="0">{
                home, err := os.UserHomeDir()
                if err != nil </span><span class="cov0" title="0">{
                        return path
                }</span>
                <span class="cov0" title="0">return home</span>
        }
        <span class="cov0" title="0">return path</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package utils

import (
        "io"
        "os"
        "time"

        "github.com/rs/zerolog"
)

// Logger is a wrapper around zerolog.Logger
type Logger struct {
        zerolog.Logger
}

// LoggerOptions contains options for creating a logger
type LoggerOptions struct {
        Level   string
        Format  string // "pretty" or "json"
        Output  io.Writer
        Verbose bool
}

// NewLogger creates a new logger with the given options
func NewLogger(opts LoggerOptions) *Logger <span class="cov0" title="0">{
        var output io.Writer = os.Stderr
        if opts.Output != nil </span><span class="cov0" title="0">{
                output = opts.Output
        }</span>

        // Set up pretty or JSON output
        <span class="cov0" title="0">if opts.Format == "pretty" </span><span class="cov0" title="0">{
                output = zerolog.ConsoleWriter{
                        Out:        output,
                        TimeFormat: time.RFC3339,
                }
        }</span>

        // Parse log level
        <span class="cov0" title="0">level := parseLogLevel(opts.Level)
        if opts.Verbose </span><span class="cov0" title="0">{
                level = zerolog.DebugLevel
        }</span>

        // Create logger
        <span class="cov0" title="0">logger := zerolog.New(output).
                Level(level).
                With().
                Timestamp().
                Logger()

        return &amp;Logger{Logger: logger}</span>
}

// NewDefaultLogger creates a logger with default settings
func NewDefaultLogger() *Logger <span class="cov0" title="0">{
        return NewLogger(LoggerOptions{
                Level:  "info",
                Format: "pretty",
        })
}</span>

// NewVerboseLogger creates a verbose logger
func NewVerboseLogger() *Logger <span class="cov0" title="0">{
        return NewLogger(LoggerOptions{
                Level:   "debug",
                Format:  "pretty",
                Verbose: true,
        })
}</span>

// parseLogLevel parses a log level string
func parseLogLevel(level string) zerolog.Level <span class="cov0" title="0">{
        switch level </span>{
        case "debug":<span class="cov0" title="0">
                return zerolog.DebugLevel</span>
        case "info":<span class="cov0" title="0">
                return zerolog.InfoLevel</span>
        case "warn":<span class="cov0" title="0">
                return zerolog.WarnLevel</span>
        case "error":<span class="cov0" title="0">
                return zerolog.ErrorLevel</span>
        default:<span class="cov0" title="0">
                return zerolog.InfoLevel</span>
        }
}

// WithComponent returns a logger with a component field
func (l *Logger) WithComponent(component string) *Logger <span class="cov0" title="0">{
        return &amp;Logger{
                Logger: l.Logger.With().Str("component", component).Logger(),
        }
}</span>

// WithURL returns a logger with a URL field
func (l *Logger) WithURL(url string) *Logger <span class="cov0" title="0">{
        return &amp;Logger{
                Logger: l.Logger.With().Str("url", url).Logger(),
        }
}</span>

// WithStrategy returns a logger with a strategy field
func (l *Logger) WithStrategy(strategy string) *Logger <span class="cov0" title="0">{
        return &amp;Logger{
                Logger: l.Logger.With().Str("strategy", strategy).Logger(),
        }
}</span>

// SetGlobalLevel sets the global log level
func SetGlobalLevel(level string) <span class="cov0" title="0">{
        zerolog.SetGlobalLevel(parseLogLevel(level))
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">package utils

import (
        "net/url"
        "path"
        "regexp"
        "strings"
)

// NormalizeURL normalizes a URL for consistent handling
func NormalizeURL(rawURL string) (string, error) <span class="cov0" title="0">{
        // If no scheme is present, prepend https:// before parsing
        // This ensures the host is correctly identified
        if !strings.Contains(rawURL, "://") &amp;&amp; !strings.HasPrefix(rawURL, "//") </span><span class="cov0" title="0">{
                rawURL = "https://" + rawURL
        }</span>

        <span class="cov0" title="0">u, err := url.Parse(rawURL)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Ensure scheme
        <span class="cov0" title="0">if u.Scheme == "" </span><span class="cov0" title="0">{
                u.Scheme = "https"
        }</span>

        // Normalize host to lowercase
        <span class="cov0" title="0">u.Host = strings.ToLower(u.Host)

        // Remove default ports
        if (u.Scheme == "http" &amp;&amp; u.Port() == "80") ||
                (u.Scheme == "https" &amp;&amp; u.Port() == "443") </span><span class="cov0" title="0">{
                u.Host = u.Hostname()
        }</span>

        // Clean path
        <span class="cov0" title="0">if u.Path == "" </span><span class="cov0" title="0">{
                u.Path = "/"
        }</span> else<span class="cov0" title="0"> {
                u.Path = path.Clean(u.Path)
        }</span>

        // Remove trailing slash (except for root)
        <span class="cov0" title="0">if u.Path != "/" &amp;&amp; strings.HasSuffix(u.Path, "/") </span><span class="cov0" title="0">{
                u.Path = strings.TrimSuffix(u.Path, "/")
        }</span>

        // Remove fragment
        <span class="cov0" title="0">u.Fragment = ""

        // Build the result manually to ensure trailing slash for root path
        result := u.String()
        
        // Ensure root path has trailing slash
        if u.Path == "/" &amp;&amp; u.RawQuery == "" &amp;&amp; !strings.HasSuffix(result, "/") </span><span class="cov0" title="0">{
                result += "/"
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// NormalizeURLWithoutQuery normalizes a URL and removes query parameters
func NormalizeURLWithoutQuery(rawURL string) (string, error) <span class="cov0" title="0">{
        normalized, err := NormalizeURL(rawURL)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">u, err := url.Parse(normalized)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">u.RawQuery = ""
        return u.String(), nil</span>
}

// ResolveURL resolves a relative URL against a base URL
func ResolveURL(base, ref string) (string, error) <span class="cov0" title="0">{
        baseURL, err := url.Parse(base)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">refURL, err := url.Parse(ref)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">resolved := baseURL.ResolveReference(refURL)
        return resolved.String(), nil</span>
}

// GetDomain extracts the domain from a URL
func GetDomain(rawURL string) string <span class="cov0" title="0">{
        u, err := url.Parse(rawURL)
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return u.Host</span>
}

// GetBaseDomain extracts the base domain (without subdomain) from a URL
func GetBaseDomain(rawURL string) string <span class="cov0" title="0">{
        host := GetDomain(rawURL)
        if host == "" </span><span class="cov0" title="0">{
                return ""
        }</span>

        // Only strip "www." prefix, keep other subdomains
        <span class="cov0" title="0">if strings.HasPrefix(strings.ToLower(host), "www.") </span><span class="cov0" title="0">{
                return host[4:]
        }</span>

        <span class="cov0" title="0">return host</span>
}

// IsSameDomain checks if two URLs have the same domain
func IsSameDomain(url1, url2 string) bool <span class="cov0" title="0">{
        return strings.EqualFold(GetDomain(url1), GetDomain(url2))
}</span>

// IsSameBaseDomain checks if two URLs have the same base domain
func IsSameBaseDomain(url1, url2 string) bool <span class="cov0" title="0">{
        return GetBaseDomain(url1) == GetBaseDomain(url2)
}</span>

// IsAbsoluteURL checks if a URL is absolute
func IsAbsoluteURL(rawURL string) bool <span class="cov0" title="0">{
        // Protocol-relative URLs (starting with //) are considered absolute
        if strings.HasPrefix(rawURL, "//") </span><span class="cov0" title="0">{
                return true
        }</span>
        
        <span class="cov0" title="0">u, err := url.Parse(rawURL)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return u.IsAbs()</span>
}

// IsHTTPURL checks if a URL uses HTTP or HTTPS scheme
func IsHTTPURL(rawURL string) bool <span class="cov0" title="0">{
        u, err := url.Parse(rawURL)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return u.Scheme == "http" || u.Scheme == "https"</span>
}

// IsGitURL checks if a URL is a git repository URL
func IsGitURL(rawURL string) bool <span class="cov0" title="0">{
        return strings.HasPrefix(rawURL, "git@") ||
                strings.HasSuffix(rawURL, ".git") ||
                strings.Contains(rawURL, "github.com") ||
                strings.Contains(rawURL, "gitlab.com") ||
                strings.Contains(rawURL, "bitbucket.org")
}</span>

// IsSitemapURL checks if a URL points to a sitemap
func IsSitemapURL(rawURL string) bool <span class="cov0" title="0">{
        lower := strings.ToLower(rawURL)
        return strings.HasSuffix(lower, "sitemap.xml") ||
                strings.HasSuffix(lower, "sitemap.xml.gz") ||
                strings.Contains(lower, "sitemap")
}</span>

// IsLLMSURL checks if a URL points to an llms.txt file
func IsLLMSURL(rawURL string) bool <span class="cov0" title="0">{
        lower := strings.ToLower(rawURL)
        return strings.HasSuffix(lower, "/llms.txt") ||
                strings.HasSuffix(lower, "llms.txt")
}</span>

// IsPkgGoDevURL checks if a URL is a pkg.go.dev URL
func IsPkgGoDevURL(rawURL string) bool <span class="cov0" title="0">{
        return strings.Contains(rawURL, "pkg.go.dev")
}</span>

// ExtractLinks extracts all href links from HTML content
// This is a simple regex-based extraction, use goquery for more robust parsing
func ExtractLinks(html, baseURL string) []string <span class="cov0" title="0">{
        linkRegex := regexp.MustCompile(`href=["']([^"']+)["']`)
        matches := linkRegex.FindAllStringSubmatch(html, -1)

        links := make([]string, 0, len(matches))
        for _, match := range matches </span><span class="cov0" title="0">{
                if len(match) &gt; 1 </span><span class="cov0" title="0">{
                        link := match[1]
                        // Skip anchors, javascript, mailto, etc.
                        if strings.HasPrefix(link, "#") ||
                                strings.HasPrefix(link, "javascript:") ||
                                strings.HasPrefix(link, "mailto:") ||
                                strings.HasPrefix(link, "tel:") </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // Resolve relative URLs
                        <span class="cov0" title="0">if !IsAbsoluteURL(link) </span><span class="cov0" title="0">{
                                resolved, err := ResolveURL(baseURL, link)
                                if err != nil </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">link = resolved</span>
                        }

                        <span class="cov0" title="0">links = append(links, link)</span>
                }
        }

        <span class="cov0" title="0">return links</span>
}

// GenerateOutputDirFromURL generates an output directory name from a URL
// Examples:
//   - https://github.com/QwenLM/qwen-code -&gt; docs_qwen-code
//   - https://docs.crawl4ai.com/sitemap.xml -&gt; docs_docscrawl4aicom
//   - https://docs.factory.ai/llms.txt -&gt; docs_docsfactoryai
//   - https://pkg.go.dev/github.com/user/package -&gt; docs_package
func GenerateOutputDirFromURL(rawURL string) string <span class="cov0" title="0">{
        u, err := url.Parse(rawURL)
        if err != nil </span><span class="cov0" title="0">{
                return "docs"
        }</span>

        <span class="cov0" title="0">host := strings.ToLower(u.Host)
        pathStr := strings.Trim(u.Path, "/")

        // Remove port if present
        if idx := strings.LastIndex(host, ":"); idx != -1 </span><span class="cov0" title="0">{
                host = host[:idx]
        }</span>

        <span class="cov0" title="0">var name string

        // Handle Git repository URLs (GitHub, GitLab, Bitbucket)
        if strings.Contains(host, "github.com") ||
                strings.Contains(host, "gitlab.com") ||
                strings.Contains(host, "bitbucket.org") </span><span class="cov0" title="0">{
                // Extract repository name from path
                parts := strings.Split(pathStr, "/")
                if len(parts) &gt;= 2 </span><span class="cov0" title="0">{
                        // Use the repo name (second part: owner/repo)
                        name = parts[1]
                        // Remove .git suffix if present
                        name = strings.TrimSuffix(name, ".git")
                }</span> else<span class="cov0" title="0"> if len(parts) == 1 &amp;&amp; parts[0] != "" </span><span class="cov0" title="0">{
                        name = parts[0]
                }</span>
        }

        // Handle pkg.go.dev URLs
        <span class="cov0" title="0">if name == "" &amp;&amp; strings.Contains(host, "pkg.go.dev") </span><span class="cov0" title="0">{
                // Path is like: /github.com/user/package or /package
                parts := strings.Split(pathStr, "/")
                if len(parts) &gt; 0 </span><span class="cov0" title="0">{
                        // Use the last significant part
                        for i := len(parts) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                                if parts[i] != "" &amp;&amp; !strings.Contains(parts[i], ".") </span><span class="cov0" title="0">{
                                        name = parts[i]
                                        break</span>
                                }
                        }
                        // Fallback to last part
                        <span class="cov0" title="0">if name == "" &amp;&amp; len(parts) &gt; 0 </span><span class="cov0" title="0">{
                                name = parts[len(parts)-1]
                        }</span>
                }
        }

        // For other URLs, use sanitized hostname
        <span class="cov0" title="0">if name == "" </span><span class="cov0" title="0">{
                // Remove common prefixes
                host = strings.TrimPrefix(host, "www.")

                // Remove dots and special characters to create a clean name
                name = sanitizeForDirName(host)
        }</span>

        // Ensure we have a valid name
        <span class="cov0" title="0">if name == "" </span><span class="cov0" title="0">{
                return "docs"
        }</span>

        // Sanitize the name for filesystem
        <span class="cov0" title="0">name = sanitizeForDirName(name)

        return "docs_" + name</span>
}

// sanitizeForDirName removes characters that are not safe for directory names
func sanitizeForDirName(s string) string <span class="cov0" title="0">{
        // Remove dots, spaces, and special characters
        var result strings.Builder
        for _, r := range strings.ToLower(s) </span><span class="cov0" title="0">{
                if (r &gt;= 'a' &amp;&amp; r &lt;= 'z') || (r &gt;= '0' &amp;&amp; r &lt;= '9') || r == '-' || r == '_' </span><span class="cov0" title="0">{
                        result.WriteRune(r)
                }</span>
        }
        <span class="cov0" title="0">return result.String()</span>
}

// HasBaseURL checks if a URL starts with the given base URL path
// Example: HasBaseURL("https://example.com/docs/api", "https://example.com/docs") returns true
// Example: HasBaseURL("https://example.com/blog", "https://example.com/docs") returns false
func HasBaseURL(targetURL, baseURL string) bool <span class="cov0" title="0">{
        if baseURL == "" </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">targetParsed, err := url.Parse(targetURL)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">baseParsed, err := url.Parse(baseURL)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Must be same host
        <span class="cov0" title="0">if strings.ToLower(targetParsed.Host) != strings.ToLower(baseParsed.Host) </span><span class="cov0" title="0">{
                return false
        }</span>

        // Normalize paths
        <span class="cov0" title="0">targetPath := strings.TrimSuffix(targetParsed.Path, "/")
        basePath := strings.TrimSuffix(baseParsed.Path, "/")

        // Target path must start with base path
        if basePath == "" || basePath == "/" </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">return targetPath == basePath || strings.HasPrefix(targetPath, basePath+"/")</span>
}

// FilterLinks filters links based on patterns
func FilterLinks(links []string, excludePatterns []string) []string <span class="cov0" title="0">{
        var regexps []*regexp.Regexp
        for _, pattern := range excludePatterns </span><span class="cov0" title="0">{
                re, err := regexp.Compile(pattern)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">regexps = append(regexps, re)</span>
        }

        <span class="cov0" title="0">filtered := make([]string, 0, len(links))
        for _, link := range links </span><span class="cov0" title="0">{
                excluded := false
                for _, re := range regexps </span><span class="cov0" title="0">{
                        if re.MatchString(link) </span><span class="cov0" title="0">{
                                excluded = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !excluded </span><span class="cov0" title="0">{
                        filtered = append(filtered, link)
                }</span>
        }

        <span class="cov0" title="0">return filtered</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package utils

import (
        "context"
        "sync"
)

// Task represents a unit of work
type Task[T any] struct {
        Data   T
        Result any
        Err    error
}

// Worker is a function that processes a task
type Worker[T any] func(ctx context.Context, data T) (any, error)

// Pool is a worker pool for concurrent task processing
type Pool[T any] struct {
        workers    int
        taskQueue  chan *Task[T]
        resultChan chan *Task[T]
        wg         sync.WaitGroup
        worker     Worker[T]
        stopOnce   sync.Once
}

// NewPool creates a new worker pool
func NewPool[T any](workers int, worker Worker[T]) *Pool[T] <span class="cov0" title="0">{
        return &amp;Pool[T]{
                workers:    workers,
                taskQueue:  make(chan *Task[T], workers*2),
                resultChan: make(chan *Task[T], workers*2),
                worker:     worker,
        }
}</span>

// Start starts the worker pool
func (p *Pool[T]) Start(ctx context.Context) <span class="cov0" title="0">{
        for i := 0; i &lt; p.workers; i++ </span><span class="cov0" title="0">{
                p.wg.Add(1)
                go p.runWorker(ctx)
        }</span>
}

// runWorker runs a single worker
func (p *Pool[T]) runWorker(ctx context.Context) <span class="cov0" title="0">{
        defer p.wg.Done()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                case task, ok := &lt;-p.taskQueue:<span class="cov0" title="0">
                        if !ok </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">result, err := p.worker(ctx, task.Data)
                        task.Result = result
                        task.Err = err

                        select </span>{
                        case p.resultChan &lt;- task:<span class="cov0" title="0"></span>
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        }
                }
        }
}

// Submit submits a task to the pool
func (p *Pool[T]) Submit(data T) <span class="cov0" title="0">{
        p.taskQueue &lt;- &amp;Task[T]{Data: data}
}</span>

// Results returns the results channel
func (p *Pool[T]) Results() &lt;-chan *Task[T] <span class="cov0" title="0">{
        return p.resultChan
}</span>

// Stop stops the pool and waits for workers to finish
func (p *Pool[T]) Stop() <span class="cov0" title="0">{
        p.stopOnce.Do(func() </span><span class="cov0" title="0">{
                close(p.taskQueue)
                p.wg.Wait()
                close(p.resultChan)
        }</span>)
}

// Process processes a slice of data items concurrently
func (p *Pool[T]) Process(ctx context.Context, items []T) ([]*Task[T], error) <span class="cov0" title="0">{
        // Handle empty slice case
        if len(items) == 0 </span><span class="cov0" title="0">{
                return []*Task[T]{}, nil
        }</span>

        <span class="cov0" title="0">p.Start(ctx)

        // Submit all items
        go func() </span><span class="cov0" title="0">{
                for _, item := range items </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        default:<span class="cov0" title="0">
                                p.Submit(item)</span>
                        }
                }
                <span class="cov0" title="0">close(p.taskQueue)</span>
        }()

        // Collect results with context awareness
        <span class="cov0" title="0">results := make([]*Task[T], 0, len(items))
        collectDone := false
        for !collectDone </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        collectDone = true</span>
                case task, ok := &lt;-p.resultChan:<span class="cov0" title="0">
                        if !ok </span><span class="cov0" title="0">{
                                collectDone = true
                        }</span> else<span class="cov0" title="0"> {
                                results = append(results, task)
                                if len(results) == len(items) </span><span class="cov0" title="0">{
                                        collectDone = true
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">p.wg.Wait()

        // Drain remaining results to avoid goroutine leak
        go func() </span><span class="cov0" title="0">{
                for range p.resultChan </span>{<span class="cov0" title="0">
                }</span>
        }()
        <span class="cov0" title="0">close(p.resultChan)

        // Check for context error
        if ctx.Err() != nil </span><span class="cov0" title="0">{
                return results, ctx.Err()
        }</span>

        <span class="cov0" title="0">return results, nil</span>
}

// SimplePool is a simpler worker pool without generics for basic use cases
type SimplePool struct {
        workers int
        wg      sync.WaitGroup
}

// NewSimplePool creates a new simple worker pool
func NewSimplePool(workers int) *SimplePool <span class="cov0" title="0">{
        return &amp;SimplePool{workers: workers}
}</span>

// Run runs tasks concurrently with the given function
func (p *SimplePool) Run(ctx context.Context, tasks []func(context.Context) error) []error <span class="cov0" title="0">{
        errors := make([]error, len(tasks))
        taskChan := make(chan int, len(tasks))
        var mu sync.Mutex

        // Start workers
        for i := 0; i &lt; p.workers; i++ </span><span class="cov0" title="0">{
                p.wg.Add(1)
                go func() </span><span class="cov0" title="0">{
                        defer p.wg.Done()
                        for </span><span class="cov0" title="0">{
                                select </span>{
                                case &lt;-ctx.Done():<span class="cov0" title="0">
                                        return</span>
                                case idx, ok := &lt;-taskChan:<span class="cov0" title="0">
                                        if !ok </span><span class="cov0" title="0">{
                                                return
                                        }</span>
                                        <span class="cov0" title="0">err := tasks[idx](ctx)
                                        mu.Lock()
                                        errors[idx] = err
                                        mu.Unlock()</span>
                                }
                        }
                }()
        }

        // Submit tasks
        <span class="cov0" title="0">for i := range tasks </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        close(taskChan)
                        p.wg.Wait()
                        return errors</span>
                case taskChan &lt;- i:<span class="cov0" title="0"></span>
                }
        }

        <span class="cov0" title="0">close(taskChan)
        p.wg.Wait()

        return errors</span>
}

// ParallelForEach executes a function for each item in parallel
func ParallelForEach[T any](ctx context.Context, items []T, workers int, fn func(context.Context, T) error) []error <span class="cov0" title="0">{
        if workers &lt;= 0 </span><span class="cov0" title="0">{
                workers = 1
        }</span>
        <span class="cov0" title="0">if workers &gt; len(items) </span><span class="cov0" title="0">{
                workers = len(items)
        }</span>

        <span class="cov0" title="0">errors := make([]error, len(items))
        taskChan := make(chan int, len(items))
        var wg sync.WaitGroup
        var mu sync.Mutex

        // Start workers
        for i := 0; i &lt; workers; i++ </span><span class="cov0" title="0">{
                wg.Add(1)
                go func() </span><span class="cov0" title="0">{
                        defer wg.Done()
                        for </span><span class="cov0" title="0">{
                                select </span>{
                                case &lt;-ctx.Done():<span class="cov0" title="0">
                                        return</span>
                                case idx, ok := &lt;-taskChan:<span class="cov0" title="0">
                                        if !ok </span><span class="cov0" title="0">{
                                                return
                                        }</span>
                                        <span class="cov0" title="0">err := fn(ctx, items[idx])
                                        mu.Lock()
                                        errors[idx] = err
                                        mu.Unlock()</span>
                                }
                        }
                }()
        }

        // Submit tasks
        <span class="cov0" title="0">for i := range items </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        close(taskChan)
                        wg.Wait()
                        return errors</span>
                case taskChan &lt;- i:<span class="cov0" title="0"></span>
                }
        }

        <span class="cov0" title="0">close(taskChan)
        wg.Wait()

        return errors</span>
}

// FirstError returns the first non-nil error from a slice of errors
func FirstError(errors []error) error <span class="cov0" title="0">{
        for _, err := range errors </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// CollectErrors collects all non-nil errors from a slice
func CollectErrors(errors []error) []error <span class="cov0" title="0">{
        var result []error
        for _, err := range errors </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        result = append(result, err)
                }</span>
        }
        <span class="cov0" title="0">return result</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package version

import (
        "fmt"
        "runtime"
)

// Build-time variables (set via ldflags)
var (
        Version   = "dev"
        BuildTime = "unknown"
        Commit    = "unknown"
)

// Info contains version information
type Info struct {
        Version   string `json:"version"`
        BuildTime string `json:"build_time"`
        Commit    string `json:"commit"`
        GoVersion string `json:"go_version"`
        OS        string `json:"os"`
        Arch      string `json:"arch"`
}

// Get returns the current version info
func Get() Info <span class="cov0" title="0">{
        return Info{
                Version:   Version,
                BuildTime: BuildTime,
                Commit:    Commit,
                GoVersion: runtime.Version(),
                OS:        runtime.GOOS,
                Arch:      runtime.GOARCH,
        }
}</span>

// String returns a formatted version string
func (i Info) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("repodocs %s (commit: %s, built: %s, %s %s/%s)",
                i.Version, i.Commit, i.BuildTime, i.GoVersion, i.OS, i.Arch)
}</span>

// Short returns a short version string
func Short() string <span class="cov0" title="0">{
        return Version
}</span>

// Full returns a full version string
func Full() string <span class="cov0" title="0">{
        return Get().String()
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: internal/domain/interfaces.go
//
// Generated by this command:
//
//        mockgen -source=internal/domain/interfaces.go -destination=tests/mocks/domain.go -package mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        http "net/http"
        reflect "reflect"
        time "time"

        domain "github.com/quantmind-br/repodocs-go/internal/domain"
        gomock "go.uber.org/mock/gomock"
)

// MockStrategy is a mock of Strategy interface.
type MockStrategy struct {
        ctrl     *gomock.Controller
        recorder *MockStrategyMockRecorder
        isgomock struct{}
}

// MockStrategyMockRecorder is the mock recorder for MockStrategy.
type MockStrategyMockRecorder struct {
        mock *MockStrategy
}

// NewMockStrategy creates a new mock instance.
func NewMockStrategy(ctrl *gomock.Controller) *MockStrategy <span class="cov0" title="0">{
        mock := &amp;MockStrategy{ctrl: ctrl}
        mock.recorder = &amp;MockStrategyMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockStrategy) EXPECT() *MockStrategyMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// CanHandle mocks base method.
func (m *MockStrategy) CanHandle(url string) bool <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CanHandle", url)
        ret0, _ := ret[0].(bool)
        return ret0
}</span>

// CanHandle indicates an expected call of CanHandle.
func (mr *MockStrategyMockRecorder) CanHandle(url any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CanHandle", reflect.TypeOf((*MockStrategy)(nil).CanHandle), url)
}</span>

// Execute mocks base method.
func (m *MockStrategy) Execute(ctx context.Context, url string, opts domain.StrategyOptions) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Execute", ctx, url, opts)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Execute indicates an expected call of Execute.
func (mr *MockStrategyMockRecorder) Execute(ctx, url, opts any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockStrategy)(nil).Execute), ctx, url, opts)
}</span>

// Name mocks base method.
func (m *MockStrategy) Name() string <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Name")
        ret0, _ := ret[0].(string)
        return ret0
}</span>

// Name indicates an expected call of Name.
func (mr *MockStrategyMockRecorder) Name() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Name", reflect.TypeOf((*MockStrategy)(nil).Name))
}</span>

// MockFetcher is a mock of Fetcher interface.
type MockFetcher struct {
        ctrl     *gomock.Controller
        recorder *MockFetcherMockRecorder
        isgomock struct{}
}

// MockFetcherMockRecorder is the mock recorder for MockFetcher.
type MockFetcherMockRecorder struct {
        mock *MockFetcher
}

// NewMockFetcher creates a new mock instance.
func NewMockFetcher(ctrl *gomock.Controller) *MockFetcher <span class="cov0" title="0">{
        mock := &amp;MockFetcher{ctrl: ctrl}
        mock.recorder = &amp;MockFetcherMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockFetcher) EXPECT() *MockFetcherMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Close mocks base method.
func (m *MockFetcher) Close() error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Close")
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Close indicates an expected call of Close.
func (mr *MockFetcherMockRecorder) Close() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockFetcher)(nil).Close))
}</span>

// Get mocks base method.
func (m *MockFetcher) Get(ctx context.Context, url string) (*domain.Response, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Get", ctx, url)
        ret0, _ := ret[0].(*domain.Response)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Get indicates an expected call of Get.
func (mr *MockFetcherMockRecorder) Get(ctx, url any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockFetcher)(nil).Get), ctx, url)
}</span>

// GetCookies mocks base method.
func (m *MockFetcher) GetCookies(url string) []*http.Cookie <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetCookies", url)
        ret0, _ := ret[0].([]*http.Cookie)
        return ret0
}</span>

// GetCookies indicates an expected call of GetCookies.
func (mr *MockFetcherMockRecorder) GetCookies(url any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCookies", reflect.TypeOf((*MockFetcher)(nil).GetCookies), url)
}</span>

// GetWithHeaders mocks base method.
func (m *MockFetcher) GetWithHeaders(ctx context.Context, url string, headers map[string]string) (*domain.Response, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetWithHeaders", ctx, url, headers)
        ret0, _ := ret[0].(*domain.Response)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetWithHeaders indicates an expected call of GetWithHeaders.
func (mr *MockFetcherMockRecorder) GetWithHeaders(ctx, url, headers any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetWithHeaders", reflect.TypeOf((*MockFetcher)(nil).GetWithHeaders), ctx, url, headers)
}</span>

// MockRenderer is a mock of Renderer interface.
type MockRenderer struct {
        ctrl     *gomock.Controller
        recorder *MockRendererMockRecorder
        isgomock struct{}
}

// MockRendererMockRecorder is the mock recorder for MockRenderer.
type MockRendererMockRecorder struct {
        mock *MockRenderer
}

// NewMockRenderer creates a new mock instance.
func NewMockRenderer(ctrl *gomock.Controller) *MockRenderer <span class="cov0" title="0">{
        mock := &amp;MockRenderer{ctrl: ctrl}
        mock.recorder = &amp;MockRendererMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRenderer) EXPECT() *MockRendererMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Close mocks base method.
func (m *MockRenderer) Close() error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Close")
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Close indicates an expected call of Close.
func (mr *MockRendererMockRecorder) Close() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockRenderer)(nil).Close))
}</span>

// Render mocks base method.
func (m *MockRenderer) Render(ctx context.Context, url string, opts domain.RenderOptions) (string, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Render", ctx, url, opts)
        ret0, _ := ret[0].(string)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Render indicates an expected call of Render.
func (mr *MockRendererMockRecorder) Render(ctx, url, opts any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Render", reflect.TypeOf((*MockRenderer)(nil).Render), ctx, url, opts)
}</span>

// MockCache is a mock of Cache interface.
type MockCache struct {
        ctrl     *gomock.Controller
        recorder *MockCacheMockRecorder
        isgomock struct{}
}

// MockCacheMockRecorder is the mock recorder for MockCache.
type MockCacheMockRecorder struct {
        mock *MockCache
}

// NewMockCache creates a new mock instance.
func NewMockCache(ctrl *gomock.Controller) *MockCache <span class="cov0" title="0">{
        mock := &amp;MockCache{ctrl: ctrl}
        mock.recorder = &amp;MockCacheMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCache) EXPECT() *MockCacheMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Close mocks base method.
func (m *MockCache) Close() error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Close")
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Close indicates an expected call of Close.
func (mr *MockCacheMockRecorder) Close() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockCache)(nil).Close))
}</span>

// Delete mocks base method.
func (m *MockCache) Delete(ctx context.Context, key string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Delete", ctx, key)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Delete indicates an expected call of Delete.
func (mr *MockCacheMockRecorder) Delete(ctx, key any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockCache)(nil).Delete), ctx, key)
}</span>

// Get mocks base method.
func (m *MockCache) Get(ctx context.Context, key string) ([]byte, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Get", ctx, key)
        ret0, _ := ret[0].([]byte)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Get indicates an expected call of Get.
func (mr *MockCacheMockRecorder) Get(ctx, key any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockCache)(nil).Get), ctx, key)
}</span>

// Has mocks base method.
func (m *MockCache) Has(ctx context.Context, key string) bool <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Has", ctx, key)
        ret0, _ := ret[0].(bool)
        return ret0
}</span>

// Has indicates an expected call of Has.
func (mr *MockCacheMockRecorder) Has(ctx, key any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Has", reflect.TypeOf((*MockCache)(nil).Has), ctx, key)
}</span>

// Set mocks base method.
func (m *MockCache) Set(ctx context.Context, key string, value []byte, ttl time.Duration) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Set", ctx, key, value, ttl)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Set indicates an expected call of Set.
func (mr *MockCacheMockRecorder) Set(ctx, key, value, ttl any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Set", reflect.TypeOf((*MockCache)(nil).Set), ctx, key, value, ttl)
}</span>

// MockConverter is a mock of Converter interface.
type MockConverter struct {
        ctrl     *gomock.Controller
        recorder *MockConverterMockRecorder
        isgomock struct{}
}

// MockConverterMockRecorder is the mock recorder for MockConverter.
type MockConverterMockRecorder struct {
        mock *MockConverter
}

// NewMockConverter creates a new mock instance.
func NewMockConverter(ctrl *gomock.Controller) *MockConverter <span class="cov0" title="0">{
        mock := &amp;MockConverter{ctrl: ctrl}
        mock.recorder = &amp;MockConverterMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockConverter) EXPECT() *MockConverterMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Convert mocks base method.
func (m *MockConverter) Convert(ctx context.Context, html, sourceURL string) (*domain.Document, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Convert", ctx, html, sourceURL)
        ret0, _ := ret[0].(*domain.Document)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Convert indicates an expected call of Convert.
func (mr *MockConverterMockRecorder) Convert(ctx, html, sourceURL any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Convert", reflect.TypeOf((*MockConverter)(nil).Convert), ctx, html, sourceURL)
}</span>

// MockWriter is a mock of Writer interface.
type MockWriter struct {
        ctrl     *gomock.Controller
        recorder *MockWriterMockRecorder
        isgomock struct{}
}

// MockWriterMockRecorder is the mock recorder for MockWriter.
type MockWriterMockRecorder struct {
        mock *MockWriter
}

// NewMockWriter creates a new mock instance.
func NewMockWriter(ctrl *gomock.Controller) *MockWriter <span class="cov0" title="0">{
        mock := &amp;MockWriter{ctrl: ctrl}
        mock.recorder = &amp;MockWriterMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockWriter) EXPECT() *MockWriterMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Write mocks base method.
func (m *MockWriter) Write(ctx context.Context, doc *domain.Document) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Write", ctx, doc)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Write indicates an expected call of Write.
func (mr *MockWriterMockRecorder) Write(ctx, doc any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Write", reflect.TypeOf((*MockWriter)(nil).Write), ctx, doc)
}</span>

// SimpleMockCache is a simple in-memory cache for testing without gomock
type SimpleMockCache struct {
        data map[string][]byte
}

// NewSimpleMockCache creates a new SimpleMockCache
func NewSimpleMockCache() *SimpleMockCache <span class="cov0" title="0">{
        return &amp;SimpleMockCache{
                data: make(map[string][]byte),
        }
}</span>

// Get retrieves a value from the cache
func (m *SimpleMockCache) Get(ctx context.Context, key string) ([]byte, error) <span class="cov0" title="0">{
        value, ok := m.data[key]
        if !ok </span><span class="cov0" title="0">{
                return nil, domain.ErrCacheMiss
        }</span>
        <span class="cov0" title="0">return value, nil</span>
}

// Set stores a value in the cache
func (m *SimpleMockCache) Set(ctx context.Context, key string, value []byte, ttl time.Duration) error <span class="cov0" title="0">{
        m.data[key] = value
        return nil
}</span>

// Has checks if a key exists in the cache
func (m *SimpleMockCache) Has(ctx context.Context, key string) bool <span class="cov0" title="0">{
        _, ok := m.data[key]
        return ok
}</span>

// Delete removes a key from the cache
func (m *SimpleMockCache) Delete(ctx context.Context, key string) error <span class="cov0" title="0">{
        delete(m.data, key)
        return nil
}</span>

// Close releases cache resources
func (m *SimpleMockCache) Close() error <span class="cov0" title="0">{
        m.data = nil
        return nil
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">package testutil

import (
        "os"
        "path/filepath"
        "testing"

        "github.com/quantmind-br/repodocs-go/internal/domain"
        "github.com/stretchr/testify/assert"
        "github.com/stretchr/testify/require"
)

// AssertDocumentContent asserts document has expected content
func AssertDocumentContent(t *testing.T, doc *domain.Document, expectedURL, expectedTitle, expectedContent string) <span class="cov0" title="0">{
        t.Helper()

        require.NotNil(t, doc)
        assert.Equal(t, expectedURL, doc.URL)
        assert.Equal(t, expectedTitle, doc.Title)
        assert.Equal(t, expectedContent, doc.Content)
}</span>

// AssertDocumentMarkdown asserts document has expected markdown content
func AssertDocumentMarkdown(t *testing.T, doc *domain.Document, expectedMarkdown string) <span class="cov0" title="0">{
        t.Helper()

        require.NotNil(t, doc)
        assert.Equal(t, expectedMarkdown, doc.Content)
}</span>

// AssertDocumentMetadata asserts document has expected metadata
func AssertDocumentMetadata(t *testing.T, doc *domain.Document, expectedDescription string, expectedWordCount int) <span class="cov0" title="0">{
        t.Helper()

        require.NotNil(t, doc)
        assert.Equal(t, expectedDescription, doc.Description)
        assert.Equal(t, expectedWordCount, doc.WordCount)
}</span>

// AssertDocumentHasHeaders asserts document has expected headers map
func AssertDocumentHasHeaders(t *testing.T, doc *domain.Document, expectedHeaders map[string][]string) <span class="cov0" title="0">{
        t.Helper()

        require.NotNil(t, doc)
        assert.Equal(t, expectedHeaders, doc.Headers)
}</span>

// AssertDocumentHasHeaderLevel asserts document has expected headers for a specific level
func AssertDocumentHasHeaderLevel(t *testing.T, doc *domain.Document, level string, expectedValues []string) <span class="cov0" title="0">{
        t.Helper()

        require.NotNil(t, doc)
        headers, ok := doc.Headers[level]
        require.True(t, ok, "Headers should contain level %s", level)
        assert.Equal(t, expectedValues, headers)
}</span>

// AssertDocumentHasLinks asserts document has expected links
func AssertDocumentHasLinks(t *testing.T, doc *domain.Document, expectedLinks []string) <span class="cov0" title="0">{
        t.Helper()

        require.NotNil(t, doc)
        assert.Equal(t, expectedLinks, doc.Links)
}</span>

// AssertFileExists asserts a file exists at the given path
func AssertFileExists(t *testing.T, path string) <span class="cov0" title="0">{
        t.Helper()

        assert.True(t, fileExists(path), "File should exist at %s", path)
}</span>

// AssertFileNotExists asserts a file does not exist at the given path
func AssertFileNotExists(t *testing.T, path string) <span class="cov0" title="0">{
        t.Helper()

        assert.False(t, fileExists(path), "File should not exist at %s", path)
}</span>

// AssertFileContains asserts a file contains expected content
func AssertFileContains(t *testing.T, path, expectedContent string) <span class="cov0" title="0">{
        t.Helper()

        content, err := os.ReadFile(path)
        require.NoError(t, err)
        assert.Contains(t, string(content), expectedContent)
}</span>

// AssertFileEquals asserts a file equals expected content
func AssertFileEquals(t *testing.T, path, expectedContent string) <span class="cov0" title="0">{
        t.Helper()

        content, err := os.ReadFile(path)
        require.NoError(t, err)
        assert.Equal(t, expectedContent, string(content))
}</span>

// AssertDirExists asserts a directory exists
func AssertDirExists(t *testing.T, path string) <span class="cov0" title="0">{
        t.Helper()

        info, err := os.Stat(path)
        require.NoError(t, err)
        assert.True(t, info.IsDir(), "Path should be a directory: %s", path)
}</span>

// AssertFilesInDir asserts expected number of files exist in directory
func AssertFilesInDir(t *testing.T, dirPath string, expectedCount int, pattern string) <span class="cov0" title="0">{
        t.Helper()

        if pattern == "" </span><span class="cov0" title="0">{
                pattern = "*"
        }</span>

        <span class="cov0" title="0">files, err := filepath.Glob(filepath.Join(dirPath, pattern))
        require.NoError(t, err)
        assert.Equal(t, expectedCount, len(files), "Expected %d files in %s, got %d", expectedCount, dirPath, len(files))</span>
}

// AssertMarkdownFileWithFrontmatter asserts a markdown file has proper frontmatter
func AssertMarkdownFileWithFrontmatter(t *testing.T, path, expectedTitle string) <span class="cov0" title="0">{
        t.Helper()

        content, err := os.ReadFile(path)
        require.NoError(t, err)

        contentStr := string(content)
        assert.Contains(t, contentStr, "---")
        assert.Contains(t, contentStr, "title:")
        assert.Contains(t, contentStr, expectedTitle)
}</span>

// fileExists is a helper to check if a file exists
func fileExists(path string) bool <span class="cov0" title="0">{
        _, err := os.Stat(path)
        return err == nil
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">package testutil

import (
        "context"
        "testing"
        "time"

        "github.com/quantmind-br/repodocs-go/internal/cache"
        "github.com/quantmind-br/repodocs-go/internal/domain"
        "github.com/stretchr/testify/require"
)

// NewBadgerCache creates an in-memory BadgerDB cache for testing
func NewBadgerCache(t *testing.T) domain.Cache <span class="cov0" title="0">{
        t.Helper()

        c, err := cache.NewBadgerCache(cache.Options{
                InMemory: true,
                Logger:   false,
        })
        require.NoError(t, err)

        t.Cleanup(func() </span><span class="cov0" title="0">{
                c.Close()
        }</span>)

        <span class="cov0" title="0">return c</span>
}

// CreateTestCacheEntry creates a test cache entry with expiration
func CreateTestCacheEntry(t *testing.T, url, content string, ttlSeconds int) *domain.CacheEntry <span class="cov0" title="0">{
        t.Helper()

        return &amp;domain.CacheEntry{
                URL:         url,
                Content:     []byte(content),
                ContentType: "text/html",
                FetchedAt:   time.Now(),
                ExpiresAt:   time.Now().Add(time.Duration(ttlSeconds) * time.Second),
        }
}</span>

// CreateTestCacheEntryExpired creates an expired cache entry
func CreateTestCacheEntryExpired(t *testing.T, url, content string) *domain.CacheEntry <span class="cov0" title="0">{
        t.Helper()

        return &amp;domain.CacheEntry{
                URL:         url,
                Content:     []byte(content),
                ContentType: "text/html",
                FetchedAt:   time.Now().Add(-24 * time.Hour),
                ExpiresAt:   time.Now().Add(-1 * time.Hour),
        }
}</span>

// VerifyCacheEntry verifies a cache entry was stored correctly
func VerifyCacheEntry(t *testing.T, cache domain.Cache, key, expectedValue string) <span class="cov0" title="0">{
        t.Helper()

        result, err := cache.Get(context.Background(), key)
        require.NoError(t, err)
        require.Equal(t, expectedValue, string(result))
}</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">package testutil

import (
        "strings"
        "testing"
        "time"

        "github.com/quantmind-br/repodocs-go/internal/domain"
        "github.com/stretchr/testify/require"
)

// NewDocument creates a test document
func NewDocument(t *testing.T) *domain.Document <span class="cov0" title="0">{
        t.Helper()

        return &amp;domain.Document{
                URL:            "https://example.com/test",
                Title:          "Test Document",
                Description:    "Test description",
                Content:        "This is test content",
                HTMLContent:    "&lt;p&gt;This is test content&lt;/p&gt;",
                FetchedAt:      time.Now(),
                ContentHash:    "abc123",
                WordCount:      5,
                CharCount:      25,
                Links:          []string{"https://example.com/link1", "https://example.com/link2"},
                Headers:        map[string][]string{"h1": {"Test Document"}, "h2": {"Section 1"}},
                RenderedWithJS: false,
                SourceStrategy: "crawler",
                CacheHit:       false,
        }
}</span>

// NewHTMLDocument creates a test document with HTML content
func NewHTMLDocument(t *testing.T, url, title, htmlContent string) *domain.Document <span class="cov0" title="0">{
        t.Helper()

        return &amp;domain.Document{
                URL:            url,
                Title:          title,
                Description:    "",
                Content:        htmlContent,
                HTMLContent:    htmlContent,
                FetchedAt:      time.Now(),
                ContentHash:    "",
                WordCount:      0,
                CharCount:      len(htmlContent),
                Links:          []string{},
                Headers:        map[string][]string{},
                RenderedWithJS: false,
                SourceStrategy: "crawler",
                CacheHit:       false,
        }
}</span>

// NewMarkdownDocument creates a test document with Markdown content
func NewMarkdownDocument(t *testing.T, url, title, markdown string) *domain.Document <span class="cov0" title="0">{
        t.Helper()

        return &amp;domain.Document{
                URL:            url,
                Title:          title,
                Description:    "",
                Content:        markdown,
                HTMLContent:    "",
                FetchedAt:      time.Now(),
                ContentHash:    "",
                WordCount:      len(strings.Fields(markdown)),
                CharCount:      len(markdown),
                Links:          []string{},
                Headers:        map[string][]string{},
                RenderedWithJS: false,
                SourceStrategy: "git",
                CacheHit:       false,
        }
}</span>

// NewEmptyDocument creates an empty test document
func NewEmptyDocument(t *testing.T) *domain.Document <span class="cov0" title="0">{
        t.Helper()

        return &amp;domain.Document{
                URL:            "",
                Title:          "",
                Description:    "",
                Content:        "",
                HTMLContent:    "",
                FetchedAt:      time.Now(),
                ContentHash:    "",
                WordCount:      0,
                CharCount:      0,
                Links:          []string{},
                Headers:        map[string][]string{},
                RenderedWithJS: false,
                SourceStrategy: "",
                CacheHit:       false,
        }
}</span>

// VerifyDocumentFields verifies common document fields
func VerifyDocumentFields(t *testing.T, doc *domain.Document, expectedURL, expectedTitle string) <span class="cov0" title="0">{
        t.Helper()

        require.NotNil(t, doc)
        require.Equal(t, expectedURL, doc.URL)
        require.Equal(t, expectedTitle, doc.Title)
        require.NotNil(t, doc.Headers)
        require.NotNil(t, doc.Links)
        require.False(t, doc.FetchedAt.IsZero())
}</span>

// CloneDocument creates a copy of a document for testing
func CloneDocument(t *testing.T, doc *domain.Document) *domain.Document <span class="cov0" title="0">{
        t.Helper()

        headersCopy := make(map[string][]string)
        for k, v := range doc.Headers </span><span class="cov0" title="0">{
                headersCopy[k] = append([]string(nil), v...)
        }</span>

        <span class="cov0" title="0">return &amp;domain.Document{
                URL:            doc.URL,
                Title:          doc.Title,
                Description:    doc.Description,
                Content:        doc.Content,
                HTMLContent:    doc.HTMLContent,
                FetchedAt:      doc.FetchedAt,
                ContentHash:    doc.ContentHash,
                WordCount:      doc.WordCount,
                CharCount:      doc.CharCount,
                Links:          append([]string(nil), doc.Links...),
                Headers:        headersCopy,
                RenderedWithJS: doc.RenderedWithJS,
                SourceStrategy: doc.SourceStrategy,
                CacheHit:       doc.CacheHit,
                RelativePath:   doc.RelativePath,
        }</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package testutil

import (
        "encoding/json"
        "io"
        "net/http"
        "net/http/httptest"
        "strings"
        "testing"

        "github.com/quantmind-br/repodocs-go/internal/domain"
        "github.com/stretchr/testify/require"
)

// TestServer is a wrapper around httptest.Server for testing
type TestServer struct {
        *httptest.Server
        mux *http.ServeMux
}

// NewTestServer creates a new test HTTP server
func NewTestServer(t *testing.T) *TestServer <span class="cov0" title="0">{
        t.Helper()

        mux := http.NewServeMux()
        server := httptest.NewServer(mux)

        t.Cleanup(func() </span><span class="cov0" title="0">{
                server.Close()
        }</span>)

        <span class="cov0" title="0">return &amp;TestServer{
                Server: server,
                mux:    mux,
        }</span>
}

// Handle registers a handler for a specific path
func (ts *TestServer) Handle(t *testing.T, path string, handler http.HandlerFunc) <span class="cov0" title="0">{
        t.Helper()
        ts.mux.HandleFunc(path, handler)
}</span>

// HandleString registers a handler that returns a string response
func (ts *TestServer) HandleString(t *testing.T, path, contentType, body string) <span class="cov0" title="0">{
        t.Helper()
        ts.mux.HandleFunc(path, func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", contentType)
                w.WriteHeader(http.StatusOK)
                w.Write([]byte(body))
        }</span>)
}

// HandleHTML registers a handler that returns HTML content
func (ts *TestServer) HandleHTML(t *testing.T, path, htmlBody string) <span class="cov0" title="0">{
        t.Helper()
        ts.HandleString(t, path, "text/html; charset=utf-8", htmlBody)
}</span>

// HandleJSON registers a handler that returns JSON content
func (ts *TestServer) HandleJSON(t *testing.T, path string, data interface{}) <span class="cov0" title="0">{
        t.Helper()
        ts.mux.HandleFunc(path, func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
                w.WriteHeader(http.StatusOK)
                json.NewEncoder(w).Encode(data)
        }</span>)
}

// Handle404 registers a handler that returns 404 Not Found
func (ts *TestServer) Handle404(t *testing.T, path string) <span class="cov0" title="0">{
        t.Helper()
        ts.mux.HandleFunc(path, func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusNotFound)
                w.Write([]byte("Not Found"))
        }</span>)
}

// Handle500 registers a handler that returns 500 Internal Server Error
func (ts *TestServer) Handle500(t *testing.T, path string) <span class="cov0" title="0">{
        t.Helper()
        ts.mux.HandleFunc(path, func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusInternalServerError)
                w.Write([]byte("Internal Server Error"))
        }</span>)
}

// NewResponse creates a mock domain.Response
func NewResponse(statusCode int, body string, contentType string) *domain.Response <span class="cov0" title="0">{
        return &amp;domain.Response{
                StatusCode:  statusCode,
                Body:        []byte(body),
                Headers:     make(http.Header),
                ContentType: contentType,
                URL:         "",
                FromCache:   false,
        }
}</span>

// CreateHTTPResponse creates an http.Response from domain.Response
func CreateHTTPResponse(t *testing.T, resp *domain.Response) *http.Response <span class="cov0" title="0">{
        t.Helper()

        return &amp;http.Response{
                StatusCode: resp.StatusCode,
                Body:       io.NopCloser(strings.NewReader(string(resp.Body))),
                Header:     resp.Headers,
        }
}</span>

// VerifyRequest verifies an HTTP request matches expected values
func VerifyRequest(t *testing.T, req *http.Request, method, path string) <span class="cov0" title="0">{
        t.Helper()
        require.Equal(t, method, req.Method)
        require.Equal(t, path, req.URL.Path)
}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">package testutil

import (
        "io"
        "testing"

        "github.com/rs/zerolog"
)

// NewTestLogger creates a test logger that writes to testing.T
func NewTestLogger(t *testing.T) *zerolog.Logger <span class="cov0" title="0">{
        t.Helper()

        // Create a logger that writes to the test output
        logger := zerolog.New(io.Discard).With().
                Timestamp().
                Str("test", t.Name()).
                Logger()

        return &amp;logger
}</span>

// NewNoOpLogger creates a logger that discards all output
func NewNoOpLogger() *zerolog.Logger <span class="cov0" title="0">{
        logger := zerolog.New(io.Discard)
        return &amp;logger
}</span>

// NewVerboseLogger creates a logger that writes to both test output and discards
func NewVerboseLogger(t *testing.T) *zerolog.Logger <span class="cov0" title="0">{
        t.Helper()

        // For verbose testing, we can add more detailed logging
        // Currently using no-op but can be enhanced to write to t.Log
        logger := zerolog.New(io.Discard).With().
                Timestamp().
                Str("test", t.Name()).
                Logger()

        return &amp;logger
}</span>
</pre>
		
		<pre class="file" id="file42" style="display: none">package testutil

import (
        "os"
        "path/filepath"
        "testing"

        "github.com/stretchr/testify/require"
)

// TempDir creates a temporary directory for testing
func TempDir(t *testing.T) string <span class="cov0" title="0">{
        t.Helper()

        tmpDir, err := os.MkdirTemp("", "repodocs-test-*")
        require.NoError(t, err)

        t.Cleanup(func() </span><span class="cov0" title="0">{
                os.RemoveAll(tmpDir)
        }</span>)

        <span class="cov0" title="0">return tmpDir</span>
}

// TempSubDir creates a temporary subdirectory within a base directory
func TempSubDir(t *testing.T, baseDir string) string <span class="cov0" title="0">{
        t.Helper()

        subDir, err := os.MkdirTemp(baseDir, "sub-*")
        require.NoError(t, err)

        t.Cleanup(func() </span><span class="cov0" title="0">{
                os.RemoveAll(subDir)
        }</span>)

        <span class="cov0" title="0">return subDir</span>
}

// CreateTempFile creates a temporary file with content
func CreateTempFile(t *testing.T, dir, filename, content string) string <span class="cov0" title="0">{
        t.Helper()

        tmpFile, err := os.CreateTemp(dir, filename)
        require.NoError(t, err)
        defer tmpFile.Close()

        _, err = tmpFile.WriteString(content)
        require.NoError(t, err)

        return tmpFile.Name()
}</span>

// EnsureDir creates a directory if it doesn't exist
func EnsureDir(t *testing.T, path string) string <span class="cov0" title="0">{
        t.Helper()

        err := os.MkdirAll(path, 0755)
        require.NoError(t, err)

        t.Cleanup(func() </span><span class="cov0" title="0">{
                os.RemoveAll(path)
        }</span>)

        <span class="cov0" title="0">return path</span>
}

// TempOutputDir creates a temporary directory structure for output testing
func TempOutputDir(t *testing.T) (baseDir, docsDir string) <span class="cov0" title="0">{
        t.Helper()

        baseDir = TempDir(t)
        docsDir = filepath.Join(baseDir, "docs")

        err := os.MkdirAll(docsDir, 0755)
        require.NoError(t, err)

        return baseDir, docsDir
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
