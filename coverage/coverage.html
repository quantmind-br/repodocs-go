
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>app: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/quantmind-br/repodocs-go/internal/app/detector.go (87.5%)</option>
				
				<option value="file1">github.com/quantmind-br/repodocs-go/internal/app/orchestrator.go (90.2%)</option>
				
				<option value="file2">github.com/quantmind-br/repodocs-go/internal/cache/badger.go (87.3%)</option>
				
				<option value="file3">github.com/quantmind-br/repodocs-go/internal/cache/interface.go (83.3%)</option>
				
				<option value="file4">github.com/quantmind-br/repodocs-go/internal/cache/keys.go (87.0%)</option>
				
				<option value="file5">github.com/quantmind-br/repodocs-go/internal/config/config.go (100.0%)</option>
				
				<option value="file6">github.com/quantmind-br/repodocs-go/internal/config/defaults.go (71.4%)</option>
				
				<option value="file7">github.com/quantmind-br/repodocs-go/internal/config/loader.go (88.1%)</option>
				
				<option value="file8">github.com/quantmind-br/repodocs-go/internal/converter/encoding.go (94.1%)</option>
				
				<option value="file9">github.com/quantmind-br/repodocs-go/internal/converter/markdown.go (90.7%)</option>
				
				<option value="file10">github.com/quantmind-br/repodocs-go/internal/converter/pipeline.go (85.7%)</option>
				
				<option value="file11">github.com/quantmind-br/repodocs-go/internal/converter/readability.go (73.1%)</option>
				
				<option value="file12">github.com/quantmind-br/repodocs-go/internal/converter/sanitizer.go (93.0%)</option>
				
				<option value="file13">github.com/quantmind-br/repodocs-go/internal/domain/errors.go (100.0%)</option>
				
				<option value="file14">github.com/quantmind-br/repodocs-go/internal/domain/models.go (100.0%)</option>
				
				<option value="file15">github.com/quantmind-br/repodocs-go/internal/fetcher/client.go (79.7%)</option>
				
				<option value="file16">github.com/quantmind-br/repodocs-go/internal/fetcher/retry.go (96.8%)</option>
				
				<option value="file17">github.com/quantmind-br/repodocs-go/internal/fetcher/stealth.go (81.0%)</option>
				
				<option value="file18">github.com/quantmind-br/repodocs-go/internal/fetcher/transport.go (90.0%)</option>
				
				<option value="file19">github.com/quantmind-br/repodocs-go/internal/output/writer.go (86.3%)</option>
				
				<option value="file20">github.com/quantmind-br/repodocs-go/internal/renderer/detector.go (100.0%)</option>
				
				<option value="file21">github.com/quantmind-br/repodocs-go/internal/renderer/pool.go (75.0%)</option>
				
				<option value="file22">github.com/quantmind-br/repodocs-go/internal/renderer/rod.go (77.1%)</option>
				
				<option value="file23">github.com/quantmind-br/repodocs-go/internal/renderer/stealth.go (81.8%)</option>
				
				<option value="file24">github.com/quantmind-br/repodocs-go/internal/strategies/crawler.go (61.0%)</option>
				
				<option value="file25">github.com/quantmind-br/repodocs-go/internal/strategies/git.go (1.7%)</option>
				
				<option value="file26">github.com/quantmind-br/repodocs-go/internal/strategies/llms.go (62.5%)</option>
				
				<option value="file27">github.com/quantmind-br/repodocs-go/internal/strategies/pkggo.go (80.0%)</option>
				
				<option value="file28">github.com/quantmind-br/repodocs-go/internal/strategies/sitemap.go (58.9%)</option>
				
				<option value="file29">github.com/quantmind-br/repodocs-go/internal/strategies/strategy.go (85.2%)</option>
				
				<option value="file30">github.com/quantmind-br/repodocs-go/internal/utils/fs.go (78.9%)</option>
				
				<option value="file31">github.com/quantmind-br/repodocs-go/internal/utils/logger.go (100.0%)</option>
				
				<option value="file32">github.com/quantmind-br/repodocs-go/internal/utils/url.go (89.7%)</option>
				
				<option value="file33">github.com/quantmind-br/repodocs-go/internal/utils/workerpool.go (91.8%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package app

import (
        "strings"

        "github.com/quantmind-br/repodocs-go/internal/strategies"
)

// StrategyType represents the type of extraction strategy
type StrategyType string

const (
        StrategyLLMS    StrategyType = "llms"
        StrategySitemap StrategyType = "sitemap"
        StrategyGit     StrategyType = "git"
        StrategyPkgGo   StrategyType = "pkggo"
        StrategyCrawler StrategyType = "crawler"
        StrategyUnknown StrategyType = "unknown"
)

// DetectStrategy determines the appropriate strategy based on URL patterns
func DetectStrategy(url string) StrategyType <span class="cov8" title="1">{
        lower := strings.ToLower(url)

        // Check for llms.txt first
        if strings.HasSuffix(lower, "/llms.txt") || strings.HasSuffix(lower, "llms.txt") </span><span class="cov8" title="1">{
                return StrategyLLMS
        }</span>

        // Check for pkg.go.dev (before Git, since pkg.go.dev URLs contain github.com paths)
        <span class="cov8" title="1">if strings.Contains(lower, "pkg.go.dev") </span><span class="cov8" title="1">{
                return StrategyPkgGo
        }</span>

        // Check for sitemap
        <span class="cov8" title="1">if strings.HasSuffix(lower, "sitemap.xml") ||
                strings.HasSuffix(lower, "sitemap.xml.gz") ||
                strings.Contains(lower, "sitemap") &amp;&amp; strings.HasSuffix(lower, ".xml") </span><span class="cov8" title="1">{
                return StrategySitemap
        }</span>

        // Check for Git repository
        <span class="cov8" title="1">if strings.HasPrefix(url, "git@") ||
                strings.HasSuffix(lower, ".git") ||
                (strings.Contains(lower, "github.com") &amp;&amp; !strings.Contains(lower, "/blob/") &amp;&amp; !strings.Contains(lower, "/tree/")) ||
                (strings.Contains(lower, "gitlab.com") &amp;&amp; !strings.Contains(lower, "/-/blob/") &amp;&amp; !strings.Contains(lower, "/-/tree/")) ||
                strings.Contains(lower, "bitbucket.org") </span><span class="cov8" title="1">{
                return StrategyGit
        }</span>

        // Default to crawler for HTTP URLs
        <span class="cov8" title="1">if strings.HasPrefix(lower, "http://") || strings.HasPrefix(lower, "https://") </span><span class="cov8" title="1">{
                return StrategyCrawler
        }</span>

        <span class="cov8" title="1">return StrategyUnknown</span>
}

// CreateStrategy creates the appropriate strategy based on detected type
func CreateStrategy(strategyType StrategyType, deps *strategies.Dependencies) strategies.Strategy <span class="cov8" title="1">{
        switch strategyType </span>{
        case StrategyLLMS:<span class="cov8" title="1">
                return strategies.NewLLMSStrategy(deps)</span>
        case StrategySitemap:<span class="cov8" title="1">
                return strategies.NewSitemapStrategy(deps)</span>
        case StrategyGit:<span class="cov0" title="0">
                return strategies.NewGitStrategy(deps)</span>
        case StrategyPkgGo:<span class="cov0" title="0">
                return strategies.NewPkgGoStrategy(deps)</span>
        case StrategyCrawler:<span class="cov8" title="1">
                return strategies.NewCrawlerStrategy(deps)</span>
        default:<span class="cov0" title="0">
                return nil</span>
        }
}

// GetAllStrategies returns all available strategies
func GetAllStrategies(deps *strategies.Dependencies) []strategies.Strategy <span class="cov8" title="1">{
        return []strategies.Strategy{
                strategies.NewLLMSStrategy(deps),
                strategies.NewSitemapStrategy(deps),
                strategies.NewGitStrategy(deps),
                strategies.NewPkgGoStrategy(deps),
                strategies.NewCrawlerStrategy(deps),
        }
}</span>

// FindMatchingStrategy finds the first strategy that can handle the URL
func FindMatchingStrategy(url string, deps *strategies.Dependencies) strategies.Strategy <span class="cov8" title="1">{
        for _, strategy := range GetAllStrategies(deps) </span><span class="cov8" title="1">{
                if strategy.CanHandle(url) </span><span class="cov8" title="1">{
                        return strategy
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package app

import (
        "context"
        "fmt"
        "time"

        "github.com/quantmind-br/repodocs-go/internal/config"
        "github.com/quantmind-br/repodocs-go/internal/strategies"
        "github.com/quantmind-br/repodocs-go/internal/utils"
)

// Orchestrator coordinates the documentation extraction process
type Orchestrator struct {
        config          *config.Config
        deps            *strategies.Dependencies
        logger          *utils.Logger
        strategyFactory func(StrategyType, *strategies.Dependencies) strategies.Strategy
}

// OrchestratorOptions contains options for creating an orchestrator
type OrchestratorOptions struct {
        Config          *config.Config
        Verbose         bool
        DryRun          bool
        Force           bool
        RenderJS        bool
        Split           bool
        IncludeAssets   bool
        Limit           int
        ContentSelector string
        ExcludePatterns []string
        FilterURL       string
        // StrategyFactory allows injecting custom strategy creation logic for testing
        // If nil, uses default strategy creation
        StrategyFactory func(StrategyType, *strategies.Dependencies) strategies.Strategy
}

// NewOrchestrator creates a new orchestrator with the given configuration
func NewOrchestrator(opts OrchestratorOptions) (*Orchestrator, error) <span class="cov8" title="1">{
        cfg := opts.Config

        // Validate config
        if cfg == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("config is required")
        }</span>

        // Create logger
        <span class="cov8" title="1">logLevel := "info"
        logFormat := "pretty"
        if cfg.Logging.Level != "" </span><span class="cov8" title="1">{
                logLevel = cfg.Logging.Level
        }</span>
        <span class="cov8" title="1">if cfg.Logging.Format != "" </span><span class="cov8" title="1">{
                logFormat = cfg.Logging.Format
        }</span>
        <span class="cov8" title="1">if opts.Verbose </span><span class="cov8" title="1">{
                logLevel = "debug"
        }</span>

        <span class="cov8" title="1">logger := utils.NewLogger(utils.LoggerOptions{
                Level:   logLevel,
                Format:  logFormat,
                Verbose: opts.Verbose,
        })

        // Determine cache directory
        cacheDir := cfg.Cache.Directory
        if cacheDir == "" </span><span class="cov0" title="0">{
                cacheDir = "~/.repodocs/cache"
        }</span>
        <span class="cov8" title="1">cacheDir = utils.ExpandPath(cacheDir)

        // Create dependencies
        deps, err := strategies.NewDependencies(strategies.DependencyOptions{
                Timeout:         cfg.Concurrency.Timeout,
                EnableCache:     cfg.Cache.Enabled,
                CacheTTL:        cfg.Cache.TTL,
                CacheDir:        cacheDir,
                UserAgent:       cfg.Stealth.UserAgent,
                EnableRenderer:  cfg.Rendering.ForceJS || opts.RenderJS,
                RendererTimeout: cfg.Rendering.JSTimeout,
                Concurrency:     cfg.Concurrency.Workers,
                ContentSelector: opts.ContentSelector,
                OutputDir:       cfg.Output.Directory,
                Flat:            cfg.Output.Flat,
                JSONMetadata:    cfg.Output.JSONMetadata,
                Force:           opts.Force || cfg.Output.Overwrite,
                DryRun:          opts.DryRun,
                Verbose:         opts.Verbose,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create dependencies: %w", err)
        }</span>

        // Set default strategy factory if none provided
        <span class="cov8" title="1">strategyFactory := opts.StrategyFactory
        if strategyFactory == nil </span><span class="cov8" title="1">{
                strategyFactory = func(st StrategyType, d *strategies.Dependencies) strategies.Strategy </span><span class="cov8" title="1">{
                        return CreateStrategy(st, d)
                }</span>
        }

        <span class="cov8" title="1">return &amp;Orchestrator{
                config:          cfg,
                deps:            deps,
                logger:          logger,
                strategyFactory: strategyFactory,
        }, nil</span>
}

// Run executes the documentation extraction for the given URL
func (o *Orchestrator) Run(ctx context.Context, url string, opts OrchestratorOptions) error <span class="cov8" title="1">{
        startTime := time.Now()

        o.logger.Info().
                Str("url", url).
                Str("output", o.config.Output.Directory).
                Int("concurrency", o.config.Concurrency.Workers).
                Msg("Starting documentation extraction")

        // Detect strategy
        strategyType := DetectStrategy(url)
        o.logger.Debug().
                Str("strategy", string(strategyType)).
                Msg("Detected strategy type")

        if strategyType == StrategyUnknown </span><span class="cov8" title="1">{
                return fmt.Errorf("unable to determine strategy for URL: %s", url)
        }</span>

        // Create strategy using strategy factory (allows injection for testing)
        <span class="cov8" title="1">strategy := o.strategyFactory(strategyType, o.deps)
        if strategy == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create strategy for URL: %s", url)
        }</span>

        <span class="cov8" title="1">o.logger.Info().
                Str("strategy", strategy.Name()).
                Msg("Using extraction strategy")

        // Build strategy options
        strategyOpts := strategies.Options{
                Output:          o.config.Output.Directory,
                Concurrency:     o.config.Concurrency.Workers,
                Limit:           opts.Limit,
                MaxDepth:        o.config.Concurrency.MaxDepth,
                Exclude:         append(o.config.Exclude, opts.ExcludePatterns...),
                NoFolders:       o.config.Output.Flat,
                DryRun:          opts.DryRun,
                Verbose:         opts.Verbose,
                Force:           opts.Force || o.config.Output.Overwrite,
                RenderJS:        opts.RenderJS || o.config.Rendering.ForceJS,
                Split:           opts.Split,
                IncludeAssets:   opts.IncludeAssets,
                ContentSelector: opts.ContentSelector,
                FilterURL:       opts.FilterURL,
        }

        // Execute strategy
        if err := strategy.Execute(ctx, url, strategyOpts); err != nil </span><span class="cov8" title="1">{
                // Check if it was a context cancellation
                if ctx.Err() != nil </span><span class="cov8" title="1">{
                        o.logger.Warn().Msg("Extraction cancelled")
                        return ctx.Err()
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("strategy execution failed: %w", err)</span>
        }

        <span class="cov8" title="1">duration := time.Since(startTime)
        o.logger.Info().
                Dur("duration", duration).
                Msg("Documentation extraction completed")

        return nil</span>
}

// Close releases all resources held by the orchestrator
func (o *Orchestrator) Close() error <span class="cov8" title="1">{
        if o.deps != nil </span><span class="cov8" title="1">{
                return o.deps.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetStrategyName returns the detected strategy name for a URL
func (o *Orchestrator) GetStrategyName(url string) string <span class="cov8" title="1">{
        return string(DetectStrategy(url))
}</span>

// ValidateURL checks if the URL can be processed
func (o *Orchestrator) ValidateURL(url string) error <span class="cov8" title="1">{
        strategyType := DetectStrategy(url)
        if strategyType == StrategyUnknown </span><span class="cov8" title="1">{
                return fmt.Errorf("unsupported URL format: %s", url)
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package cache

import (
        "context"
        "os"
        "time"

        "github.com/dgraph-io/badger/v4"
        "github.com/quantmind-br/repodocs-go/internal/domain"
)

// BadgerCache is a cache implementation using BadgerDB
type BadgerCache struct {
        db *badger.DB
}

// NewBadgerCache creates a new BadgerDB cache
func NewBadgerCache(opts Options) (*BadgerCache, error) <span class="cov8" title="1">{
        var badgerOpts badger.Options

        if opts.InMemory </span><span class="cov8" title="1">{
                badgerOpts = badger.DefaultOptions("").WithInMemory(true)
        }</span> else<span class="cov8" title="1"> {
                if opts.Directory == "" </span><span class="cov0" title="0">{
                        homeDir, err := os.UserHomeDir()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">opts.Directory = homeDir + "/.repodocs/cache"</span>
                }

                // Ensure directory exists
                <span class="cov8" title="1">if err := os.MkdirAll(opts.Directory, 0755); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">badgerOpts = badger.DefaultOptions(opts.Directory)</span>
        }

        // Disable logging unless explicitly enabled
        <span class="cov8" title="1">if !opts.Logger </span><span class="cov8" title="1">{
                badgerOpts = badgerOpts.WithLogger(nil)
        }</span>

        <span class="cov8" title="1">db, err := badger.Open(badgerOpts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Start background garbage collection
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                ticker := time.NewTicker(5 * time.Minute)
                defer ticker.Stop()
                for range ticker.C </span><span class="cov0" title="0">{
                        _ = db.RunValueLogGC(0.5)
                }</span>
        }()

        <span class="cov8" title="1">return &amp;BadgerCache{db: db}, nil</span>
}

// Get retrieves a value from cache
func (c *BadgerCache) Get(ctx context.Context, key string) ([]byte, error) <span class="cov8" title="1">{
        // Generate cache key from URL
        cacheKey := GenerateKey(key)

        var value []byte
        err := c.db.View(func(txn *badger.Txn) error </span><span class="cov8" title="1">{
                item, err := txn.Get([]byte(cacheKey))
                if err != nil </span><span class="cov8" title="1">{
                        if err == badger.ErrKeyNotFound </span><span class="cov8" title="1">{
                                return domain.ErrCacheMiss
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }

                <span class="cov8" title="1">value, err = item.ValueCopy(nil)
                return err</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return value, nil</span>
}

// Set stores a value in cache with TTL
func (c *BadgerCache) Set(ctx context.Context, key string, value []byte, ttl time.Duration) error <span class="cov8" title="1">{
        // Generate cache key from URL
        cacheKey := GenerateKey(key)

        return c.db.Update(func(txn *badger.Txn) error </span><span class="cov8" title="1">{
                e := badger.NewEntry([]byte(cacheKey), value)
                if ttl &gt; 0 </span><span class="cov8" title="1">{
                        e = e.WithTTL(ttl)
                }</span>
                <span class="cov8" title="1">return txn.SetEntry(e)</span>
        })
}

// Has checks if a key exists in cache
func (c *BadgerCache) Has(ctx context.Context, key string) bool <span class="cov8" title="1">{
        cacheKey := GenerateKey(key)

        err := c.db.View(func(txn *badger.Txn) error </span><span class="cov8" title="1">{
                _, err := txn.Get([]byte(cacheKey))
                return err
        }</span>)

        <span class="cov8" title="1">return err == nil</span>
}

// Delete removes a key from cache
func (c *BadgerCache) Delete(ctx context.Context, key string) error <span class="cov8" title="1">{
        cacheKey := GenerateKey(key)

        return c.db.Update(func(txn *badger.Txn) error </span><span class="cov8" title="1">{
                return txn.Delete([]byte(cacheKey))
        }</span>)
}

// Close releases cache resources
func (c *BadgerCache) Close() error <span class="cov8" title="1">{
        return c.db.Close()
}</span>

// Clear removes all entries from the cache
func (c *BadgerCache) Clear() error <span class="cov8" title="1">{
        return c.db.DropAll()
}</span>

// Size returns the number of entries in the cache
func (c *BadgerCache) Size() int64 <span class="cov8" title="1">{
        var count int64
        _ = c.db.View(func(txn *badger.Txn) error </span><span class="cov8" title="1">{
                opts := badger.DefaultIteratorOptions
                opts.PrefetchValues = false
                it := txn.NewIterator(opts)
                defer it.Close()

                for it.Rewind(); it.Valid(); it.Next() </span><span class="cov8" title="1">{
                        count++
                }</span>
                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">return count</span>
}

// Stats returns cache statistics
func (c *BadgerCache) Stats() map[string]interface{} <span class="cov8" title="1">{
        lsm, vlog := c.db.Size()
        return map[string]interface{}{
                "entries":   c.Size(),
                "lsm_size":  lsm,
                "vlog_size": vlog,
        }
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package cache

import (
        "time"

        "github.com/quantmind-br/repodocs-go/internal/domain"
)

// Ensure BadgerCache implements domain.Cache
var _ domain.Cache = (*BadgerCache)(nil)

// Entry represents a cached entry with metadata
type Entry struct {
        URL         string    `json:"url"`
        Content     []byte    `json:"content"`
        ContentType string    `json:"content_type"`
        FetchedAt   time.Time `json:"fetched_at"`
        ExpiresAt   time.Time `json:"expires_at"`
}

// IsExpired returns true if the entry has expired
func (e *Entry) IsExpired() bool <span class="cov8" title="1">{
        return time.Now().After(e.ExpiresAt)
}</span>

// TTL returns the remaining time-to-live
func (e *Entry) TTL() time.Duration <span class="cov8" title="1">{
        remaining := time.Until(e.ExpiresAt)
        if remaining &lt; 0 </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">return remaining</span>
}

// Options contains cache configuration options
type Options struct {
        Directory string
        InMemory  bool
        Logger    bool
}

// DefaultOptions returns default cache options
func DefaultOptions() Options <span class="cov0" title="0">{
        return Options{
                Directory: "",
                InMemory:  false,
                Logger:    false,
        }
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package cache

import (
        "crypto/sha256"
        "encoding/hex"
        "net/url"
        "path"
        "strings"
)

// GenerateKey generates a cache key from a URL
// The key is a SHA256 hash of the normalized URL
func GenerateKey(rawURL string) string <span class="cov8" title="1">{
        normalized := normalizeForKey(rawURL)
        hash := sha256.Sum256([]byte(normalized))
        return hex.EncodeToString(hash[:])
}</span>

// GenerateKeyWithPrefix generates a cache key with a prefix
func GenerateKeyWithPrefix(prefix, rawURL string) string <span class="cov8" title="1">{
        key := GenerateKey(rawURL)
        return prefix + ":" + key
}</span>

// normalizeForKey normalizes a URL for consistent key generation
func normalizeForKey(rawURL string) string <span class="cov8" title="1">{
        u, err := url.Parse(rawURL)
        if err != nil </span><span class="cov8" title="1">{
                return rawURL
        }</span>

        // Normalize scheme
        <span class="cov8" title="1">if u.Scheme == "" </span><span class="cov0" title="0">{
                u.Scheme = "https"
        }</span>

        // Normalize host
        <span class="cov8" title="1">u.Host = strings.ToLower(u.Host)

        // Remove default ports
        if (u.Scheme == "http" &amp;&amp; u.Port() == "80") ||
                (u.Scheme == "https" &amp;&amp; u.Port() == "443") </span><span class="cov0" title="0">{
                u.Host = u.Hostname()
        }</span>

        // Clean path
        <span class="cov8" title="1">if u.Path == "" </span><span class="cov8" title="1">{
                u.Path = "/"
        }</span> else<span class="cov8" title="1"> {
                u.Path = path.Clean(u.Path)
        }</span>

        // Remove trailing slash except for root
        <span class="cov8" title="1">if u.Path != "/" &amp;&amp; strings.HasSuffix(u.Path, "/") </span><span class="cov0" title="0">{
                u.Path = strings.TrimSuffix(u.Path, "/")
        }</span>

        // Remove fragment
        <span class="cov8" title="1">u.Fragment = ""

        return u.String()</span>
}

// KeyPrefix constants for different cache types
const (
        PrefixPage     = "page"
        PrefixSitemap  = "sitemap"
        PrefixGit      = "git"
        PrefixMetadata = "meta"
)

// PageKey generates a cache key for a page
func PageKey(url string) string <span class="cov8" title="1">{
        return GenerateKeyWithPrefix(PrefixPage, url)
}</span>

// SitemapKey generates a cache key for a sitemap
func SitemapKey(url string) string <span class="cov8" title="1">{
        return GenerateKeyWithPrefix(PrefixSitemap, url)
}</span>

// MetadataKey generates a cache key for metadata
func MetadataKey(url string) string <span class="cov8" title="1">{
        return GenerateKeyWithPrefix(PrefixMetadata, url)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package config

import "time"

// Config represents the application configuration
type Config struct {
        Output      OutputConfig      `mapstructure:"output"`
        Concurrency ConcurrencyConfig `mapstructure:"concurrency"`
        Cache       CacheConfig       `mapstructure:"cache"`
        Rendering   RenderingConfig   `mapstructure:"rendering"`
        Stealth     StealthConfig     `mapstructure:"stealth"`
        Exclude     []string          `mapstructure:"exclude"`
        Logging     LoggingConfig     `mapstructure:"logging"`
}

// OutputConfig contains output-related settings
type OutputConfig struct {
        Directory    string `mapstructure:"directory"`
        Flat         bool   `mapstructure:"flat"`
        JSONMetadata bool   `mapstructure:"json_metadata"`
        Overwrite    bool   `mapstructure:"overwrite"`
}

// ConcurrencyConfig contains concurrency settings
type ConcurrencyConfig struct {
        Workers  int           `mapstructure:"workers"`
        Timeout  time.Duration `mapstructure:"timeout"`
        MaxDepth int           `mapstructure:"max_depth"`
}

// CacheConfig contains cache settings
type CacheConfig struct {
        Enabled   bool          `mapstructure:"enabled"`
        TTL       time.Duration `mapstructure:"ttl"`
        Directory string        `mapstructure:"directory"`
}

// RenderingConfig contains JavaScript rendering settings
type RenderingConfig struct {
        ForceJS     bool          `mapstructure:"force_js"`
        JSTimeout   time.Duration `mapstructure:"js_timeout"`
        ScrollToEnd bool          `mapstructure:"scroll_to_end"`
}

// StealthConfig contains stealth mode settings
type StealthConfig struct {
        UserAgent      string        `mapstructure:"user_agent"`
        RandomDelayMin time.Duration `mapstructure:"random_delay_min"`
        RandomDelayMax time.Duration `mapstructure:"random_delay_max"`
}

// LoggingConfig contains logging settings
type LoggingConfig struct {
        Level  string `mapstructure:"level"`
        Format string `mapstructure:"format"`
}

// Validate validates the configuration
func (c *Config) Validate() error <span class="cov8" title="1">{
        if c.Concurrency.Workers &lt; 1 </span><span class="cov8" title="1">{
                c.Concurrency.Workers = DefaultWorkers
        }</span>
        <span class="cov8" title="1">if c.Concurrency.MaxDepth &lt; 1 </span><span class="cov8" title="1">{
                c.Concurrency.MaxDepth = DefaultMaxDepth
        }</span>
        <span class="cov8" title="1">if c.Concurrency.Timeout &lt; time.Second </span><span class="cov8" title="1">{
                c.Concurrency.Timeout = DefaultTimeout
        }</span>
        <span class="cov8" title="1">if c.Cache.TTL &lt; time.Minute </span><span class="cov8" title="1">{
                c.Cache.TTL = DefaultCacheTTL
        }</span>
        <span class="cov8" title="1">if c.Rendering.JSTimeout &lt; time.Second </span><span class="cov8" title="1">{
                c.Rendering.JSTimeout = DefaultJSTimeout
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package config

import (
        "os"
        "path/filepath"
        "time"
)

// Default values
const (
        // Output defaults
        DefaultOutputDir = "./docs"

        // Concurrency defaults
        DefaultWorkers  = 5
        DefaultTimeout  = 30 * time.Second
        DefaultMaxDepth = 3

        // Cache defaults
        DefaultCacheEnabled = true
        DefaultCacheTTL     = 24 * time.Hour

        // Rendering defaults
        DefaultJSTimeout   = 60 * time.Second
        DefaultScrollToEnd = true

        // Stealth defaults
        DefaultRandomDelayMin = 1 * time.Second
        DefaultRandomDelayMax = 3 * time.Second

        // Logging defaults
        DefaultLogLevel  = "info"
        DefaultLogFormat = "pretty"
)

// Default exclude patterns
var DefaultExcludePatterns = []string{
        `.*\.pdf$`,
        `.*/login.*`,
        `.*/logout.*`,
        `.*/admin.*`,
        `.*/sign-in.*`,
        `.*/sign-up.*`,
}

// ConfigDir returns the config directory path
func ConfigDir() string <span class="cov8" title="1">{
        home, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return ".repodocs"
        }</span>
        <span class="cov8" title="1">return filepath.Join(home, ".repodocs")</span>
}

// CacheDir returns the cache directory path
func CacheDir() string <span class="cov8" title="1">{
        return filepath.Join(ConfigDir(), "cache")
}</span>

// ConfigFilePath returns the config file path
func ConfigFilePath() string <span class="cov0" title="0">{
        return filepath.Join(ConfigDir(), "config.yaml")
}</span>

// Default returns the default configuration
func Default() *Config <span class="cov8" title="1">{
        return &amp;Config{
                Output: OutputConfig{
                        Directory:    DefaultOutputDir,
                        Flat:         false,
                        JSONMetadata: false,
                        Overwrite:    false,
                },
                Concurrency: ConcurrencyConfig{
                        Workers:  DefaultWorkers,
                        Timeout:  DefaultTimeout,
                        MaxDepth: DefaultMaxDepth,
                },
                Cache: CacheConfig{
                        Enabled:   DefaultCacheEnabled,
                        TTL:       DefaultCacheTTL,
                        Directory: CacheDir(),
                },
                Rendering: RenderingConfig{
                        ForceJS:     false,
                        JSTimeout:   DefaultJSTimeout,
                        ScrollToEnd: DefaultScrollToEnd,
                },
                Stealth: StealthConfig{
                        UserAgent:      "",
                        RandomDelayMin: DefaultRandomDelayMin,
                        RandomDelayMax: DefaultRandomDelayMax,
                },
                Exclude: DefaultExcludePatterns,
                Logging: LoggingConfig{
                        Level:  DefaultLogLevel,
                        Format: DefaultLogFormat,
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package config

import (
        "os"
        "strings"

        "github.com/spf13/viper"
)

// Load loads configuration from file, environment, and defaults
// Uses the global viper instance to access CLI flag bindings
func Load() (*Config, error) <span class="cov8" title="1">{
        // Use global viper instance to get CLI flag bindings
        v := viper.GetViper()

        // Set defaults
        setDefaults(v)

        // Config file settings
        v.SetConfigName("config")
        v.SetConfigType("yaml")
        v.AddConfigPath(ConfigDir())
        v.AddConfigPath(".")

        // Read config file (ignore if not found)
        if err := v.ReadInConfig(); err != nil </span><span class="cov0" title="0">{
                if _, ok := err.(viper.ConfigFileNotFoundError); !ok </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        // Environment variables (REPODOCS_*)
        <span class="cov8" title="1">v.SetEnvPrefix("REPODOCS")
        v.SetEnvKeyReplacer(strings.NewReplacer(".", "_"))
        v.AutomaticEnv()

        // Unmarshal config
        var cfg Config
        if err := v.Unmarshal(&amp;cfg); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Validate and apply defaults for invalid values
        <span class="cov8" title="1">if err := cfg.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;cfg, nil</span>
}

// LoadWithViper loads configuration and returns the viper instance
// This is useful for merging CLI flags later
func LoadWithViper() (*Config, *viper.Viper, error) <span class="cov8" title="1">{
        v := viper.New()

        // Set defaults
        setDefaults(v)

        // Config file settings
        v.SetConfigName("config")
        v.SetConfigType("yaml")
        v.AddConfigPath(ConfigDir())
        v.AddConfigPath(".")

        // Read config file (ignore if not found)
        if err := v.ReadInConfig(); err != nil </span><span class="cov8" title="1">{
                if _, ok := err.(viper.ConfigFileNotFoundError); !ok </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>
        }

        // Environment variables (REPODOCS_*)
        <span class="cov8" title="1">v.SetEnvPrefix("REPODOCS")
        v.SetEnvKeyReplacer(strings.NewReplacer(".", "_"))
        v.AutomaticEnv()

        // Unmarshal config
        var cfg Config
        if err := v.Unmarshal(&amp;cfg); err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        // Validate
        <span class="cov8" title="1">if err := cfg.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov8" title="1">return &amp;cfg, v, nil</span>
}

// setDefaults sets default values in viper
func setDefaults(v *viper.Viper) <span class="cov8" title="1">{
        // Output defaults
        v.SetDefault("output.directory", DefaultOutputDir)
        v.SetDefault("output.flat", false)
        v.SetDefault("output.json_metadata", false)
        v.SetDefault("output.overwrite", false)

        // Concurrency defaults
        v.SetDefault("concurrency.workers", DefaultWorkers)
        v.SetDefault("concurrency.timeout", DefaultTimeout)
        v.SetDefault("concurrency.max_depth", DefaultMaxDepth)

        // Cache defaults
        v.SetDefault("cache.enabled", DefaultCacheEnabled)
        v.SetDefault("cache.ttl", DefaultCacheTTL)
        v.SetDefault("cache.directory", CacheDir())

        // Rendering defaults
        v.SetDefault("rendering.force_js", false)
        v.SetDefault("rendering.js_timeout", DefaultJSTimeout)
        v.SetDefault("rendering.scroll_to_end", DefaultScrollToEnd)

        // Stealth defaults
        v.SetDefault("stealth.user_agent", "")
        v.SetDefault("stealth.random_delay_min", DefaultRandomDelayMin)
        v.SetDefault("stealth.random_delay_max", DefaultRandomDelayMax)

        // Exclude defaults
        v.SetDefault("exclude", DefaultExcludePatterns)

        // Logging defaults
        v.SetDefault("logging.level", DefaultLogLevel)
        v.SetDefault("logging.format", DefaultLogFormat)
}</span>

// EnsureConfigDir creates the config directory if it doesn't exist
func EnsureConfigDir() error <span class="cov8" title="1">{
        dir := ConfigDir()
        return os.MkdirAll(dir, 0755)
}</span>

// EnsureCacheDir creates the cache directory if it doesn't exist
func EnsureCacheDir() error <span class="cov8" title="1">{
        dir := CacheDir()
        return os.MkdirAll(dir, 0755)
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package converter

import (
        "bytes"
        "io"
        "strings"

        "golang.org/x/net/html/charset"
        "golang.org/x/text/encoding"
        "golang.org/x/text/encoding/htmlindex"
        "golang.org/x/text/transform"
)

// DetectEncoding detects the character encoding of HTML content
func DetectEncoding(content []byte) string <span class="cov8" title="1">{
        // Try to detect from content-type meta tag or charset attribute
        contentStr := string(content[:min(1024, len(content))])

        // Look for charset in meta tag
        if enc := extractCharsetFromMeta(contentStr); enc != "" </span><span class="cov8" title="1">{
                return enc
        }</span>

        // Use golang.org/x/net/html/charset for detection
        <span class="cov8" title="1">_, name, _ := charset.DetermineEncoding(content, "")
        if name != "" </span><span class="cov8" title="1">{
                return name
        }</span>

        // Default to UTF-8
        <span class="cov0" title="0">return "utf-8"</span>
}

// extractCharsetFromMeta extracts charset from meta tag
func extractCharsetFromMeta(html string) string <span class="cov8" title="1">{
        html = strings.ToLower(html)

        // Look for &lt;meta charset="..."&gt;
        if idx := strings.Index(html, "charset="); idx != -1 </span><span class="cov8" title="1">{
                start := idx + 8
                end := start

                // Skip quote if present
                if start &lt; len(html) &amp;&amp; (html[start] == '"' || html[start] == '\'') </span><span class="cov8" title="1">{
                        start++
                }</span>

                // Find end of charset value
                <span class="cov8" title="1">for end = start; end &lt; len(html); end++ </span><span class="cov8" title="1">{
                        c := html[end]
                        if c == '"' || c == '\'' || c == ';' || c == '&gt;' || c == ' ' </span><span class="cov8" title="1">{
                                break</span>
                        }
                }

                <span class="cov8" title="1">if end &gt; start </span><span class="cov8" title="1">{
                        return strings.TrimSpace(html[start:end])
                }</span>
        }

        <span class="cov8" title="1">return ""</span>
}

// ConvertToUTF8 converts content from detected encoding to UTF-8
func ConvertToUTF8(content []byte) ([]byte, error) <span class="cov8" title="1">{
        enc := DetectEncoding(content)

        // Already UTF-8
        if enc == "utf-8" || enc == "utf8" </span><span class="cov8" title="1">{
                return content, nil
        }</span>

        // Get encoder for the detected charset
        <span class="cov8" title="1">e, err := htmlindex.Get(enc)
        if err != nil </span><span class="cov0" title="0">{
                // Unknown encoding, return as-is
                return content, nil
        }</span>

        // Decode to UTF-8
        <span class="cov8" title="1">reader := transform.NewReader(bytes.NewReader(content), e.NewDecoder())
        return io.ReadAll(reader)</span>
}

// IsUTF8 checks if content is valid UTF-8
func IsUTF8(content []byte) bool <span class="cov8" title="1">{
        enc := DetectEncoding(content)
        return enc == "utf-8" || enc == "utf8"
}</span>

// GetEncoder returns the encoding for a charset name
func GetEncoder(charsetName string) (encoding.Encoding, error) <span class="cov8" title="1">{
        return htmlindex.Get(charsetName)
}</span>

// min returns the minimum of two integers
func min(a, b int) int <span class="cov8" title="1">{
        if a &lt; b </span><span class="cov8" title="1">{
                return a
        }</span>
        <span class="cov8" title="1">return b</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package converter

import (
        "fmt"
        "regexp"
        "strings"

        md "github.com/JohannesKaufmann/html-to-markdown/v2"
        "github.com/quantmind-br/repodocs-go/internal/domain"
        "gopkg.in/yaml.v3"
)

// MarkdownConverter converts HTML to Markdown
type MarkdownConverter struct {
        domain string
}

// MarkdownOptions contains options for Markdown conversion
type MarkdownOptions struct {
        Domain          string
        CodeBlockStyle  string // "fenced" or "indented"
        HeadingStyle    string // "atx" or "setext"
        BulletListStyle string // "-", "*", or "+"
}

// DefaultMarkdownOptions returns default Markdown options
func DefaultMarkdownOptions() MarkdownOptions <span class="cov8" title="1">{
        return MarkdownOptions{
                CodeBlockStyle:  "fenced",
                HeadingStyle:    "atx",
                BulletListStyle: "-",
        }
}</span>

// NewMarkdownConverter creates a new Markdown converter
func NewMarkdownConverter(opts MarkdownOptions) *MarkdownConverter <span class="cov8" title="1">{
        return &amp;MarkdownConverter{
                domain: opts.Domain,
        }
}</span>

// Convert converts HTML to Markdown
func (c *MarkdownConverter) Convert(html string) (string, error) <span class="cov8" title="1">{
        // html-to-markdown v2 uses ConvertString directly
        markdown, err := md.ConvertString(html)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to convert HTML to Markdown: %w", err)
        }</span>

        // Clean up the markdown
        <span class="cov8" title="1">markdown = c.cleanMarkdown(markdown)

        return markdown, nil</span>
}

// cleanMarkdown cleans up the converted markdown
func (c *MarkdownConverter) cleanMarkdown(markdown string) string <span class="cov8" title="1">{
        // Remove excessive blank lines (more than 2 consecutive)
        for strings.Contains(markdown, "\n\n\n\n") </span><span class="cov0" title="0">{
                markdown = strings.ReplaceAll(markdown, "\n\n\n\n", "\n\n\n")
        }</span>

        // Trim leading/trailing whitespace
        <span class="cov8" title="1">markdown = strings.TrimSpace(markdown)

        return markdown</span>
}

// GenerateFrontmatter generates YAML frontmatter for a document
func GenerateFrontmatter(doc *domain.Document) (string, error) <span class="cov8" title="1">{
        fm := doc.ToFrontmatter()
        data, err := yaml.Marshal(fm)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">return fmt.Sprintf("---\n%s---\n\n", string(data)), nil</span>
}

// AddFrontmatter adds YAML frontmatter to markdown content
func AddFrontmatter(markdown string, doc *domain.Document) (string, error) <span class="cov8" title="1">{
        frontmatter, err := GenerateFrontmatter(doc)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">return frontmatter + markdown, nil</span>
}

// CountWords counts words in text
func CountWords(text string) int <span class="cov8" title="1">{
        words := strings.Fields(text)
        return len(words)
}</span>

// CountChars counts characters in text
func CountChars(text string) int <span class="cov8" title="1">{
        return len(text)
}</span>

// StripMarkdown removes markdown formatting to get plain text
func StripMarkdown(markdown string) string <span class="cov8" title="1">{
        // Remove code blocks
        markdown = removeCodeBlocks(markdown)

        // Remove links but keep text: [text](url) -&gt; text
        linkRegex := regexp.MustCompile(`\[([^\]]+)\]\([^)]+\)`)
        markdown = linkRegex.ReplaceAllString(markdown, "$1")

        // Remove images: ![alt](url) -&gt; alt
        imageRegex := regexp.MustCompile(`!\[([^\]]*)\]\([^)]+\)`)
        markdown = imageRegex.ReplaceAllString(markdown, "$1")

        // Remove emphasis: **bold** -&gt; bold, *italic* -&gt; italic
        markdown = regexp.MustCompile(`\*\*([^*]+)\*\*`).ReplaceAllString(markdown, "$1")
        markdown = regexp.MustCompile(`\*([^*]+)\*`).ReplaceAllString(markdown, "$1")
        markdown = regexp.MustCompile(`__([^_]+)__`).ReplaceAllString(markdown, "$1")
        markdown = regexp.MustCompile(`_([^_]+)_`).ReplaceAllString(markdown, "$1")

        // Remove headers: # Header -&gt; Header
        markdown = regexp.MustCompile(`(?m)^#{1,6}\s+`).ReplaceAllString(markdown, "")

        // Remove horizontal rules
        markdown = regexp.MustCompile(`(?m)^[\-*_]{3,}$`).ReplaceAllString(markdown, "")

        // Remove blockquotes
        markdown = regexp.MustCompile(`(?m)^&gt;\s+`).ReplaceAllString(markdown, "")

        // Remove list markers
        markdown = regexp.MustCompile(`(?m)^[\s]*[\-*+]\s+`).ReplaceAllString(markdown, "")
        markdown = regexp.MustCompile(`(?m)^[\s]*\d+\.\s+`).ReplaceAllString(markdown, "")

        return strings.TrimSpace(markdown)
}</span>

// removeCodeBlocks removes fenced code blocks
func removeCodeBlocks(markdown string) string <span class="cov8" title="1">{
        // Remove fenced code blocks
        fenced := regexp.MustCompile("(?s)```[^`]*```")
        markdown = fenced.ReplaceAllString(markdown, "")

        // Remove indented code blocks (lines starting with 4 spaces or tab)
        indented := regexp.MustCompile(`(?m)^(    |\t).*$`)
        markdown = indented.ReplaceAllString(markdown, "")

        return markdown
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package converter

import (
        "context"
        "crypto/sha256"
        "encoding/hex"
        "strings"
        "time"

        "github.com/PuerkitoBio/goquery"
        "github.com/quantmind-br/repodocs-go/internal/domain"
)

// Pipeline orchestrates the HTML to Markdown conversion process
type Pipeline struct {
        sanitizer   *Sanitizer
        extractor   *ExtractContent
        mdConverter *MarkdownConverter
}

// PipelineOptions contains options for the conversion pipeline
type PipelineOptions struct {
        BaseURL         string
        ContentSelector string
}

// NewPipeline creates a new conversion pipeline
func NewPipeline(opts PipelineOptions) *Pipeline <span class="cov8" title="1">{
        sanitizer := NewSanitizer(SanitizerOptions{
                BaseURL:          opts.BaseURL,
                RemoveNavigation: true,
                RemoveComments:   true,
        })

        extractor := NewExtractContent(opts.ContentSelector)

        mdConverter := NewMarkdownConverter(MarkdownOptions{
                Domain:          opts.BaseURL,
                CodeBlockStyle:  "fenced",
                HeadingStyle:    "atx",
                BulletListStyle: "-",
        })

        return &amp;Pipeline{
                sanitizer:   sanitizer,
                extractor:   extractor,
                mdConverter: mdConverter,
        }
}</span>

// Convert processes HTML content and returns a Document
func (p *Pipeline) Convert(ctx context.Context, html string, sourceURL string) (*domain.Document, error) <span class="cov8" title="1">{
        // Step 1: Convert encoding to UTF-8
        htmlBytes, err := ConvertToUTF8([]byte(html))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">html = string(htmlBytes)

        // Step 2: Extract main content
        content, title, err := p.extractor.Extract(html, sourceURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Step 3: Sanitize HTML
        <span class="cov8" title="1">sanitized, err := p.sanitizer.Sanitize(content)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Step 4: Convert to Markdown
        <span class="cov8" title="1">markdown, err := p.mdConverter.Convert(sanitized)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Step 5: Extract metadata
        <span class="cov8" title="1">doc, err := goquery.NewDocumentFromReader(strings.NewReader(html))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">description := ExtractDescription(doc)
        headers := ExtractHeaders(sanitized)
        links := ExtractLinks(sanitized, sourceURL)

        // Step 6: Calculate statistics
        plainText := StripMarkdown(markdown)
        wordCount := CountWords(plainText)
        charCount := CountChars(plainText)
        contentHash := calculateHash(markdown)

        // Step 7: Build document
        document := &amp;domain.Document{
                URL:            sourceURL,
                Title:          title,
                Description:    description,
                Content:        markdown,
                HTMLContent:    html,
                FetchedAt:      time.Now(),
                ContentHash:    contentHash,
                WordCount:      wordCount,
                CharCount:      charCount,
                Links:          links,
                Headers:        headers,
                RenderedWithJS: false,
                SourceStrategy: "",
                CacheHit:       false,
        }

        return document, nil</span>
}

// calculateHash calculates SHA256 hash of content
func calculateHash(content string) string <span class="cov8" title="1">{
        hash := sha256.Sum256([]byte(content))
        return hex.EncodeToString(hash[:])
}</span>

// ConvertHTML is a convenience function for simple HTML to Markdown conversion
func ConvertHTML(html, sourceURL string) (*domain.Document, error) <span class="cov8" title="1">{
        pipeline := NewPipeline(PipelineOptions{
                BaseURL: sourceURL,
        })
        return pipeline.Convert(context.Background(), html, sourceURL)
}</span>

// ConvertHTMLWithSelector converts HTML with a specific content selector
func ConvertHTMLWithSelector(html, sourceURL, selector string) (*domain.Document, error) <span class="cov8" title="1">{
        pipeline := NewPipeline(PipelineOptions{
                BaseURL:         sourceURL,
                ContentSelector: selector,
        })
        return pipeline.Convert(context.Background(), html, sourceURL)
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package converter

import (
        "net/url"
        "strings"

        "github.com/PuerkitoBio/goquery"
        "github.com/go-shiori/go-readability"
)

// ExtractContent extracts the main content from HTML
type ExtractContent struct {
        selector string
}

// ExtractOptions contains options for content extraction
type ExtractOptions struct {
        Selector string // CSS selector for main content
        URL      string // Source URL for resolving relative links
}

// NewExtractContent creates a new content extractor
func NewExtractContent(selector string) *ExtractContent <span class="cov8" title="1">{
        return &amp;ExtractContent{selector: selector}
}</span>

// Extract extracts main content from HTML
func (e *ExtractContent) Extract(html, sourceURL string) (string, string, error) <span class="cov8" title="1">{
        // If a selector is provided, use it directly
        if e.selector != "" </span><span class="cov8" title="1">{
                return e.extractWithSelector(html, sourceURL)
        }</span>

        // Otherwise, use readability algorithm
        <span class="cov8" title="1">return e.extractWithReadability(html, sourceURL)</span>
}

// extractWithSelector extracts content using a CSS selector
func (e *ExtractContent) extractWithSelector(html, sourceURL string) (string, string, error) <span class="cov8" title="1">{
        doc, err := goquery.NewDocumentFromReader(strings.NewReader(html))
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        // Find the content element
        <span class="cov8" title="1">content := doc.Find(e.selector).First()
        if content.Length() == 0 </span><span class="cov8" title="1">{
                // Fallback to readability if selector doesn't match
                return e.extractWithReadability(html, sourceURL)
        }</span>

        // Get title
        <span class="cov8" title="1">title := extractTitle(doc)

        // Get content HTML
        contentHTML, err := content.Html()
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        <span class="cov8" title="1">return contentHTML, title, nil</span>
}

// extractWithReadability extracts content using the readability algorithm
func (e *ExtractContent) extractWithReadability(html, sourceURL string) (string, string, error) <span class="cov8" title="1">{
        parsedURL, err := url.Parse(sourceURL)
        if err != nil </span><span class="cov0" title="0">{
                parsedURL = &amp;url.URL{Scheme: "https", Host: "example.com"}
        }</span>

        <span class="cov8" title="1">article, err := readability.FromReader(strings.NewReader(html), parsedURL)
        if err != nil </span><span class="cov0" title="0">{
                // If readability fails, try to extract the body
                return e.extractBody(html)
        }</span>

        <span class="cov8" title="1">return article.Content, article.Title, nil</span>
}

// extractBody extracts the body content as a fallback
func (e *ExtractContent) extractBody(html string) (string, string, error) <span class="cov0" title="0">{
        doc, err := goquery.NewDocumentFromReader(strings.NewReader(html))
        if err != nil </span><span class="cov0" title="0">{
                return html, "", nil
        }</span>

        <span class="cov0" title="0">title := extractTitle(doc)

        // Get body content
        body := doc.Find("body")
        if body.Length() == 0 </span><span class="cov0" title="0">{
                return html, title, nil
        }</span>

        <span class="cov0" title="0">bodyHTML, err := body.Html()
        if err != nil </span><span class="cov0" title="0">{
                return html, title, nil
        }</span>

        <span class="cov0" title="0">return bodyHTML, title, nil</span>
}

// extractTitle extracts the page title
func extractTitle(doc *goquery.Document) string <span class="cov8" title="1">{
        // Try &lt;title&gt; tag
        title := strings.TrimSpace(doc.Find("title").First().Text())
        if title != "" </span><span class="cov8" title="1">{
                return title
        }</span>

        // Try &lt;h1&gt; tag
        <span class="cov8" title="1">h1 := strings.TrimSpace(doc.Find("h1").First().Text())
        if h1 != "" </span><span class="cov8" title="1">{
                return h1
        }</span>

        // Try og:title meta tag
        <span class="cov0" title="0">ogTitle, exists := doc.Find("meta[property='og:title']").Attr("content")
        if exists &amp;&amp; ogTitle != "" </span><span class="cov0" title="0">{
                return ogTitle
        }</span>

        <span class="cov0" title="0">return ""</span>
}

// ExtractDescription extracts the page description
func ExtractDescription(doc *goquery.Document) string <span class="cov8" title="1">{
        // Try meta description
        desc, exists := doc.Find("meta[name='description']").Attr("content")
        if exists &amp;&amp; desc != "" </span><span class="cov8" title="1">{
                return strings.TrimSpace(desc)
        }</span>

        // Try og:description
        <span class="cov8" title="1">ogDesc, exists := doc.Find("meta[property='og:description']").Attr("content")
        if exists &amp;&amp; ogDesc != "" </span><span class="cov8" title="1">{
                return strings.TrimSpace(ogDesc)
        }</span>

        <span class="cov8" title="1">return ""</span>
}

// ExtractHeaders extracts all headers from HTML
func ExtractHeaders(html string) map[string][]string <span class="cov8" title="1">{
        headers := make(map[string][]string)

        doc, err := goquery.NewDocumentFromReader(strings.NewReader(html))
        if err != nil </span><span class="cov0" title="0">{
                return headers
        }</span>

        <span class="cov8" title="1">for i := 1; i &lt;= 6; i++ </span><span class="cov8" title="1">{
                tag := string('h') + string('0'+byte(i)) // h1, h2, ..., h6
                doc.Find(tag).Each(func(_ int, sel *goquery.Selection) </span><span class="cov8" title="1">{
                        text := strings.TrimSpace(sel.Text())
                        if text != "" </span><span class="cov8" title="1">{
                                headers[tag] = append(headers[tag], text)
                        }</span>
                })
        }

        <span class="cov8" title="1">return headers</span>
}

// ExtractLinks extracts all links from HTML
func ExtractLinks(html, baseURL string) []string <span class="cov8" title="1">{
        var links []string

        doc, err := goquery.NewDocumentFromReader(strings.NewReader(html))
        if err != nil </span><span class="cov0" title="0">{
                return links
        }</span>

        <span class="cov8" title="1">base, _ := url.Parse(baseURL)

        doc.Find("a[href]").Each(func(_ int, sel *goquery.Selection) </span><span class="cov8" title="1">{
                href, exists := sel.Attr("href")
                if !exists || href == "" </span><span class="cov8" title="1">{
                        return
                }</span>

                // Skip anchors, javascript, mailto
                <span class="cov8" title="1">if strings.HasPrefix(href, "#") ||
                        strings.HasPrefix(href, "javascript:") ||
                        strings.HasPrefix(href, "mailto:") ||
                        strings.HasPrefix(href, "tel:") </span><span class="cov8" title="1">{
                        return
                }</span>

                // Resolve relative URLs
                <span class="cov8" title="1">if base != nil &amp;&amp; !strings.HasPrefix(href, "http") </span><span class="cov8" title="1">{
                        refURL, err := url.Parse(href)
                        if err == nil </span><span class="cov8" title="1">{
                                href = base.ResolveReference(refURL).String()
                        }</span>
                }

                <span class="cov8" title="1">links = append(links, href)</span>
        })

        <span class="cov8" title="1">return links</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package converter

import (
        "net/url"
        "regexp"
        "strings"

        "github.com/PuerkitoBio/goquery"
)

// TagsToRemove are HTML tags that should be completely removed
var TagsToRemove = []string{
        "script",
        "style",
        "noscript",
        "iframe",
        "object",
        "embed",
        "applet",
        "form",
        "input",
        "button",
        "select",
        "textarea",
        "nav",
        "footer",
        "header",
        "aside",
        "advertisement",
        "banner",
}

// ClassesToRemove are CSS classes that indicate non-content elements
var ClassesToRemove = []string{
        "sidebar",
        "navigation",
        "nav",
        "menu",
        "footer",
        "header",
        "banner",
        "advertisement",
        "ad",
        "social",
        "share",
        "comment",
        "comments",
        "related",
        "recommended",
}

// IDsToRemove are element IDs that indicate non-content elements
var IDsToRemove = []string{
        "sidebar",
        "navigation",
        "nav",
        "menu",
        "footer",
        "header",
        "banner",
        "advertisement",
        "comments",
}

// Sanitizer cleans HTML content for conversion
type Sanitizer struct {
        baseURL          string
        removeNavigation bool
        removeComments   bool
}

// SanitizerOptions contains options for the sanitizer
type SanitizerOptions struct {
        BaseURL          string
        RemoveNavigation bool
        RemoveComments   bool
}

// NewSanitizer creates a new sanitizer
func NewSanitizer(opts SanitizerOptions) *Sanitizer <span class="cov8" title="1">{
        return &amp;Sanitizer{
                baseURL:          opts.BaseURL,
                removeNavigation: opts.RemoveNavigation,
                removeComments:   opts.RemoveComments,
        }
}</span>

// Sanitize cleans HTML content
func (s *Sanitizer) Sanitize(html string) (string, error) <span class="cov8" title="1">{
        doc, err := goquery.NewDocumentFromReader(strings.NewReader(html))
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Remove unwanted tags
        <span class="cov8" title="1">for _, tag := range TagsToRemove </span><span class="cov8" title="1">{
                doc.Find(tag).Remove()
        }</span>

        // Remove elements by class
        <span class="cov8" title="1">if s.removeNavigation </span><span class="cov8" title="1">{
                for _, class := range ClassesToRemove </span><span class="cov8" title="1">{
                        doc.Find("." + class).Remove()
                        doc.Find("[class*='" + class + "']").Remove()
                }</span>

                // Remove elements by ID
                <span class="cov8" title="1">for _, id := range IDsToRemove </span><span class="cov8" title="1">{
                        doc.Find("#" + id).Remove()
                }</span>
        }

        // Remove hidden elements
        <span class="cov8" title="1">doc.Find("[style*='display:none']").Remove()
        doc.Find("[style*='display: none']").Remove()
        doc.Find("[hidden]").Remove()

        // Normalize URLs if base URL is provided
        if s.baseURL != "" </span><span class="cov8" title="1">{
                s.normalizeURLs(doc)
        }</span>

        // Remove empty paragraphs and divs
        <span class="cov8" title="1">s.removeEmptyElements(doc)

        // Get cleaned HTML
        result, err := doc.Html()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}

// normalizeURLs converts relative URLs to absolute URLs
func (s *Sanitizer) normalizeURLs(doc *goquery.Document) <span class="cov8" title="1">{
        base, err := url.Parse(s.baseURL)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Normalize href attributes
        <span class="cov8" title="1">doc.Find("a[href]").Each(func(_ int, sel *goquery.Selection) </span><span class="cov8" title="1">{
                if href, exists := sel.Attr("href"); exists </span><span class="cov8" title="1">{
                        if absoluteURL := resolveURL(base, href); absoluteURL != "" </span><span class="cov8" title="1">{
                                sel.SetAttr("href", absoluteURL)
                        }</span>
                }
        })

        // Normalize src attributes
        <span class="cov8" title="1">doc.Find("[src]").Each(func(_ int, sel *goquery.Selection) </span><span class="cov8" title="1">{
                if src, exists := sel.Attr("src"); exists </span><span class="cov8" title="1">{
                        if absoluteURL := resolveURL(base, src); absoluteURL != "" </span><span class="cov8" title="1">{
                                sel.SetAttr("src", absoluteURL)
                        }</span>
                }
        })

        // Normalize srcset attributes
        <span class="cov8" title="1">doc.Find("[srcset]").Each(func(_ int, sel *goquery.Selection) </span><span class="cov8" title="1">{
                if srcset, exists := sel.Attr("srcset"); exists </span><span class="cov8" title="1">{
                        sel.SetAttr("srcset", normalizeSrcset(base, srcset))
                }</span>
        })
}

// resolveURL resolves a relative URL against a base URL
func resolveURL(base *url.URL, ref string) string <span class="cov8" title="1">{
        // Skip empty, fragment, javascript, mailto, and data URLs
        if ref == "" || strings.HasPrefix(ref, "#") ||
                strings.HasPrefix(ref, "javascript:") ||
                strings.HasPrefix(ref, "mailto:") ||
                strings.HasPrefix(ref, "data:") </span><span class="cov8" title="1">{
                return ref
        }</span>

        <span class="cov8" title="1">refURL, err := url.Parse(ref)
        if err != nil </span><span class="cov0" title="0">{
                return ref
        }</span>

        <span class="cov8" title="1">return base.ResolveReference(refURL).String()</span>
}

// normalizeSrcset normalizes URLs in srcset attribute
func normalizeSrcset(base *url.URL, srcset string) string <span class="cov8" title="1">{
        parts := strings.Split(srcset, ",")
        for i, part := range parts </span><span class="cov8" title="1">{
                part = strings.TrimSpace(part)
                tokens := strings.Fields(part)
                if len(tokens) &gt; 0 </span><span class="cov8" title="1">{
                        tokens[0] = resolveURL(base, tokens[0])
                        parts[i] = strings.Join(tokens, " ")
                }</span>
        }
        <span class="cov8" title="1">return strings.Join(parts, ", ")</span>
}

// removeEmptyElements removes empty block elements
func (s *Sanitizer) removeEmptyElements(doc *goquery.Document) <span class="cov8" title="1">{
        emptyTags := []string{"p", "div", "span", "section", "article"}
        whitespaceRegex := regexp.MustCompile(`^\s*$`)

        for _, tag := range emptyTags </span><span class="cov8" title="1">{
                doc.Find(tag).Each(func(_ int, sel *goquery.Selection) </span><span class="cov8" title="1">{
                        text := strings.TrimSpace(sel.Text())
                        if whitespaceRegex.MatchString(text) &amp;&amp; sel.Children().Length() == 0 </span><span class="cov8" title="1">{
                                sel.Remove()
                        }</span>
                })
        }
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package domain

import (
        "errors"
        "fmt"
)

// Sentinel errors
var (
        // ErrNotFound indicates a resource was not found
        ErrNotFound = errors.New("not found")

        // ErrCacheMiss indicates a cache miss
        ErrCacheMiss = errors.New("cache miss")

        // ErrCacheExpired indicates the cached entry has expired
        ErrCacheExpired = errors.New("cache entry expired")

        // ErrRateLimited indicates rate limiting was encountered
        ErrRateLimited = errors.New("rate limited")

        // ErrBlocked indicates the request was blocked (e.g., by Cloudflare)
        ErrBlocked = errors.New("request blocked")

        // ErrTimeout indicates a timeout occurred
        ErrTimeout = errors.New("timeout")

        // ErrInvalidURL indicates an invalid URL was provided
        ErrInvalidURL = errors.New("invalid URL")

        // ErrNoStrategy indicates no strategy can handle the URL
        ErrNoStrategy = errors.New("no strategy found for URL")

        // ErrRenderFailed indicates JavaScript rendering failed
        ErrRenderFailed = errors.New("render failed")

        // ErrConversionFailed indicates HTML to Markdown conversion failed
        ErrConversionFailed = errors.New("conversion failed")

        // ErrWriteFailed indicates writing output failed
        ErrWriteFailed = errors.New("write failed")

        // ErrBrowserNotFound indicates Chrome/Chromium was not found
        ErrBrowserNotFound = errors.New("browser not found")
)

// FetchError represents an error during fetching
type FetchError struct {
        URL        string
        StatusCode int
        Err        error
}

func (e *FetchError) Error() string <span class="cov8" title="1">{
        if e.StatusCode &gt; 0 </span><span class="cov8" title="1">{
                return fmt.Sprintf("fetch error for %s: status %d: %v", e.URL, e.StatusCode, e.Err)
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("fetch error for %s: %v", e.URL, e.Err)</span>
}

func (e *FetchError) Unwrap() error <span class="cov8" title="1">{
        return e.Err
}</span>

// NewFetchError creates a new FetchError
func NewFetchError(url string, statusCode int, err error) *FetchError <span class="cov8" title="1">{
        return &amp;FetchError{
                URL:        url,
                StatusCode: statusCode,
                Err:        err,
        }
}</span>

// RetryableError indicates an error that can be retried
type RetryableError struct {
        Err        error
        RetryAfter int // Seconds to wait before retry, 0 if unknown
}

func (e *RetryableError) Error() string <span class="cov8" title="1">{
        if e.RetryAfter &gt; 0 </span><span class="cov8" title="1">{
                return fmt.Sprintf("retryable error (retry after %ds): %v", e.RetryAfter, e.Err)
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("retryable error: %v", e.Err)</span>
}

func (e *RetryableError) Unwrap() error <span class="cov8" title="1">{
        return e.Err
}</span>

// IsRetryable checks if an error should be retried
func IsRetryable(err error) bool <span class="cov8" title="1">{
        var retryable *RetryableError
        if errors.As(err, &amp;retryable) </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">var fetchErr *FetchError
        if errors.As(err, &amp;fetchErr) </span><span class="cov8" title="1">{
                // Retry on specific status codes
                switch fetchErr.StatusCode </span>{
                case 429, 503, 502, 504:<span class="cov8" title="1">
                        return true</span>
                }
                // Retry on Cloudflare errors
                <span class="cov8" title="1">if fetchErr.StatusCode &gt;= 520 &amp;&amp; fetchErr.StatusCode &lt;= 530 </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return errors.Is(err, ErrRateLimited) || errors.Is(err, ErrTimeout)</span>
}

// ValidationError represents a validation error
type ValidationError struct {
        Field   string
        Message string
}

func (e *ValidationError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("validation error for %s: %s", e.Field, e.Message)
}</span>

// NewValidationError creates a new ValidationError
func NewValidationError(field, message string) *ValidationError <span class="cov8" title="1">{
        return &amp;ValidationError{
                Field:   field,
                Message: message,
        }
}</span>

// StrategyError represents an error in strategy execution
type StrategyError struct {
        Strategy string
        URL      string
        Err      error
}

func (e *StrategyError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("strategy %s failed for %s: %v", e.Strategy, e.URL, e.Err)
}</span>

func (e *StrategyError) Unwrap() error <span class="cov8" title="1">{
        return e.Err
}</span>

// NewStrategyError creates a new StrategyError
func NewStrategyError(strategy, url string, err error) *StrategyError <span class="cov8" title="1">{
        return &amp;StrategyError{
                Strategy: strategy,
                URL:      url,
                Err:      err,
        }
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package domain

import "time"

// Document represents a processed documentation page
type Document struct {
        URL            string              `json:"url"`
        Title          string              `json:"title"`
        Description    string              `json:"description,omitempty"`
        Content        string              `json:"-"` // Markdown content (not in JSON)
        HTMLContent    string              `json:"-"` // Original HTML (not in JSON)
        FetchedAt      time.Time           `json:"fetched_at"`
        ContentHash    string              `json:"content_hash"`
        WordCount      int                 `json:"word_count"`
        CharCount      int                 `json:"char_count"`
        Links          []string            `json:"links,omitempty"`
        Headers        map[string][]string `json:"headers,omitempty"` // h1, h2, h3...
        RenderedWithJS bool                `json:"rendered_with_js"`
        SourceStrategy string              `json:"source_strategy"`
        CacheHit       bool                `json:"cache_hit"`
        RelativePath   string              `json:"-"` // Relative path for Git-sourced files (used for output structure)
}

// Page represents a raw fetched page before conversion
type Page struct {
        URL         string
        Content     []byte
        ContentType string
        StatusCode  int
        FetchedAt   time.Time
        FromCache   bool
        RenderedJS  bool
}

// CacheEntry represents a cached page entry
type CacheEntry struct {
        URL         string    `json:"url"`
        Content     []byte    `json:"content"`
        ContentType string    `json:"content_type"`
        FetchedAt   time.Time `json:"fetched_at"`
        ExpiresAt   time.Time `json:"expires_at"`
}

// SitemapURL represents a URL entry in a sitemap
type SitemapURL struct {
        Loc        string    `xml:"loc"`
        LastMod    time.Time `xml:"-"`
        LastModStr string    `xml:"lastmod"`
        ChangeFreq string    `xml:"changefreq"`
        Priority   float64   `xml:"priority"`
}

// Sitemap represents a parsed sitemap
type Sitemap struct {
        URLs      []SitemapURL
        Sitemaps  []string // For sitemap index files
        IsIndex   bool
        SourceURL string
}

// LLMSLink represents a link parsed from llms.txt
type LLMSLink struct {
        Title string
        URL   string
}

// Metadata represents document metadata for JSON output
type Metadata struct {
        URL            string              `json:"url"`
        Title          string              `json:"title"`
        Description    string              `json:"description,omitempty"`
        FetchedAt      time.Time           `json:"fetched_at"`
        ContentHash    string              `json:"content_hash"`
        WordCount      int                 `json:"word_count"`
        CharCount      int                 `json:"char_count"`
        Links          []string            `json:"links,omitempty"`
        Headers        map[string][]string `json:"headers,omitempty"`
        RenderedWithJS bool                `json:"rendered_with_js"`
        SourceStrategy string              `json:"source_strategy"`
        CacheHit       bool                `json:"cache_hit"`
}

// ToMetadata converts a Document to Metadata
func (d *Document) ToMetadata() *Metadata <span class="cov8" title="1">{
        return &amp;Metadata{
                URL:            d.URL,
                Title:          d.Title,
                Description:    d.Description,
                FetchedAt:      d.FetchedAt,
                ContentHash:    d.ContentHash,
                WordCount:      d.WordCount,
                CharCount:      d.CharCount,
                Links:          d.Links,
                Headers:        d.Headers,
                RenderedWithJS: d.RenderedWithJS,
                SourceStrategy: d.SourceStrategy,
                CacheHit:       d.CacheHit,
        }
}</span>

// Frontmatter represents YAML frontmatter for markdown files
type Frontmatter struct {
        Title      string    `yaml:"title"`
        URL        string    `yaml:"url"`
        Source     string    `yaml:"source"`
        FetchedAt  time.Time `yaml:"fetched_at"`
        RenderedJS bool      `yaml:"rendered_js"`
        WordCount  int       `yaml:"word_count"`
}

// ToFrontmatter converts a Document to Frontmatter
func (d *Document) ToFrontmatter() *Frontmatter <span class="cov8" title="1">{
        return &amp;Frontmatter{
                Title:      d.Title,
                URL:        d.URL,
                Source:     d.SourceStrategy,
                FetchedAt:  d.FetchedAt,
                RenderedJS: d.RenderedWithJS,
                WordCount:  d.WordCount,
        }
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package fetcher

import (
        "context"
        "fmt"
        "io"
        "net/http"
        "net/url"
        "time"

        fhttp "github.com/bogdanfinn/fhttp"
        tls_client "github.com/bogdanfinn/tls-client"
        "github.com/bogdanfinn/tls-client/profiles"
        "github.com/quantmind-br/repodocs-go/internal/domain"
)

// Client is a stealth HTTP client using tls-client
type Client struct {
        tlsClient    tls_client.HttpClient
        userAgent    string
        retrier      *Retrier
        cache        domain.Cache
        cacheEnabled bool
        cacheTTL     time.Duration
}

// ClientOptions contains options for creating a Client
type ClientOptions struct {
        Timeout     time.Duration
        MaxRetries  int
        EnableCache bool
        CacheTTL    time.Duration
        Cache       domain.Cache
        UserAgent   string
        ProxyURL    string
}

// DefaultClientOptions returns default client options
func DefaultClientOptions() ClientOptions <span class="cov0" title="0">{
        return ClientOptions{
                Timeout:     30 * time.Second,
                MaxRetries:  3,
                EnableCache: true,
                CacheTTL:    24 * time.Hour,
                UserAgent:   "",
                ProxyURL:    "",
        }
}</span>

// NewClient creates a new stealth HTTP client
func NewClient(opts ClientOptions) (*Client, error) <span class="cov8" title="1">{
        if opts.Timeout &lt;= 0 </span><span class="cov8" title="1">{
                opts.Timeout = 30 * time.Second
        }</span>

        // TLS client options
        <span class="cov8" title="1">tlsOpts := []tls_client.HttpClientOption{
                tls_client.WithTimeoutSeconds(int(opts.Timeout.Seconds())),
                tls_client.WithClientProfile(profiles.Chrome_131),
                tls_client.WithRandomTLSExtensionOrder(),
                tls_client.WithNotFollowRedirects(),
        }

        if opts.ProxyURL != "" </span><span class="cov0" title="0">{
                tlsOpts = append(tlsOpts, tls_client.WithProxyUrl(opts.ProxyURL))
        }</span>

        <span class="cov8" title="1">tlsClient, err := tls_client.NewHttpClient(tls_client.NewNoopLogger(), tlsOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create tls client: %w", err)
        }</span>

        // Create retrier
        <span class="cov8" title="1">retrier := NewRetrier(RetrierOptions{
                MaxRetries:      opts.MaxRetries,
                InitialInterval: 1 * time.Second,
                MaxInterval:     30 * time.Second,
                Multiplier:      2.0,
        })

        return &amp;Client{
                tlsClient:    tlsClient,
                userAgent:    opts.UserAgent,
                retrier:      retrier,
                cache:        opts.Cache,
                cacheEnabled: opts.EnableCache,
                cacheTTL:     opts.CacheTTL,
        }, nil</span>
}

// Get fetches content from a URL
func (c *Client) Get(ctx context.Context, url string) (*domain.Response, error) <span class="cov8" title="1">{
        return c.GetWithHeaders(ctx, url, nil)
}</span>

// GetWithHeaders fetches content with custom headers
func (c *Client) GetWithHeaders(ctx context.Context, url string, extraHeaders map[string]string) (*domain.Response, error) <span class="cov8" title="1">{
        // Check cache first
        if c.cacheEnabled &amp;&amp; c.cache != nil </span><span class="cov8" title="1">{
                cached, err := c.getFromCache(ctx, url)
                if err == nil &amp;&amp; cached != nil </span><span class="cov8" title="1">{
                        return cached, nil
                }</span>
        }

        // Perform request with retry
        <span class="cov8" title="1">var resp *domain.Response
        err := c.retrier.Retry(ctx, func() error </span><span class="cov8" title="1">{
                var err error
                resp, err = c.doRequest(ctx, url, extraHeaders)
                return err
        }</span>)

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Cache the response
        <span class="cov8" title="1">if c.cacheEnabled &amp;&amp; c.cache != nil &amp;&amp; resp != nil </span><span class="cov0" title="0">{
                _ = c.saveToCache(ctx, url, resp)
        }</span>

        <span class="cov8" title="1">return resp, nil</span>
}

// doRequest performs the actual HTTP request
func (c *Client) doRequest(ctx context.Context, targetURL string, extraHeaders map[string]string) (*domain.Response, error) <span class="cov8" title="1">{
        // Create request using fhttp (tls-client's http package)
        req, err := fhttp.NewRequest(fhttp.MethodGet, targetURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        // Apply stealth headers
        <span class="cov8" title="1">headers := StealthHeaders(c.userAgent)
        for k, v := range headers </span><span class="cov8" title="1">{
                req.Header.Set(k, v)
        }</span>

        // Apply extra headers
        <span class="cov8" title="1">for k, v := range extraHeaders </span><span class="cov8" title="1">{
                req.Header.Set(k, v)
        }</span>

        // Perform request
        <span class="cov8" title="1">resp, err := c.tlsClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, &amp;domain.FetchError{
                        URL: targetURL,
                        Err: fmt.Errorf("request failed: %w", err),
                }
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        // Check for error status codes
        if resp.StatusCode &gt;= 400 </span><span class="cov8" title="1">{
                if ShouldRetryStatus(resp.StatusCode) </span><span class="cov0" title="0">{
                        return nil, &amp;domain.RetryableError{
                                Err:        &amp;domain.FetchError{URL: targetURL, StatusCode: resp.StatusCode, Err: fmt.Errorf("HTTP %d", resp.StatusCode)},
                                RetryAfter: int(ParseRetryAfter(resp.Header.Get("Retry-After")).Seconds()),
                        }
                }</span>
                <span class="cov8" title="1">return nil, &amp;domain.FetchError{
                        URL:        targetURL,
                        StatusCode: resp.StatusCode,
                        Err:        fmt.Errorf("HTTP %d", resp.StatusCode),
                }</span>
        }

        // Read body
        <span class="cov8" title="1">body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response body: %w", err)
        }</span>

        // Convert fhttp.Header to http.Header
        <span class="cov8" title="1">httpHeaders := make(http.Header)
        for k, v := range resp.Header </span><span class="cov8" title="1">{
                httpHeaders[k] = v
        }</span>

        <span class="cov8" title="1">return &amp;domain.Response{
                StatusCode:  resp.StatusCode,
                Body:        body,
                Headers:     httpHeaders,
                ContentType: resp.Header.Get("Content-Type"),
                URL:         targetURL,
                FromCache:   false,
        }, nil</span>
}

// GetCookies returns cookies for a URL (for sharing with renderer)
func (c *Client) GetCookies(rawURL string) []*http.Cookie <span class="cov8" title="1">{
        parsedURL, err := url.Parse(rawURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">cookies := c.tlsClient.GetCookies(parsedURL)
        result := make([]*http.Cookie, len(cookies))
        for i, cookie := range cookies </span><span class="cov0" title="0">{
                result[i] = &amp;http.Cookie{
                        Name:     cookie.Name,
                        Value:    cookie.Value,
                        Path:     cookie.Path,
                        Domain:   cookie.Domain,
                        Expires:  cookie.Expires,
                        Secure:   cookie.Secure,
                        HttpOnly: cookie.HttpOnly,
                }
        }</span>
        <span class="cov8" title="1">return result</span>
}

// Close releases client resources
func (c *Client) Close() error <span class="cov8" title="1">{
        // TLS client doesn't have a Close method, but we keep this for interface compliance
        return nil
}</span>

// getFromCache retrieves a response from cache
func (c *Client) getFromCache(ctx context.Context, url string) (*domain.Response, error) <span class="cov8" title="1">{
        if c.cache == nil </span><span class="cov0" title="0">{
                return nil, domain.ErrCacheMiss
        }</span>

        <span class="cov8" title="1">data, err := c.cache.Get(ctx, url)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;domain.Response{
                StatusCode:  200,
                Body:        data,
                ContentType: "text/html",
                URL:         url,
                FromCache:   true,
        }, nil</span>
}

// saveToCache saves a response to cache
func (c *Client) saveToCache(ctx context.Context, url string, resp *domain.Response) error <span class="cov0" title="0">{
        if c.cache == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return c.cache.Set(ctx, url, resp.Body, c.cacheTTL)</span>
}

// SetCache sets the cache implementation
func (c *Client) SetCache(cache domain.Cache) <span class="cov8" title="1">{
        c.cache = cache
}</span>

// SetCacheEnabled enables or disables caching
func (c *Client) SetCacheEnabled(enabled bool) <span class="cov8" title="1">{
        c.cacheEnabled = enabled
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package fetcher

import (
        "context"
        "time"

        "github.com/cenkalti/backoff/v4"
        "github.com/quantmind-br/repodocs-go/internal/domain"
)

// Retrier handles retry logic with exponential backoff
type Retrier struct {
        maxRetries      int
        initialInterval time.Duration
        maxInterval     time.Duration
        multiplier      float64
}

// RetrierOptions contains options for creating a Retrier
type RetrierOptions struct {
        MaxRetries      int
        InitialInterval time.Duration
        MaxInterval     time.Duration
        Multiplier      float64
}

// DefaultRetrierOptions returns default retrier options
func DefaultRetrierOptions() RetrierOptions <span class="cov8" title="1">{
        return RetrierOptions{
                MaxRetries:      3,
                InitialInterval: 1 * time.Second,
                MaxInterval:     30 * time.Second,
                Multiplier:      2.0,
        }
}</span>

// NewRetrier creates a new Retrier with the given options
func NewRetrier(opts RetrierOptions) *Retrier <span class="cov8" title="1">{
        if opts.MaxRetries &lt;= 0 </span><span class="cov8" title="1">{
                opts.MaxRetries = 3
        }</span>
        <span class="cov8" title="1">if opts.InitialInterval &lt;= 0 </span><span class="cov8" title="1">{
                opts.InitialInterval = 1 * time.Second
        }</span>
        <span class="cov8" title="1">if opts.MaxInterval &lt;= 0 </span><span class="cov8" title="1">{
                opts.MaxInterval = 30 * time.Second
        }</span>
        <span class="cov8" title="1">if opts.Multiplier &lt;= 0 </span><span class="cov8" title="1">{
                opts.Multiplier = 2.0
        }</span>

        <span class="cov8" title="1">return &amp;Retrier{
                maxRetries:      opts.MaxRetries,
                initialInterval: opts.InitialInterval,
                maxInterval:     opts.MaxInterval,
                multiplier:      opts.Multiplier,
        }</span>
}

// newBackoff creates a new exponential backoff
func (r *Retrier) newBackoff() backoff.BackOff <span class="cov8" title="1">{
        b := backoff.NewExponentialBackOff()
        b.InitialInterval = r.initialInterval
        b.MaxInterval = r.maxInterval
        b.Multiplier = r.multiplier
        b.RandomizationFactor = 0.5
        b.Reset()

        return backoff.WithMaxRetries(b, uint64(r.maxRetries))
}</span>

// Retry executes an operation with exponential backoff
func (r *Retrier) Retry(ctx context.Context, operation func() error) error <span class="cov8" title="1">{
        b := r.newBackoff()
        b = backoff.WithContext(b, ctx)

        return backoff.Retry(func() error </span><span class="cov8" title="1">{
                err := operation()
                if err == nil </span><span class="cov8" title="1">{
                        return nil
                }</span>

                // Check if error is retryable
                <span class="cov8" title="1">if !domain.IsRetryable(err) </span><span class="cov8" title="1">{
                        return backoff.Permanent(err)
                }</span>

                <span class="cov8" title="1">return err</span>
        }, b)
}

// RetryWithValue executes an operation with exponential backoff and returns a value
func RetryWithValue[T any](ctx context.Context, r *Retrier, operation func() (T, error)) (T, error) <span class="cov8" title="1">{
        var result T
        var lastErr error

        b := r.newBackoff()
        b = backoff.WithContext(b, ctx)

        err := backoff.Retry(func() error </span><span class="cov8" title="1">{
                var err error
                result, err = operation()
                if err == nil </span><span class="cov8" title="1">{
                        return nil
                }</span>

                <span class="cov8" title="1">lastErr = err

                // Check if error is retryable
                if !domain.IsRetryable(err) </span><span class="cov0" title="0">{
                        return backoff.Permanent(err)
                }</span>

                <span class="cov8" title="1">return err</span>
        }, b)

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return result, lastErr
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}

// ShouldRetryStatus returns true if the HTTP status code should be retried
func ShouldRetryStatus(statusCode int) bool <span class="cov8" title="1">{
        switch statusCode </span>{
        case 429:<span class="cov8" title="1"> // Too Many Requests
                return true</span>
        case 502:<span class="cov8" title="1"> // Bad Gateway
                return true</span>
        case 503:<span class="cov8" title="1"> // Service Unavailable
                return true</span>
        case 504:<span class="cov8" title="1"> // Gateway Timeout
                return true</span>
        }

        // Cloudflare errors (520-530)
        <span class="cov8" title="1">if statusCode &gt;= 520 &amp;&amp; statusCode &lt;= 530 </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">return false</span>
}

// ParseRetryAfter parses the Retry-After header value
func ParseRetryAfter(retryAfter string) time.Duration <span class="cov8" title="1">{
        if retryAfter == "" </span><span class="cov8" title="1">{
                return 0
        }</span>

        // Try to parse as seconds
        <span class="cov8" title="1">var seconds int
        if _, err := parseRetryAfterInt(retryAfter, &amp;seconds); err == nil &amp;&amp; seconds &gt; 0 </span><span class="cov8" title="1">{
                return time.Duration(seconds) * time.Second
        }</span>

        // Try to parse as HTTP date (simplified)
        // Full parsing would use time.Parse with HTTP date format
        <span class="cov8" title="1">return 0</span>
}

// parseRetryAfterInt is a helper to parse retry-after as int
func parseRetryAfterInt(s string, result *int) (int, error) <span class="cov8" title="1">{
        n := 0
        for _, c := range s </span><span class="cov8" title="1">{
                if c &lt; '0' || c &gt; '9' </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">n = n*10 + int(c-'0')</span>
        }
        <span class="cov8" title="1">*result = n
        return n, nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package fetcher

import (
        "math/rand"
        "time"
)

// UserAgents is a pool of real Chrome/Firefox/Safari user agents
var UserAgents = []string{
        // Chrome on Windows
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Safari/537.36",
        // Chrome on macOS
        "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36",
        "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36",
        // Chrome on Linux
        "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36",
        "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36",
        // Firefox on Windows
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:132.0) Gecko/20100101 Firefox/132.0",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:131.0) Gecko/20100101 Firefox/131.0",
        // Firefox on macOS
        "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:132.0) Gecko/20100101 Firefox/132.0",
        "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:131.0) Gecko/20100101 Firefox/131.0",
        // Firefox on Linux
        "Mozilla/5.0 (X11; Linux x86_64; rv:132.0) Gecko/20100101 Firefox/132.0",
        "Mozilla/5.0 (X11; Linux x86_64; rv:131.0) Gecko/20100101 Firefox/131.0",
        // Safari on macOS
        "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.6 Safari/605.1.15",
        "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.5 Safari/605.1.15",
        // Edge on Windows
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36 Edg/131.0.0.0",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36 Edg/130.0.0.0",
}

// AcceptLanguages are common Accept-Language header values
var AcceptLanguages = []string{
        "en-US,en;q=0.9",
        "en-GB,en;q=0.9,en-US;q=0.8",
        "en-US,en;q=0.9,es;q=0.8",
        "en-US,en;q=0.9,de;q=0.8",
        "en-US,en;q=0.9,fr;q=0.8",
        "en,en-US;q=0.9",
}

// SecChUaPlatforms are Sec-CH-UA-Platform header values
var SecChUaPlatforms = []string{
        `"Windows"`,
        `"macOS"`,
        `"Linux"`,
}

// init seeds the random number generator
func init() <span class="cov8" title="1">{
        rand.Seed(time.Now().UnixNano())
}</span>

// RandomUserAgent returns a random user agent from the pool
func RandomUserAgent() string <span class="cov8" title="1">{
        return UserAgents[rand.Intn(len(UserAgents))]
}</span>

// RandomAcceptLanguage returns a random Accept-Language header value
func RandomAcceptLanguage() string <span class="cov8" title="1">{
        return AcceptLanguages[rand.Intn(len(AcceptLanguages))]
}</span>

// RandomSecChUaPlatform returns a random Sec-CH-UA-Platform header value
func RandomSecChUaPlatform() string <span class="cov8" title="1">{
        return SecChUaPlatforms[rand.Intn(len(SecChUaPlatforms))]
}</span>

// StealthHeaders returns a map of stealth headers for HTTP requests
func StealthHeaders(userAgent string) map[string]string <span class="cov8" title="1">{
        if userAgent == "" </span><span class="cov8" title="1">{
                userAgent = RandomUserAgent()
        }</span>

        <span class="cov8" title="1">headers := map[string]string{
                "User-Agent":                userAgent,
                "Accept":                    "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8",
                "Accept-Language":           RandomAcceptLanguage(),
                "Accept-Encoding":           "gzip, deflate, br",
                "Cache-Control":             "no-cache",
                "Pragma":                    "no-cache",
                "Sec-Fetch-Dest":            "document",
                "Sec-Fetch-Mode":            "navigate",
                "Sec-Fetch-Site":            "none",
                "Sec-Fetch-User":            "?1",
                "Upgrade-Insecure-Requests": "1",
        }

        // Add Chrome-specific headers if using Chrome UA
        if isChrome(userAgent) </span><span class="cov8" title="1">{
                headers["Sec-CH-UA"] = `"Google Chrome";v="131", "Chromium";v="131", "Not_A Brand";v="24"`
                headers["Sec-CH-UA-Mobile"] = "?0"
                headers["Sec-CH-UA-Platform"] = RandomSecChUaPlatform()
        }</span>

        <span class="cov8" title="1">return headers</span>
}

// isChrome checks if the user agent is Chrome
func isChrome(userAgent string) bool <span class="cov8" title="1">{
        return len(userAgent) &gt; 0 &amp;&amp; (contains(userAgent, "Chrome") || contains(userAgent, "Chromium"))
}</span>

// contains is a simple string contains check
func contains(s, substr string) bool <span class="cov8" title="1">{
        for i := 0; i &lt;= len(s)-len(substr); i++ </span><span class="cov8" title="1">{
                if s[i:i+len(substr)] == substr </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// RandomDelay returns a random delay between min and max duration
func RandomDelay(min, max time.Duration) time.Duration <span class="cov0" title="0">{
        if min &gt;= max </span><span class="cov0" title="0">{
                return min
        }</span>
        <span class="cov0" title="0">delta := max - min
        return min + time.Duration(rand.Int63n(int64(delta)))</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package fetcher

import (
        "bytes"
        "io"
        "net/http"
)

// StealthTransport is an http.RoundTripper that uses the stealth client
// This allows integration with Colly and other HTTP client libraries
type StealthTransport struct {
        client *Client
}

// NewStealthTransport creates a new StealthTransport
func NewStealthTransport(client *Client) *StealthTransport <span class="cov8" title="1">{
        return &amp;StealthTransport{client: client}
}</span>

// RoundTrip implements http.RoundTripper
func (t *StealthTransport) RoundTrip(req *http.Request) (*http.Response, error) <span class="cov8" title="1">{
        // Extract headers from request
        extraHeaders := make(map[string]string)
        for k, v := range req.Header </span><span class="cov8" title="1">{
                if len(v) &gt; 0 </span><span class="cov8" title="1">{
                        extraHeaders[k] = v[0]
                }</span>
        }

        // Use the stealth client to make the request
        <span class="cov8" title="1">resp, err := t.client.GetWithHeaders(req.Context(), req.URL.String(), extraHeaders)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Convert domain.Response to http.Response
        <span class="cov8" title="1">return &amp;http.Response{
                Status:        http.StatusText(resp.StatusCode),
                StatusCode:    resp.StatusCode,
                Proto:         "HTTP/1.1",
                ProtoMajor:    1,
                ProtoMinor:    1,
                Header:        resp.Headers,
                Body:          io.NopCloser(bytes.NewReader(resp.Body)),
                ContentLength: int64(len(resp.Body)),
                Request:       req,
        }, nil</span>
}

// Transport returns the StealthTransport as http.RoundTripper
func (c *Client) Transport() http.RoundTripper <span class="cov8" title="1">{
        return NewStealthTransport(c)
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package output

import (
        "context"
        "encoding/json"
        "os"
        "path/filepath"

        "github.com/quantmind-br/repodocs-go/internal/converter"
        "github.com/quantmind-br/repodocs-go/internal/domain"
        "github.com/quantmind-br/repodocs-go/internal/utils"
)

// Writer handles writing documents to the filesystem
type Writer struct {
        baseDir      string
        flat         bool
        jsonMetadata bool
        force        bool
        dryRun       bool
}

// WriterOptions contains options for the writer
type WriterOptions struct {
        BaseDir      string
        Flat         bool
        JSONMetadata bool
        Force        bool
        DryRun       bool
}

// NewWriter creates a new output writer
func NewWriter(opts WriterOptions) *Writer <span class="cov8" title="1">{
        if opts.BaseDir == "" </span><span class="cov8" title="1">{
                opts.BaseDir = "./docs"
        }</span>

        <span class="cov8" title="1">return &amp;Writer{
                baseDir:      opts.BaseDir,
                flat:         opts.Flat,
                jsonMetadata: opts.JSONMetadata,
                force:        opts.Force,
                dryRun:       opts.DryRun,
        }</span>
}

// Write saves a document to the output directory
func (w *Writer) Write(ctx context.Context, doc *domain.Document) error <span class="cov8" title="1">{
        // Generate path
        var path string
        if doc.RelativePath != "" </span><span class="cov8" title="1">{
                // For Git-sourced files, use the relative path directly
                path = utils.GeneratePathFromRelative(w.baseDir, doc.RelativePath, w.flat)
        }</span> else<span class="cov8" title="1"> {
                // For other sources, generate path from URL
                path = utils.GeneratePath(w.baseDir, doc.URL, w.flat)
        }</span>

        // Check if file exists
        <span class="cov8" title="1">if !w.force </span><span class="cov8" title="1">{
                if _, err := os.Stat(path); err == nil </span><span class="cov8" title="1">{
                        // File exists, skip
                        return nil
                }</span>
        }

        // Dry run - just return
        <span class="cov8" title="1">if w.dryRun </span><span class="cov8" title="1">{
                return nil
        }</span>

        // Ensure directory exists
        <span class="cov8" title="1">if err := utils.EnsureDir(path); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Add frontmatter
        <span class="cov8" title="1">content, err := converter.AddFrontmatter(doc.Content, doc)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Write markdown file
        <span class="cov8" title="1">if err := os.WriteFile(path, []byte(content), 0644); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Write JSON metadata if enabled
        <span class="cov8" title="1">if w.jsonMetadata </span><span class="cov8" title="1">{
                jsonPath := utils.JSONPath(path)
                if err := w.writeJSON(jsonPath, doc); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// writeJSON writes JSON metadata
func (w *Writer) writeJSON(path string, doc *domain.Document) error <span class="cov8" title="1">{
        metadata := doc.ToMetadata()

        data, err := json.MarshalIndent(metadata, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return os.WriteFile(path, data, 0644)</span>
}

// WriteMultiple writes multiple documents
func (w *Writer) WriteMultiple(ctx context.Context, docs []*domain.Document) error <span class="cov8" title="1">{
        for _, doc := range docs </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        return ctx.Err()</span>
                default:<span class="cov8" title="1">
                        if err := w.Write(ctx, doc); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// GetPath returns the output path for a URL
func (w *Writer) GetPath(url string) string <span class="cov8" title="1">{
        return utils.GeneratePath(w.baseDir, url, w.flat)
}</span>

// Exists checks if a document already exists
func (w *Writer) Exists(url string) bool <span class="cov8" title="1">{
        path := w.GetPath(url)
        _, err := os.Stat(path)
        return err == nil
}</span>

// EnsureBaseDir creates the base directory if it doesn't exist
func (w *Writer) EnsureBaseDir() error <span class="cov8" title="1">{
        return os.MkdirAll(w.baseDir, 0755)
}</span>

// Clean removes the output directory
func (w *Writer) Clean() error <span class="cov8" title="1">{
        return os.RemoveAll(w.baseDir)
}</span>

// Stats returns statistics about the output directory
func (w *Writer) Stats() (int, int64, error) <span class="cov8" title="1">{
        var count int
        var size int64

        err := filepath.Walk(w.baseDir, func(path string, info os.FileInfo, err error) error </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if !info.IsDir() &amp;&amp; filepath.Ext(path) == ".md" </span><span class="cov8" title="1">{
                        count++
                        size += info.Size()
                }</span>
                <span class="cov8" title="1">return nil</span>
        })

        <span class="cov8" title="1">return count, size, err</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package renderer

import (
        "regexp"
        "strings"
)

// SPA detection patterns
var (
        // React patterns
        reactPatterns = []string{
                `&lt;div id="root"&gt;&lt;/div&gt;`,
                `&lt;div id="root"/&gt;`,
                `&lt;div id="app"&gt;&lt;/div&gt;`,
                `&lt;div id="app"/&gt;`,
                `data-reactroot`,
                `__REACT_DEVTOOLS_GLOBAL_HOOK__`,
        }

        // Vue patterns
        vuePatterns = []string{
                `&lt;div id="app"&gt;&lt;/div&gt;`,
                `&lt;div id="app"/&gt;`,
                `__VUE__`,
                `v-cloak`,
                `Vue.createApp`,
        }

        // Next.js patterns
        nextPatterns = []string{
                `&lt;div id="__next"&gt;&lt;/div&gt;`,
                `&lt;div id="__next"/&gt;`,
                `__NEXT_DATA__`,
                `_next/static`,
        }

        // Nuxt patterns
        nuxtPatterns = []string{
                `__NUXT__`,
                `window.__NUXT__`,
                `&lt;div id="__nuxt"&gt;`,
        }

        // Angular patterns
        angularPatterns = []string{
                `ng-version`,
                `ng-app`,
                `ng-controller`,
                `&lt;app-root&gt;`,
        }

        // Svelte patterns
        sveltePatterns = []string{
                `__svelte`,
                `svelte-`,
        }

        // Generic SPA indicators
        spaIndicators = []string{
                `window.__INITIAL_STATE__`,
                `window.__STATE__`,
                `window.__PRELOADED_STATE__`,
        }
)

// contentMinLength is the minimum content length to consider a page as rendered
const contentMinLength = 500

// scriptTagRegex matches script tags
var scriptTagRegex = regexp.MustCompile(`&lt;script[^&gt;]*&gt;[\s\S]*?&lt;/script&gt;`)

// htmlTagRegex matches HTML tags
var htmlTagRegex = regexp.MustCompile(`&lt;[^&gt;]+&gt;`)

// NeedsJSRendering detects if a page needs JavaScript rendering
func NeedsJSRendering(html string) bool <span class="cov8" title="1">{
        // Check for SPA framework patterns
        if hasSPAPattern(html) </span><span class="cov8" title="1">{
                return true
        }</span>

        // Check content length without scripts
        <span class="cov8" title="1">contentWithoutScripts := scriptTagRegex.ReplaceAllString(html, "")
        textContent := htmlTagRegex.ReplaceAllString(contentWithoutScripts, "")
        textContent = strings.TrimSpace(textContent)

        // If there's very little content but many scripts, likely a SPA
        if len(textContent) &lt; contentMinLength </span><span class="cov8" title="1">{
                scriptCount := strings.Count(strings.ToLower(html), "&lt;script")
                if scriptCount &gt; 3 </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}

// hasSPAPattern checks if the HTML contains any SPA framework patterns
func hasSPAPattern(html string) bool <span class="cov8" title="1">{
        htmlLower := strings.ToLower(html)

        allPatterns := append([]string{}, reactPatterns...)
        allPatterns = append(allPatterns, vuePatterns...)
        allPatterns = append(allPatterns, nextPatterns...)
        allPatterns = append(allPatterns, nuxtPatterns...)
        allPatterns = append(allPatterns, angularPatterns...)
        allPatterns = append(allPatterns, sveltePatterns...)
        allPatterns = append(allPatterns, spaIndicators...)

        for _, pattern := range allPatterns </span><span class="cov8" title="1">{
                if strings.Contains(htmlLower, strings.ToLower(pattern)) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}

// DetectFramework attempts to detect which SPA framework is being used
func DetectFramework(html string) string <span class="cov8" title="1">{
        htmlLower := strings.ToLower(html)

        for _, pattern := range nextPatterns </span><span class="cov8" title="1">{
                if strings.Contains(htmlLower, strings.ToLower(pattern)) </span><span class="cov8" title="1">{
                        return "Next.js"
                }</span>
        }

        <span class="cov8" title="1">for _, pattern := range nuxtPatterns </span><span class="cov8" title="1">{
                if strings.Contains(htmlLower, strings.ToLower(pattern)) </span><span class="cov8" title="1">{
                        return "Nuxt"
                }</span>
        }

        <span class="cov8" title="1">for _, pattern := range reactPatterns </span><span class="cov8" title="1">{
                if strings.Contains(htmlLower, strings.ToLower(pattern)) </span><span class="cov8" title="1">{
                        return "React"
                }</span>
        }

        <span class="cov8" title="1">for _, pattern := range vuePatterns </span><span class="cov8" title="1">{
                if strings.Contains(htmlLower, strings.ToLower(pattern)) </span><span class="cov8" title="1">{
                        return "Vue"
                }</span>
        }

        <span class="cov8" title="1">for _, pattern := range angularPatterns </span><span class="cov8" title="1">{
                if strings.Contains(htmlLower, strings.ToLower(pattern)) </span><span class="cov8" title="1">{
                        return "Angular"
                }</span>
        }

        <span class="cov8" title="1">for _, pattern := range sveltePatterns </span><span class="cov8" title="1">{
                if strings.Contains(htmlLower, strings.ToLower(pattern)) </span><span class="cov8" title="1">{
                        return "Svelte"
                }</span>
        }

        <span class="cov8" title="1">return "Unknown"</span>
}

// HasDynamicContent checks for indicators of dynamic content loading
func HasDynamicContent(html string) bool <span class="cov8" title="1">{
        indicators := []string{
                "loading...",
                "loading",
                "please wait",
                "spinner",
                "skeleton",
                "lazy-load",
                "lazyload",
                "infinite-scroll",
        }

        htmlLower := strings.ToLower(html)
        for _, indicator := range indicators </span><span class="cov8" title="1">{
                if strings.Contains(htmlLower, indicator) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package renderer

import (
        "context"
        "sync"

        "github.com/go-rod/rod"
)

// TabPool manages a pool of browser tabs for concurrent rendering
type TabPool struct {
        browser    *rod.Browser
        maxTabs    int
        activeTabs chan *rod.Page
        mu         sync.Mutex
        closed     bool
}

// NewTabPool creates a new tab pool
func NewTabPool(browser *rod.Browser, maxTabs int) (*TabPool, error) <span class="cov8" title="1">{
        if maxTabs &lt;= 0 </span><span class="cov0" title="0">{
                maxTabs = 5
        }</span>

        <span class="cov8" title="1">pool := &amp;TabPool{
                browser:    browser,
                maxTabs:    maxTabs,
                activeTabs: make(chan *rod.Page, maxTabs),
        }

        // Pre-create tabs
        for i := 0; i &lt; maxTabs; i++ </span><span class="cov8" title="1">{
                page, err := StealthPage(browser)
                if err != nil </span><span class="cov0" title="0">{
                        pool.Close()
                        return nil, err
                }</span>
                <span class="cov8" title="1">pool.activeTabs &lt;- page</span>
        }

        <span class="cov8" title="1">return pool, nil</span>
}

// Acquire gets a page from the pool, blocking if none available
func (p *TabPool) Acquire(ctx context.Context) (*rod.Page, error) <span class="cov8" title="1">{
        p.mu.Lock()
        if p.closed </span><span class="cov0" title="0">{
                p.mu.Unlock()
                return nil, ErrPoolClosed
        }</span>
        <span class="cov8" title="1">p.mu.Unlock()

        select </span>{
        case page := &lt;-p.activeTabs:<span class="cov8" title="1">
                return page, nil</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return nil, ctx.Err()</span>
        }
}

// Release returns a page to the pool after cleaning up
func (p *TabPool) Release(page *rod.Page) <span class="cov8" title="1">{
        p.mu.Lock()
        if p.closed </span><span class="cov0" title="0">{
                p.mu.Unlock()
                page.Close()
                return
        }</span>
        <span class="cov8" title="1">p.mu.Unlock()

        // Clean up the page before returning to pool
        _ = page.Navigate("about:blank")

        select </span>{
        case p.activeTabs &lt;- page:<span class="cov8" title="1"></span>
                // Successfully returned to pool
        default:<span class="cov0" title="0">
                // Pool is full (shouldn't happen normally)
                page.Close()</span>
        }
}

// Close closes all tabs and the pool
func (p *TabPool) Close() error <span class="cov8" title="1">{
        p.mu.Lock()
        if p.closed </span><span class="cov8" title="1">{
                p.mu.Unlock()
                return nil
        }</span>
        <span class="cov8" title="1">p.closed = true
        p.mu.Unlock()

        close(p.activeTabs)

        // Close remaining pages
        for page := range p.activeTabs </span><span class="cov8" title="1">{
                page.Close()
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Size returns the current number of available tabs
func (p *TabPool) Size() int <span class="cov8" title="1">{
        return len(p.activeTabs)
}</span>

// MaxSize returns the maximum pool size
func (p *TabPool) MaxSize() int <span class="cov8" title="1">{
        return p.maxTabs
}</span>

// ErrPoolClosed is returned when trying to acquire from a closed pool
var ErrPoolClosed = &amp;poolError{message: "pool is closed"}

type poolError struct {
        message string
}

func (e *poolError) Error() string <span class="cov8" title="1">{
        return e.message
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package renderer

import (
        "context"
        "fmt"
        "net/http"
        "net/url"
        "time"

        "github.com/go-rod/rod"
        "github.com/go-rod/rod/lib/launcher"
        "github.com/go-rod/rod/lib/proto"
        "github.com/quantmind-br/repodocs-go/internal/domain"
)

// Renderer provides JavaScript rendering using headless Chrome
type Renderer struct {
        browser  *rod.Browser
        pool     *TabPool
        timeout  time.Duration
        stealth  bool
        headless bool
}

// RendererOptions contains options for creating a Renderer
type RendererOptions struct {
        Timeout     time.Duration
        MaxTabs     int
        Stealth     bool
        Headless    bool
        BrowserPath string
}

// DefaultRendererOptions returns default renderer options
func DefaultRendererOptions() RendererOptions <span class="cov8" title="1">{
        return RendererOptions{
                Timeout:     60 * time.Second,
                MaxTabs:     5,
                Stealth:     true,
                Headless:    true,
                BrowserPath: "",
        }
}</span>

// NewRenderer creates a new headless browser renderer
func NewRenderer(opts RendererOptions) (*Renderer, error) <span class="cov8" title="1">{
        if opts.Timeout &lt;= 0 </span><span class="cov0" title="0">{
                opts.Timeout = 60 * time.Second
        }</span>
        <span class="cov8" title="1">if opts.MaxTabs &lt;= 0 </span><span class="cov0" title="0">{
                opts.MaxTabs = 5
        }</span>

        // Create launcher
        <span class="cov8" title="1">l := launcher.New()

        if opts.BrowserPath != "" </span><span class="cov0" title="0">{
                l = l.Bin(opts.BrowserPath)
        }</span>

        <span class="cov8" title="1">if opts.Headless </span><span class="cov8" title="1">{
                l = l.Headless(true)
        }</span>

        // Additional flags for stealth
        <span class="cov8" title="1">if opts.Stealth </span><span class="cov8" title="1">{
                l = l.Set("disable-blink-features", "AutomationControlled")
        }</span>

        // Launch browser
        <span class="cov8" title="1">controlURL, err := l.Launch()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to launch browser: %w", err)
        }</span>

        <span class="cov8" title="1">browser := rod.New().ControlURL(controlURL)
        if err := browser.Connect(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to browser: %w", err)
        }</span>

        // Create tab pool
        <span class="cov8" title="1">pool, err := NewTabPool(browser, opts.MaxTabs)
        if err != nil </span><span class="cov0" title="0">{
                browser.Close()
                return nil, fmt.Errorf("failed to create tab pool: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;Renderer{
                browser:  browser,
                pool:     pool,
                timeout:  opts.Timeout,
                stealth:  opts.Stealth,
                headless: opts.Headless,
        }, nil</span>
}

// Render fetches and renders a page with JavaScript
func (r *Renderer) Render(ctx context.Context, url string, opts domain.RenderOptions) (string, error) <span class="cov8" title="1">{
        if opts.Timeout &lt;= 0 </span><span class="cov0" title="0">{
                opts.Timeout = r.timeout
        }</span>

        // Create context with timeout
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(ctx, opts.Timeout)
        defer cancel()

        // Acquire a page from the pool
        page, err := r.pool.Acquire(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to acquire page: %w", err)
        }</span>
        <span class="cov8" title="1">defer r.pool.Release(page)

        // Apply context to page so all operations respect the timeout
        page = page.Context(ctx)

        // Apply stealth mode
        if r.stealth </span><span class="cov8" title="1">{
                if err := ApplyStealthMode(page); err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to apply stealth mode: %w", err)
                }</span>
        }

        // Set cookies if provided
        <span class="cov8" title="1">if len(opts.Cookies) &gt; 0 </span><span class="cov8" title="1">{
                if err := r.setCookies(page, url, opts.Cookies); err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to set cookies: %w", err)
                }</span>
        }

        // Navigate to URL
        <span class="cov8" title="1">if err := page.Navigate(url); err != nil </span><span class="cov8" title="1">{
                return "", domain.NewFetchError(url, 0, fmt.Errorf("navigation failed: %w", err))
        }</span>

        // Wait for page to load
        <span class="cov8" title="1">if err := page.WaitLoad(); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed waiting for load: %w", err)
        }</span>

        // Wait for specific selector if provided
        <span class="cov8" title="1">if opts.WaitFor != "" </span><span class="cov8" title="1">{
                if err := page.Timeout(opts.Timeout).MustElement(opts.WaitFor).WaitVisible(); err != nil </span>{<span class="cov0" title="0">
                        // Don't fail, just continue
                }</span>
        }

        // Wait for network to be idle
        <span class="cov8" title="1">if opts.WaitStable &gt; 0 </span><span class="cov8" title="1">{
                if err := page.WaitRequestIdle(opts.WaitStable, nil, nil, nil); err != nil </span>{<span class="cov8" title="1">
                        // Don't fail, just continue
                }</span>
        }

        // Scroll to bottom to load lazy content
        <span class="cov8" title="1">if opts.ScrollToEnd </span><span class="cov8" title="1">{
                if err := r.scrollToEnd(page); err != nil </span>{<span class="cov0" title="0">
                        // Don't fail, just continue
                }</span>
        }

        // Get rendered HTML
        <span class="cov8" title="1">html, err := page.HTML()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get HTML: %w", err)
        }</span>

        <span class="cov8" title="1">return html, nil</span>
}

// setCookies sets cookies on a page
func (r *Renderer) setCookies(page *rod.Page, pageURL string, cookies []*http.Cookie) error <span class="cov8" title="1">{
        // Parse URL to extract domain if cookie domain is empty
        parsedURL, err := url.Parse(pageURL)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse URL for cookies: %w", err)
        }</span>

        <span class="cov8" title="1">for _, cookie := range cookies </span><span class="cov8" title="1">{
                // Use cookie domain if set, otherwise extract from URL
                domain := cookie.Domain
                if domain == "" </span><span class="cov8" title="1">{
                        domain = parsedURL.Hostname()
                }</span>

                // Use cookie path if set, otherwise default to "/"
                <span class="cov8" title="1">path := cookie.Path
                if path == "" </span><span class="cov0" title="0">{
                        path = "/"
                }</span>

                <span class="cov8" title="1">err := page.SetCookies([]*proto.NetworkCookieParam{
                        {
                                Name:     cookie.Name,
                                Value:    cookie.Value,
                                Domain:   domain,
                                Path:     path,
                                Secure:   cookie.Secure,
                                HTTPOnly: cookie.HttpOnly,
                        },
                })
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// scrollToEnd scrolls to the bottom of the page to trigger lazy loading
func (r *Renderer) scrollToEnd(page *rod.Page) error <span class="cov8" title="1">{
        // Get initial scroll height
        result, err := page.Eval(`() =&gt; document.body.scrollHeight`)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">lastHeight := result.Value.Int()

        for i := 0; i &lt; 10; i++ </span><span class="cov8" title="1">{ // Max 10 scroll iterations
                // Scroll to bottom
                _, err := page.Eval(`() =&gt; window.scrollTo(0, document.body.scrollHeight)`)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Wait for content to load
                <span class="cov8" title="1">time.Sleep(500 * time.Millisecond)

                // Check new scroll height
                result, err := page.Eval(`() =&gt; document.body.scrollHeight`)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">newHeight := result.Value.Int()

                // If height hasn't changed, we've reached the bottom
                if newHeight == lastHeight </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov0" title="0">lastHeight = newHeight</span>
        }

        // Scroll back to top
        <span class="cov8" title="1">_, _ = page.Eval(`() =&gt; window.scrollTo(0, 0)`)

        return nil</span>
}

// DefaultRenderOptions returns default render options
func DefaultRenderOptions() domain.RenderOptions <span class="cov8" title="1">{
        return domain.RenderOptions{
                Timeout:     60 * time.Second,
                WaitStable:  2 * time.Second,
                ScrollToEnd: true,
        }
}</span>

// Close releases browser resources
func (r *Renderer) Close() error <span class="cov8" title="1">{
        if r.pool != nil </span><span class="cov8" title="1">{
                r.pool.Close()
        }</span>
        <span class="cov8" title="1">if r.browser != nil </span><span class="cov8" title="1">{
                return r.browser.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// IsAvailable checks if the browser is available
func IsAvailable() bool <span class="cov8" title="1">{
        path, exists := launcher.LookPath()
        return exists &amp;&amp; path != ""
}</span>

// GetBrowserPath returns the detected browser path
func GetBrowserPath() (string, bool) <span class="cov8" title="1">{
        return launcher.LookPath()
}</span>

// GetTabPool returns the tab pool for testing purposes
func (r *Renderer) GetTabPool() (*TabPool, error) <span class="cov8" title="1">{
        if r.pool == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("pool not initialized")
        }</span>
        <span class="cov8" title="1">return r.pool, nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package renderer

import (
        "github.com/go-rod/rod"
        "github.com/go-rod/rod/lib/proto"
        "github.com/go-rod/stealth"
)

// StealthPage creates a new stealth page that's harder to detect as automated
func StealthPage(browser *rod.Browser) (*rod.Page, error) <span class="cov8" title="1">{
        page, err := stealth.Page(browser)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return page, nil</span>
}

// ApplyStealthMode applies stealth mode configurations to a page
// This includes removing webdriver flags and emulating real browser behavior
func ApplyStealthMode(page *rod.Page) error <span class="cov8" title="1">{
        // The stealth package already handles most of this, but we can add extra measures

        // Set a realistic viewport using proto.EmulationSetDeviceMetricsOverride
        err := page.SetViewport(&amp;proto.EmulationSetDeviceMetricsOverride{
                Width:  1920,
                Height: 1080,
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Simple stealth: just hide webdriver flag
        // Rod expects arrow function format: () =&gt; expression
        <span class="cov8" title="1">js := `() =&gt; { Object.defineProperty(navigator, 'webdriver', { get: () =&gt; undefined }); return true; }`
        _, err = page.Eval(js)
        return err</span>
}

// StealthOptions contains options for stealth mode
type StealthOptions struct {
        // HideWebdriver hides the webdriver property
        HideWebdriver bool
        // EmulatePlugins emulates real browser plugins
        EmulatePlugins bool
        // RandomizeViewport randomizes the viewport size
        RandomizeViewport bool
        // DisableAutomationFlags disables Chrome automation flags
        DisableAutomationFlags bool
}

// DefaultStealthOptions returns default stealth options
func DefaultStealthOptions() StealthOptions <span class="cov8" title="1">{
        return StealthOptions{
                HideWebdriver:          true,
                EmulatePlugins:         true,
                RandomizeViewport:      false,
                DisableAutomationFlags: true,
        }
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package strategies

import (
        "context"
        "regexp"
        "strings"
        "sync"
        "time"

        "github.com/gocolly/colly/v2"
        "github.com/quantmind-br/repodocs-go/internal/converter"
        "github.com/quantmind-br/repodocs-go/internal/domain"
        "github.com/quantmind-br/repodocs-go/internal/fetcher"
        "github.com/quantmind-br/repodocs-go/internal/output"
        "github.com/quantmind-br/repodocs-go/internal/renderer"
        "github.com/quantmind-br/repodocs-go/internal/utils"
        "github.com/schollz/progressbar/v3"
)

// CrawlerStrategy crawls websites to extract documentation
type CrawlerStrategy struct {
        fetcher   *fetcher.Client
        renderer  domain.Renderer
        converter *converter.Pipeline
        writer    *output.Writer
        logger    *utils.Logger
}

// NewCrawlerStrategy creates a new crawler strategy
func NewCrawlerStrategy(deps *Dependencies) *CrawlerStrategy <span class="cov8" title="1">{
        return &amp;CrawlerStrategy{
                fetcher:   deps.Fetcher,
                renderer:  deps.Renderer,
                converter: deps.Converter,
                writer:    deps.Writer,
                logger:    deps.Logger,
        }
}</span>

// Name returns the strategy name
func (s *CrawlerStrategy) Name() string <span class="cov8" title="1">{
        return "crawler"
}</span>

// CanHandle returns true if this strategy can handle the given URL
func (s *CrawlerStrategy) CanHandle(url string) bool <span class="cov8" title="1">{
        return utils.IsHTTPURL(url)
}</span>

// Execute runs the crawler extraction strategy
func (s *CrawlerStrategy) Execute(ctx context.Context, url string, opts Options) error <span class="cov8" title="1">{
        s.logger.Info().Str("url", url).Msg("Starting web crawl")

        // Log filter if set
        if opts.FilterURL != "" </span><span class="cov0" title="0">{
                s.logger.Info().Str("filter", opts.FilterURL).Msg("URL filter active - only crawling URLs under this path")
        }</span>

        // Create visited URL tracker
        <span class="cov8" title="1">visited := sync.Map{}
        var processedCount int
        var mu sync.Mutex

        // Compile exclude patterns
        var excludeRegexps []*regexp.Regexp
        for _, pattern := range opts.Exclude </span><span class="cov8" title="1">{
                if re, err := regexp.Compile(pattern); err == nil </span><span class="cov8" title="1">{
                        excludeRegexps = append(excludeRegexps, re)
                }</span>
        }

        // Create colly collector
        <span class="cov8" title="1">c := colly.NewCollector(
                colly.Async(true),
                colly.MaxDepth(opts.MaxDepth),
        )

        // Set transport from fetcher for stealth
        c.WithTransport(s.fetcher.Transport())

        // Configure rate limiting
        _ = c.Limit(&amp;colly.LimitRule{
                DomainGlob:  "*",
                Parallelism: opts.Concurrency,
                RandomDelay: 2 * time.Second,
        })

        // Create progress bar (unknown total)
        bar := progressbar.NewOptions(-1,
                progressbar.OptionSetDescription("Crawling"),
                progressbar.OptionShowCount(),
                progressbar.OptionSpinnerType(14),
        )

        // Handle links
        c.OnHTML("a[href]", func(e *colly.HTMLElement) </span><span class="cov0" title="0">{
                link := e.Request.AbsoluteURL(e.Attr("href"))
                if link == "" </span><span class="cov0" title="0">{
                        return
                }</span>

                // Check if within same domain
                <span class="cov0" title="0">if !utils.IsSameDomain(link, url) </span><span class="cov0" title="0">{
                        return
                }</span>

                // Check base URL filter - only crawl URLs that start with the filter path
                <span class="cov0" title="0">if opts.FilterURL != "" &amp;&amp; !utils.HasBaseURL(link, opts.FilterURL) </span><span class="cov0" title="0">{
                        return
                }</span>

                // Check exclude patterns
                <span class="cov0" title="0">for _, re := range excludeRegexps </span><span class="cov0" title="0">{
                        if re.MatchString(link) </span><span class="cov0" title="0">{
                                return
                        }</span>
                }

                // Check limit
                <span class="cov0" title="0">mu.Lock()
                if opts.Limit &gt; 0 &amp;&amp; processedCount &gt;= opts.Limit </span><span class="cov0" title="0">{
                        mu.Unlock()
                        return
                }</span>
                <span class="cov0" title="0">mu.Unlock()

                // Check if already visited
                if _, exists := visited.LoadOrStore(link, true); exists </span><span class="cov0" title="0">{
                        return
                }</span>

                // Visit the link
                <span class="cov0" title="0">_ = e.Request.Visit(link)</span>
        })

        // Handle page responses
        <span class="cov8" title="1">c.OnResponse(func(r *colly.Response) </span><span class="cov8" title="1">{
                // Check context cancellation
                select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        return</span>
                default:<span class="cov8" title="1"></span>
                }

                // Check content type
                <span class="cov8" title="1">contentType := r.Headers.Get("Content-Type")
                if !isHTMLContentType(contentType) </span><span class="cov0" title="0">{
                        return
                }</span>

                // Check limit
                <span class="cov8" title="1">mu.Lock()
                if opts.Limit &gt; 0 &amp;&amp; processedCount &gt;= opts.Limit </span><span class="cov0" title="0">{
                        mu.Unlock()
                        return
                }</span>
                <span class="cov8" title="1">processedCount++
                mu.Unlock()

                bar.Add(1)

                // Check if already exists
                if !opts.Force &amp;&amp; s.writer.Exists(r.Request.URL.String()) </span><span class="cov0" title="0">{
                        return
                }</span>

                // Get HTML content
                <span class="cov8" title="1">html := string(r.Body)

                // Check if JS rendering is needed
                if opts.RenderJS || renderer.NeedsJSRendering(html) </span><span class="cov0" title="0">{
                        if s.renderer != nil </span><span class="cov0" title="0">{
                                rendered, err := s.renderer.Render(ctx, r.Request.URL.String(), domain.RenderOptions{
                                        Timeout:     60 * time.Second,
                                        WaitStable:  2 * time.Second,
                                        ScrollToEnd: true,
                                })
                                if err == nil </span><span class="cov0" title="0">{
                                        html = rendered
                                }</span>
                        }
                }

                // Convert to document
                <span class="cov8" title="1">doc, err := s.converter.Convert(ctx, html, r.Request.URL.String())
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn().Err(err).Str("url", r.Request.URL.String()).Msg("Failed to convert page")
                        return
                }</span>

                // Set metadata
                <span class="cov8" title="1">doc.SourceStrategy = s.Name()
                doc.FetchedAt = time.Now()

                // Write document
                if !opts.DryRun </span><span class="cov8" title="1">{
                        if err := s.writer.Write(ctx, doc); err != nil </span><span class="cov0" title="0">{
                                s.logger.Warn().Err(err).Str("url", r.Request.URL.String()).Msg("Failed to write document")
                        }</span>
                }
        })

        // Handle errors
        <span class="cov8" title="1">c.OnError(func(r *colly.Response, err error) </span><span class="cov8" title="1">{
                s.logger.Debug().Err(err).Str("url", r.Request.URL.String()).Msg("Request failed")
        }</span>)

        // Start crawling
        <span class="cov8" title="1">if err := c.Visit(url); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Handle context cancellation
        <span class="cov8" title="1">done := make(chan struct{})
        go func() </span><span class="cov8" title="1">{
                c.Wait()
                close(done)
        }</span>()

        <span class="cov8" title="1">select </span>{
        case &lt;-ctx.Done():<span class="cov8" title="1">
                return ctx.Err()</span>
        case &lt;-done:<span class="cov8" title="1"></span>
        }

        <span class="cov8" title="1">s.logger.Info().Int("pages", processedCount).Msg("Crawl completed")
        return nil</span>
}

// isHTMLContentType checks if content type is HTML
func isHTMLContentType(contentType string) bool <span class="cov8" title="1">{
        if contentType == "" </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="1">lower := strings.ToLower(contentType)
        return strings.Contains(lower, "text/html") ||
                strings.Contains(lower, "application/xhtml")</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package strategies

import (
        "archive/tar"
        "bufio"
        "compress/gzip"
        "context"
        "fmt"
        "io"
        "io/fs"
        "net/http"
        "os"
        "os/exec"
        "path/filepath"
        "regexp"
        "strings"
        "time"

        "github.com/go-git/go-git/v5"
        githttp "github.com/go-git/go-git/v5/plumbing/transport/http"
        "github.com/quantmind-br/repodocs-go/internal/domain"
        "github.com/quantmind-br/repodocs-go/internal/output"
        "github.com/quantmind-br/repodocs-go/internal/utils"
        "github.com/schollz/progressbar/v3"
)

// DocumentExtensions are file extensions to process
var DocumentExtensions = map[string]bool{
        ".md":       true,
        ".txt":      true,
        ".rst":      true,
        ".adoc":     true,
        ".asciidoc": true,
}

// IgnoreDirs are directories to skip
var IgnoreDirs = map[string]bool{
        ".git":         true,
        "node_modules": true,
        "vendor":       true,
        "__pycache__":  true,
        ".venv":        true,
        "venv":         true,
        "dist":         true,
        "build":        true,
        ".next":        true,
        ".nuxt":        true,
}

// GitStrategy extracts documentation from git repositories
// Uses archive download as primary method (faster) with git clone as fallback
type GitStrategy struct {
        writer     *output.Writer
        logger     *utils.Logger
        httpClient *http.Client
}

// NewGitStrategy creates a new git strategy
func NewGitStrategy(deps *Dependencies) *GitStrategy <span class="cov8" title="1">{
        return &amp;GitStrategy{
                writer: deps.Writer,
                logger: deps.Logger,
                httpClient: &amp;http.Client{
                        Timeout: 10 * time.Minute,
                        CheckRedirect: func(req *http.Request, via []*http.Request) error </span><span class="cov0" title="0">{
                                if len(via) &gt;= 10 </span><span class="cov0" title="0">{
                                        return fmt.Errorf("too many redirects")
                                }</span>
                                <span class="cov0" title="0">return nil</span>
                        },
                },
        }
}

// Name returns the strategy name
func (s *GitStrategy) Name() string <span class="cov8" title="1">{
        return "git"
}</span>

// CanHandle returns true if this strategy can handle the given URL
func (s *GitStrategy) CanHandle(url string) bool <span class="cov8" title="1">{
        return strings.HasPrefix(url, "git@") ||
                strings.HasSuffix(url, ".git") ||
                strings.Contains(url, "github.com") ||
                strings.Contains(url, "gitlab.com") ||
                strings.Contains(url, "bitbucket.org")
}</span>

// Execute runs the git extraction strategy
// It tries archive download first (faster), falls back to git clone if needed
func (s *GitStrategy) Execute(ctx context.Context, url string, opts Options) error <span class="cov0" title="0">{
        s.logger.Info().Str("url", url).Msg("Starting git extraction")

        // Create temporary directory
        tmpDir, err := os.MkdirTemp("", "repodocs-git-*")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create temp dir: %w", err)
        }</span>
        <span class="cov0" title="0">defer os.RemoveAll(tmpDir)

        // Try archive download first (faster)
        branch, method, err := s.tryArchiveDownload(ctx, url, tmpDir)
        if err != nil </span><span class="cov0" title="0">{
                // Fallback to git clone
                s.logger.Info().Err(err).Msg("Archive download failed, using git clone")
                branch, err = s.cloneRepository(ctx, url, tmpDir)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to acquire repository: %w", err)
                }</span>
                <span class="cov0" title="0">method = "clone"</span>
        }

        <span class="cov0" title="0">s.logger.Info().
                Str("method", method).
                Str("branch", branch).
                Msg("Repository acquired successfully")

        // Find documentation files
        files, err := s.findDocumentationFiles(tmpDir)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">s.logger.Info().Int("count", len(files)).Msg("Found documentation files")

        // Apply limit
        if opts.Limit &gt; 0 &amp;&amp; len(files) &gt; opts.Limit </span><span class="cov0" title="0">{
                files = files[:opts.Limit]
        }</span>

        // Process files in parallel
        <span class="cov0" title="0">return s.processFiles(ctx, files, tmpDir, url, branch, opts)</span>
}

// repoInfo contains parsed repository information
type repoInfo struct {
        platform string // github, gitlab, bitbucket
        owner    string
        repo     string
}

// tryArchiveDownload attempts to download and extract repository as archive
// Returns branch name, method used ("archive"), and error if failed
func (s *GitStrategy) tryArchiveDownload(ctx context.Context, url, destDir string) (branch, method string, err error) <span class="cov0" title="0">{
        // SSH URLs not supported for archive download
        if strings.HasPrefix(url, "git@") </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("SSH URLs not supported for archive download")
        }</span>

        // Parse URL
        <span class="cov0" title="0">info, err := s.parseGitURL(url)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        // Detect default branch
        <span class="cov0" title="0">branch, err = s.detectDefaultBranch(ctx, url)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Warn().Err(err).Msg("Failed to detect branch, using 'main'")
                branch = "main"
        }</span>

        // Build archive URL
        <span class="cov0" title="0">archiveURL := s.buildArchiveURL(info, branch)
        s.logger.Debug().Str("archive_url", archiveURL).Msg("Downloading archive")

        // Download and extract
        if err := s.downloadAndExtract(ctx, archiveURL, destDir); err != nil </span><span class="cov0" title="0">{
                // If failed with 'main', try 'master'
                if branch == "main" </span><span class="cov0" title="0">{
                        s.logger.Debug().Msg("Trying 'master' branch")
                        archiveURL = s.buildArchiveURL(info, "master")
                        if err2 := s.downloadAndExtract(ctx, archiveURL, destDir); err2 == nil </span><span class="cov0" title="0">{
                                return "master", "archive", nil
                        }</span>
                }
                <span class="cov0" title="0">return "", "", err</span>
        }

        <span class="cov0" title="0">return branch, "archive", nil</span>
}

// parseGitURL extracts owner and repo from various git URL formats
func (s *GitStrategy) parseGitURL(url string) (*repoInfo, error) <span class="cov0" title="0">{
        patterns := []struct {
                platform string
                regex    *regexp.Regexp
        }{
                {"github", regexp.MustCompile(`github\.com[:/]([^/]+)/([^/.]+)`)},
                {"gitlab", regexp.MustCompile(`gitlab\.com[:/]([^/]+)/([^/.]+)`)},
                {"bitbucket", regexp.MustCompile(`bitbucket\.org[:/]([^/]+)/([^/.]+)`)},
        }

        for _, p := range patterns </span><span class="cov0" title="0">{
                if matches := p.regex.FindStringSubmatch(url); len(matches) == 3 </span><span class="cov0" title="0">{
                        return &amp;repoInfo{
                                platform: p.platform,
                                owner:    matches[1],
                                repo:     strings.TrimSuffix(matches[2], ".git"),
                        }, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("unsupported git URL format: %s", url)</span>
}

// detectDefaultBranch uses git ls-remote to find the default branch
func (s *GitStrategy) detectDefaultBranch(ctx context.Context, url string) (string, error) <span class="cov0" title="0">{
        cmd := exec.CommandContext(ctx, "git", "ls-remote", "--symref", url, "HEAD")
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("git ls-remote failed: %w", err)
        }</span>

        // Output format: "ref: refs/heads/master\tHEAD"
        <span class="cov0" title="0">scanner := bufio.NewScanner(strings.NewReader(string(output)))
        for scanner.Scan() </span><span class="cov0" title="0">{
                line := scanner.Text()
                if strings.HasPrefix(line, "ref: refs/heads/") </span><span class="cov0" title="0">{
                        // Split by tab first, then extract branch from first part
                        parts := strings.Split(line, "\t")
                        if len(parts) &gt;= 1 </span><span class="cov0" title="0">{
                                // parts[0] = "ref: refs/heads/master"
                                branch := strings.TrimPrefix(parts[0], "ref: refs/heads/")
                                return branch, nil
                        }</span>
                }
        }

        <span class="cov0" title="0">return "", fmt.Errorf("could not determine default branch")</span>
}

// buildArchiveURL constructs the archive download URL for the platform
func (s *GitStrategy) buildArchiveURL(info *repoInfo, branch string) string <span class="cov0" title="0">{
        switch info.platform </span>{
        case "github":<span class="cov0" title="0">
                return fmt.Sprintf("https://github.com/%s/%s/archive/refs/heads/%s.tar.gz",
                        info.owner, info.repo, branch)</span>
        case "gitlab":<span class="cov0" title="0">
                return fmt.Sprintf("https://gitlab.com/%s/%s/-/archive/%s/%s-%s.tar.gz",
                        info.owner, info.repo, branch, info.repo, branch)</span>
        case "bitbucket":<span class="cov0" title="0">
                return fmt.Sprintf("https://bitbucket.org/%s/%s/get/%s.tar.gz",
                        info.owner, info.repo, branch)</span>
        default:<span class="cov0" title="0">
                // Fallback to GitHub format
                return fmt.Sprintf("https://github.com/%s/%s/archive/refs/heads/%s.tar.gz",
                        info.owner, info.repo, branch)</span>
        }
}

// downloadAndExtract downloads a tar.gz archive and extracts it
func (s *GitStrategy) downloadAndExtract(ctx context.Context, archiveURL, destDir string) error <span class="cov0" title="0">{
        req, err := http.NewRequestWithContext(ctx, "GET", archiveURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Add authentication if available
        <span class="cov0" title="0">if token := os.Getenv("GITHUB_TOKEN"); token != "" </span><span class="cov0" title="0">{
                req.Header.Set("Authorization", "token "+token)
        }</span>

        <span class="cov0" title="0">resp, err := s.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("download request failed: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode == http.StatusNotFound </span><span class="cov0" title="0">{
                return fmt.Errorf("archive not found (404)")
        }</span>
        <span class="cov0" title="0">if resp.StatusCode == http.StatusUnauthorized </span><span class="cov0" title="0">{
                return fmt.Errorf("authentication required (401)")
        }</span>
        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return fmt.Errorf("download failed with status: %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">return s.extractTarGz(resp.Body, destDir)</span>
}

// extractTarGz extracts a tar.gz archive to destDir
func (s *GitStrategy) extractTarGz(r io.Reader, destDir string) error <span class="cov0" title="0">{
        gzr, err := gzip.NewReader(r)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("gzip reader failed: %w", err)
        }</span>
        <span class="cov0" title="0">defer gzr.Close()

        tr := tar.NewReader(gzr)

        for </span><span class="cov0" title="0">{
                header, err := tr.Next()
                if err == io.EOF </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("tar read failed: %w", err)
                }</span>

                // Skip the root directory (GitHub adds repo-branch/ prefix)
                <span class="cov0" title="0">parts := strings.SplitN(header.Name, "/", 2)
                if len(parts) &lt; 2 || parts[1] == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">relativePath := parts[1]

                targetPath := filepath.Join(destDir, relativePath)

                // Security check: prevent path traversal
                if !strings.HasPrefix(filepath.Clean(targetPath), filepath.Clean(destDir)) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">switch header.Typeflag </span>{
                case tar.TypeDir:<span class="cov0" title="0">
                        if err := os.MkdirAll(targetPath, 0755); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("mkdir failed: %w", err)
                        }</span>
                case tar.TypeReg:<span class="cov0" title="0">
                        if err := os.MkdirAll(filepath.Dir(targetPath), 0755); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("mkdir failed: %w", err)
                        }</span>

                        <span class="cov0" title="0">f, err := os.OpenFile(targetPath, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, os.FileMode(header.Mode))
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("create file failed: %w", err)
                        }</span>

                        <span class="cov0" title="0">if _, err := io.Copy(f, tr); err != nil </span><span class="cov0" title="0">{
                                f.Close()
                                return fmt.Errorf("copy failed: %w", err)
                        }</span>
                        <span class="cov0" title="0">f.Close()</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// cloneRepository clones the repository using git (fallback method)
func (s *GitStrategy) cloneRepository(ctx context.Context, url, destDir string) (string, error) <span class="cov0" title="0">{
        s.logger.Info().Str("url", url).Msg("Cloning repository")

        cloneOpts := &amp;git.CloneOptions{
                URL:      url,
                Depth:    1, // Shallow clone
                Progress: os.Stdout,
        }

        // Use HTTPS auth if available
        if token := os.Getenv("GITHUB_TOKEN"); token != "" </span><span class="cov0" title="0">{
                cloneOpts.Auth = &amp;githttp.BasicAuth{
                        Username: "token",
                        Password: token,
                }
        }</span>

        <span class="cov0" title="0">repo, err := git.PlainCloneContext(ctx, destDir, false, cloneOpts)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Get default branch name
        <span class="cov0" title="0">head, err := repo.Head()
        if err == nil </span><span class="cov0" title="0">{
                refName := head.Name().String()
                if strings.HasPrefix(refName, "refs/heads/") </span><span class="cov0" title="0">{
                        return strings.TrimPrefix(refName, "refs/heads/"), nil
                }</span>
        }

        <span class="cov0" title="0">return "main", nil</span>
}

// findDocumentationFiles walks the directory and finds all documentation files
func (s *GitStrategy) findDocumentationFiles(dir string) ([]string, error) <span class="cov0" title="0">{
        var files []string
        err := filepath.WalkDir(dir, func(path string, d fs.DirEntry, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Skip ignored directories
                <span class="cov0" title="0">if d.IsDir() </span><span class="cov0" title="0">{
                        if IgnoreDirs[d.Name()] </span><span class="cov0" title="0">{
                                return fs.SkipDir
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }

                // Check file extension
                <span class="cov0" title="0">ext := strings.ToLower(filepath.Ext(path))
                if DocumentExtensions[ext] </span><span class="cov0" title="0">{
                        files = append(files, path)
                }</span>

                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">return files, err</span>
}

// processFiles processes all documentation files in parallel
func (s *GitStrategy) processFiles(ctx context.Context, files []string, tmpDir, repoURL, branch string, opts Options) error <span class="cov0" title="0">{
        // Create progress bar
        bar := progressbar.NewOptions(len(files),
                progressbar.OptionSetDescription("Processing"),
                progressbar.OptionShowCount(),
        )

        // Process files in parallel using existing infrastructure
        errors := utils.ParallelForEach(ctx, files, opts.Concurrency, func(ctx context.Context, file string) error </span><span class="cov0" title="0">{
                defer bar.Add(1)

                if err := s.processFile(ctx, file, tmpDir, repoURL, branch, opts); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn().Err(err).Str("file", file).Msg("Failed to process file")
                }</span>
                <span class="cov0" title="0">return nil</span>
        })

        // Check for critical errors (context cancellation)
        <span class="cov0" title="0">if err := utils.FirstError(errors); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">s.logger.Info().Msg("Git extraction completed")
        return nil</span>
}

// processFile processes a single documentation file
func (s *GitStrategy) processFile(ctx context.Context, path, tmpDir, repoURL, branch string, opts Options) error <span class="cov0" title="0">{
        // Read file content
        content, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Skip large files (&gt; 10MB)
        <span class="cov0" title="0">if len(content) &gt; 10*1024*1024 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Get relative path for URL
        <span class="cov0" title="0">relPath, _ := filepath.Rel(tmpDir, path)
        // Convert Windows backslashes to forward slashes for URL
        relPathURL := strings.ReplaceAll(relPath, "\\", "/")
        fileURL := repoURL + "/blob/" + branch + "/" + relPathURL

        // Create document
        doc := &amp;domain.Document{
                URL:            fileURL,
                Title:          extractTitleFromPath(relPath),
                Content:        string(content),
                FetchedAt:      time.Now(),
                WordCount:      len(strings.Fields(string(content))),
                CharCount:      len(content),
                SourceStrategy: s.Name(),
                RelativePath:   relPath,
        }

        // For markdown files, the content is already markdown
        ext := strings.ToLower(filepath.Ext(path))
        if ext != ".md" </span><span class="cov0" title="0">{
                // For other formats, wrap in code block
                doc.Content = "```\n" + string(content) + "\n```"
        }</span>

        // Write document
        <span class="cov0" title="0">if !opts.DryRun </span><span class="cov0" title="0">{
                return s.writer.Write(ctx, doc)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// extractTitleFromPath extracts a title from a file path
func extractTitleFromPath(path string) string <span class="cov0" title="0">{
        // Get filename without extension
        base := filepath.Base(path)
        ext := filepath.Ext(base)
        name := strings.TrimSuffix(base, ext)

        // Convert common formats to title case
        name = strings.ReplaceAll(name, "-", " ")
        name = strings.ReplaceAll(name, "_", " ")

        // Capitalize first letter
        if len(name) &gt; 0 </span><span class="cov0" title="0">{
                name = strings.ToUpper(name[:1]) + name[1:]
        }</span>

        <span class="cov0" title="0">return name</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package strategies

import (
        "context"
        "regexp"
        "strings"
        "time"

        "github.com/quantmind-br/repodocs-go/internal/converter"
        "github.com/quantmind-br/repodocs-go/internal/domain"
        "github.com/quantmind-br/repodocs-go/internal/fetcher"
        "github.com/quantmind-br/repodocs-go/internal/output"
        "github.com/quantmind-br/repodocs-go/internal/utils"
        "github.com/schollz/progressbar/v3"
)

// LLMSStrategy extracts documentation from llms.txt files
type LLMSStrategy struct {
        fetcher   *fetcher.Client
        converter *converter.Pipeline
        writer    *output.Writer
        logger    *utils.Logger
}

// NewLLMSStrategy creates a new LLMS strategy
func NewLLMSStrategy(deps *Dependencies) *LLMSStrategy <span class="cov8" title="1">{
        return &amp;LLMSStrategy{
                fetcher:   deps.Fetcher,
                converter: deps.Converter,
                writer:    deps.Writer,
                logger:    deps.Logger,
        }
}</span>

// Name returns the strategy name
func (s *LLMSStrategy) Name() string <span class="cov8" title="1">{
        return "llms"
}</span>

// CanHandle returns true if this strategy can handle the given URL
func (s *LLMSStrategy) CanHandle(url string) bool <span class="cov8" title="1">{
        return strings.HasSuffix(url, "/llms.txt") || strings.HasSuffix(url, "llms.txt")
}</span>

// Execute runs the LLMS extraction strategy
func (s *LLMSStrategy) Execute(ctx context.Context, url string, opts Options) error <span class="cov8" title="1">{
        s.logger.Info().Str("url", url).Msg("Fetching llms.txt")

        // Fetch llms.txt content
        resp, err := s.fetcher.Get(ctx, url)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Parse links from llms.txt
        <span class="cov8" title="1">links := parseLLMSLinks(string(resp.Body))
        s.logger.Info().Int("count", len(links)).Msg("Found links in llms.txt")

        // Apply limit
        if opts.Limit &gt; 0 &amp;&amp; len(links) &gt; opts.Limit </span><span class="cov0" title="0">{
                links = links[:opts.Limit]
        }</span>

        // Create progress bar
        <span class="cov8" title="1">bar := progressbar.NewOptions(len(links),
                progressbar.OptionSetDescription("Downloading"),
                progressbar.OptionShowCount(),
                progressbar.OptionShowIts(),
        )

        // Process links concurrently
        errors := utils.ParallelForEach(ctx, links, opts.Concurrency, func(ctx context.Context, link domain.LLMSLink) error </span><span class="cov8" title="1">{
                defer bar.Add(1)

                // Check if already exists
                if !opts.Force &amp;&amp; s.writer.Exists(link.URL) </span><span class="cov0" title="0">{
                        return nil
                }</span>

                // Fetch page
                <span class="cov8" title="1">pageResp, err := s.fetcher.Get(ctx, link.URL)
                if err != nil </span><span class="cov8" title="1">{
                        s.logger.Warn().Err(err).Str("url", link.URL).Msg("Failed to fetch page")
                        return nil // Continue with other pages
                }</span>

                // Convert to document
                <span class="cov0" title="0">doc, err := s.converter.Convert(ctx, string(pageResp.Body), link.URL)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn().Err(err).Str("url", link.URL).Msg("Failed to convert page")
                        return nil
                }</span>

                // Set metadata
                <span class="cov0" title="0">doc.SourceStrategy = s.Name()
                doc.CacheHit = pageResp.FromCache
                doc.FetchedAt = time.Now()

                // Use title from llms.txt if document title is empty
                if doc.Title == "" &amp;&amp; link.Title != "" </span><span class="cov0" title="0">{
                        doc.Title = link.Title
                }</span>

                // Write document
                <span class="cov0" title="0">if !opts.DryRun </span><span class="cov0" title="0">{
                        if err := s.writer.Write(ctx, doc); err != nil </span><span class="cov0" title="0">{
                                s.logger.Warn().Err(err).Str("url", link.URL).Msg("Failed to write document")
                                return nil
                        }</span>
                }

                <span class="cov0" title="0">return nil</span>
        })

        // Check for errors
        <span class="cov8" title="1">if err := utils.FirstError(errors); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">s.logger.Info().Msg("LLMS extraction completed")
        return nil</span>
}

// linkRegex matches markdown links: [Title](url)
var linkRegex = regexp.MustCompile(`\[([^\]]+)\]\(([^)]+)\)`)

// parseLLMSLinks parses markdown links from llms.txt content
func parseLLMSLinks(content string) []domain.LLMSLink <span class="cov8" title="1">{
        var links []domain.LLMSLink

        matches := linkRegex.FindAllStringSubmatch(content, -1)
        for _, match := range matches </span><span class="cov8" title="1">{
                if len(match) == 3 </span><span class="cov8" title="1">{
                        title := strings.TrimSpace(match[1])
                        url := strings.TrimSpace(match[2])

                        // Skip empty URLs or anchors
                        if url == "" || strings.HasPrefix(url, "#") </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov8" title="1">links = append(links, domain.LLMSLink{
                                Title: title,
                                URL:   url,
                        })</span>
                }
        }

        <span class="cov8" title="1">return links</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package strategies

import (
        "context"
        "strings"
        "time"

        "github.com/PuerkitoBio/goquery"
        "github.com/quantmind-br/repodocs-go/internal/converter"
        "github.com/quantmind-br/repodocs-go/internal/fetcher"
        "github.com/quantmind-br/repodocs-go/internal/output"
        "github.com/quantmind-br/repodocs-go/internal/utils"
)

// PkgGoStrategy extracts documentation from pkg.go.dev
type PkgGoStrategy struct {
        fetcher   *fetcher.Client
        converter *converter.Pipeline
        writer    *output.Writer
        logger    *utils.Logger
}

// NewPkgGoStrategy creates a new pkg.go.dev strategy
func NewPkgGoStrategy(deps *Dependencies) *PkgGoStrategy <span class="cov8" title="1">{
        return &amp;PkgGoStrategy{
                fetcher:   deps.Fetcher,
                converter: deps.Converter,
                writer:    deps.Writer,
                logger:    deps.Logger,
        }
}</span>

// Name returns the strategy name
func (s *PkgGoStrategy) Name() string <span class="cov8" title="1">{
        return "pkggo"
}</span>

// CanHandle returns true if this strategy can handle the given URL
func (s *PkgGoStrategy) CanHandle(url string) bool <span class="cov8" title="1">{
        return strings.Contains(url, "pkg.go.dev")
}</span>

// Execute runs the pkg.go.dev extraction strategy
func (s *PkgGoStrategy) Execute(ctx context.Context, url string, opts Options) error <span class="cov8" title="1">{
        s.logger.Info().Str("url", url).Msg("Fetching pkg.go.dev documentation")

        // Fetch page
        resp, err := s.fetcher.Get(ctx, url)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Parse HTML
        <span class="cov8" title="1">doc, err := goquery.NewDocumentFromReader(strings.NewReader(string(resp.Body)))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Extract package name
        <span class="cov8" title="1">packageName := doc.Find("h1.UnitHeader-title").First().Text()
        packageName = strings.TrimSpace(packageName)

        // If split option is enabled, extract sections separately
        if opts.Split </span><span class="cov8" title="1">{
                return s.extractSections(ctx, doc, url, packageName, opts)
        }</span>

        // Extract main documentation content
        <span class="cov8" title="1">content := doc.Find("div.Documentation-content").First()
        if content.Length() == 0 </span><span class="cov0" title="0">{
                // Fallback to main content area
                content = doc.Find("main").First()
        }</span>

        <span class="cov8" title="1">contentHTML, err := content.Html()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Convert to document
        <span class="cov8" title="1">document, err := s.converter.Convert(ctx, contentHTML, url)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Set metadata
        <span class="cov8" title="1">document.Title = packageName
        document.SourceStrategy = s.Name()
        document.CacheHit = resp.FromCache
        document.FetchedAt = time.Now()

        // Write document
        if !opts.DryRun </span><span class="cov8" title="1">{
                return s.writer.Write(ctx, document)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// extractSections extracts documentation split by sections
func (s *PkgGoStrategy) extractSections(ctx context.Context, doc *goquery.Document, baseURL, packageName string, opts Options) error <span class="cov8" title="1">{
        sections := []struct {
                selector string
                name     string
        }{
                {"#pkg-overview", "Overview"},
                {"#pkg-index", "Index"},
                {"#pkg-constants", "Constants"},
                {"#pkg-variables", "Variables"},
                {"#pkg-functions", "Functions"},
                {"#pkg-types", "Types"},
        }

        for _, section := range sections </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                default:<span class="cov8" title="1"></span>
                }

                <span class="cov8" title="1">content := doc.Find(section.selector).First()
                if content.Length() == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Get section HTML
                <span class="cov8" title="1">sectionHTML, err := content.Html()
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Skip empty sections
                <span class="cov8" title="1">if strings.TrimSpace(sectionHTML) == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Create section URL
                <span class="cov8" title="1">sectionURL := baseURL + section.selector

                // Convert to document
                document, err := s.converter.Convert(ctx, sectionHTML, sectionURL)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn().Err(err).Str("section", section.name).Msg("Failed to convert section")
                        continue</span>
                }

                // Set metadata
                <span class="cov8" title="1">document.Title = packageName + " - " + section.name
                document.SourceStrategy = s.Name()
                document.FetchedAt = time.Now()

                // Write document
                if !opts.DryRun </span><span class="cov8" title="1">{
                        if err := s.writer.Write(ctx, document); err != nil </span><span class="cov0" title="0">{
                                s.logger.Warn().Err(err).Str("section", section.name).Msg("Failed to write section")
                        }</span>
                }
        }

        <span class="cov8" title="1">s.logger.Info().Msg("pkg.go.dev extraction completed")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package strategies

import (
        "compress/gzip"
        "context"
        "encoding/xml"
        "io"
        "sort"
        "strings"
        "time"

        "github.com/quantmind-br/repodocs-go/internal/converter"
        "github.com/quantmind-br/repodocs-go/internal/domain"
        "github.com/quantmind-br/repodocs-go/internal/fetcher"
        "github.com/quantmind-br/repodocs-go/internal/output"
        "github.com/quantmind-br/repodocs-go/internal/renderer"
        "github.com/quantmind-br/repodocs-go/internal/utils"
        "github.com/schollz/progressbar/v3"
)

// SitemapStrategy extracts documentation from sitemap XML files
type SitemapStrategy struct {
        fetcher   *fetcher.Client
        renderer  domain.Renderer
        converter *converter.Pipeline
        writer    *output.Writer
        logger    *utils.Logger
}

// NewSitemapStrategy creates a new sitemap strategy
func NewSitemapStrategy(deps *Dependencies) *SitemapStrategy <span class="cov8" title="1">{
        return &amp;SitemapStrategy{
                fetcher:   deps.Fetcher,
                renderer:  deps.Renderer,
                converter: deps.Converter,
                writer:    deps.Writer,
                logger:    deps.Logger,
        }
}</span>

// Name returns the strategy name
func (s *SitemapStrategy) Name() string <span class="cov8" title="1">{
        return "sitemap"
}</span>

// CanHandle returns true if this strategy can handle the given URL
func (s *SitemapStrategy) CanHandle(url string) bool <span class="cov8" title="1">{
        lower := strings.ToLower(url)
        return strings.HasSuffix(lower, "sitemap.xml") ||
                strings.HasSuffix(lower, "sitemap.xml.gz") ||
                strings.Contains(lower, "sitemap")
}</span>

// Execute runs the sitemap extraction strategy
func (s *SitemapStrategy) Execute(ctx context.Context, url string, opts Options) error <span class="cov8" title="1">{
        s.logger.Info().Str("url", url).Msg("Fetching sitemap")

        // Fetch sitemap
        resp, err := s.fetcher.Get(ctx, url)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Decompress if gzipped
        <span class="cov8" title="1">content := resp.Body
        if strings.HasSuffix(strings.ToLower(url), ".gz") </span><span class="cov0" title="0">{
                content, err = decompressGzip(resp.Body)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Parse sitemap
        <span class="cov8" title="1">sitemap, err := parseSitemap(content, url)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // If it's a sitemap index, process each sitemap
        <span class="cov8" title="1">if sitemap.IsIndex </span><span class="cov0" title="0">{
                return s.processSitemapIndex(ctx, sitemap, opts)
        }</span>

        // Sort by lastmod (most recent first)
        <span class="cov8" title="1">sortURLsByLastMod(sitemap.URLs)

        // Apply limit
        urls := sitemap.URLs
        if opts.Limit &gt; 0 &amp;&amp; len(urls) &gt; opts.Limit </span><span class="cov0" title="0">{
                urls = urls[:opts.Limit]
        }</span>

        <span class="cov8" title="1">s.logger.Info().Int("count", len(urls)).Msg("Processing URLs from sitemap")

        // Create progress bar
        bar := progressbar.NewOptions(len(urls),
                progressbar.OptionSetDescription("Downloading"),
                progressbar.OptionShowCount(),
                progressbar.OptionShowIts(),
        )

        // Process URLs concurrently
        errors := utils.ParallelForEach(ctx, urls, opts.Concurrency, func(ctx context.Context, sitemapURL domain.SitemapURL) error </span><span class="cov8" title="1">{
                defer bar.Add(1)

                // Check if already exists
                if !opts.Force &amp;&amp; s.writer.Exists(sitemapURL.Loc) </span><span class="cov0" title="0">{
                        return nil
                }</span>

                // Fetch page
                <span class="cov8" title="1">var html string
                var fromCache bool

                pageResp, err := s.fetcher.Get(ctx, sitemapURL.Loc)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn().Err(err).Str("url", sitemapURL.Loc).Msg("Failed to fetch page")
                        return nil
                }</span>
                <span class="cov8" title="1">html = string(pageResp.Body)
                fromCache = pageResp.FromCache

                // Check if JS rendering is needed
                if opts.RenderJS || renderer.NeedsJSRendering(html) </span><span class="cov0" title="0">{
                        if s.renderer != nil </span><span class="cov0" title="0">{
                                rendered, err := s.renderer.Render(ctx, sitemapURL.Loc, domain.RenderOptions{
                                        Timeout:     60 * time.Second,
                                        WaitStable:  2 * time.Second,
                                        ScrollToEnd: true,
                                })
                                if err == nil </span><span class="cov0" title="0">{
                                        html = rendered
                                }</span>
                        }
                }

                // Convert to document
                <span class="cov8" title="1">doc, err := s.converter.Convert(ctx, html, sitemapURL.Loc)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn().Err(err).Str("url", sitemapURL.Loc).Msg("Failed to convert page")
                        return nil
                }</span>

                // Set metadata
                <span class="cov8" title="1">doc.SourceStrategy = s.Name()
                doc.CacheHit = fromCache
                doc.FetchedAt = time.Now()

                // Write document
                if !opts.DryRun </span><span class="cov8" title="1">{
                        if err := s.writer.Write(ctx, doc); err != nil </span><span class="cov0" title="0">{
                                s.logger.Warn().Err(err).Str("url", sitemapURL.Loc).Msg("Failed to write document")
                                return nil
                        }</span>
                }

                <span class="cov8" title="1">return nil</span>
        })

        <span class="cov8" title="1">if err := utils.FirstError(errors); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">s.logger.Info().Msg("Sitemap extraction completed")
        return nil</span>
}

// processSitemapIndex processes a sitemap index file
func (s *SitemapStrategy) processSitemapIndex(ctx context.Context, sitemap *domain.Sitemap, opts Options) error <span class="cov0" title="0">{
        s.logger.Info().Int("count", len(sitemap.Sitemaps)).Msg("Processing sitemap index")

        for _, sitemapURL := range sitemap.Sitemaps </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                default:<span class="cov0" title="0"></span>
                }

                <span class="cov0" title="0">if err := s.Execute(ctx, sitemapURL, opts); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn().Err(err).Str("url", sitemapURL).Msg("Failed to process nested sitemap")
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// sitemapXML represents the XML structure of a sitemap
type sitemapXML struct {
        XMLName xml.Name     `xml:"urlset"`
        URLs    []sitemapURL `xml:"url"`
}

type sitemapURL struct {
        Loc        string `xml:"loc"`
        LastMod    string `xml:"lastmod"`
        ChangeFreq string `xml:"changefreq"`
        Priority   string `xml:"priority"`
}

// sitemapIndexXML represents the XML structure of a sitemap index
type sitemapIndexXML struct {
        XMLName  xml.Name          `xml:"sitemapindex"`
        Sitemaps []sitemapLocation `xml:"sitemap"`
}

type sitemapLocation struct {
        Loc     string `xml:"loc"`
        LastMod string `xml:"lastmod"`
}

// parseSitemap parses sitemap XML content
func parseSitemap(content []byte, sourceURL string) (*domain.Sitemap, error) <span class="cov8" title="1">{
        // Try to parse as sitemap index first
        var index sitemapIndexXML
        if err := xml.Unmarshal(content, &amp;index); err == nil &amp;&amp; len(index.Sitemaps) &gt; 0 </span><span class="cov0" title="0">{
                var sitemaps []string
                for _, sm := range index.Sitemaps </span><span class="cov0" title="0">{
                        sitemaps = append(sitemaps, sm.Loc)
                }</span>
                <span class="cov0" title="0">return &amp;domain.Sitemap{
                        IsIndex:   true,
                        Sitemaps:  sitemaps,
                        SourceURL: sourceURL,
                }, nil</span>
        }

        // Parse as regular sitemap
        <span class="cov8" title="1">var sitemap sitemapXML
        if err := xml.Unmarshal(content, &amp;sitemap); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var urls []domain.SitemapURL
        for _, u := range sitemap.URLs </span><span class="cov8" title="1">{
                lastMod, _ := parseLastMod(u.LastMod)
                urls = append(urls, domain.SitemapURL{
                        Loc:        u.Loc,
                        LastMod:    lastMod,
                        LastModStr: u.LastMod,
                        ChangeFreq: u.ChangeFreq,
                })
        }</span>

        <span class="cov8" title="1">return &amp;domain.Sitemap{
                URLs:      urls,
                IsIndex:   false,
                SourceURL: sourceURL,
        }, nil</span>
}

// parseLastMod parses a lastmod date string
func parseLastMod(s string) (time.Time, error) <span class="cov8" title="1">{
        formats := []string{
                time.RFC3339,
                "2006-01-02T15:04:05-07:00",
                "2006-01-02T15:04:05Z",
                "2006-01-02",
        }

        for _, format := range formats </span><span class="cov8" title="1">{
                if t, err := time.Parse(format, s); err == nil </span><span class="cov8" title="1">{
                        return t, nil
                }</span>
        }

        <span class="cov0" title="0">return time.Time{}, nil</span>
}

// sortURLsByLastMod sorts URLs by lastmod date (most recent first)
func sortURLsByLastMod(urls []domain.SitemapURL) <span class="cov8" title="1">{
        sort.Slice(urls, func(i, j int) bool </span><span class="cov8" title="1">{
                return urls[i].LastMod.After(urls[j].LastMod)
        }</span>)
}

// decompressGzip decompresses gzip content
func decompressGzip(data []byte) ([]byte, error) <span class="cov0" title="0">{
        reader, err := gzip.NewReader(strings.NewReader(string(data)))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer reader.Close()

        return io.ReadAll(reader)</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package strategies

import (
        "context"
        "time"

        "github.com/quantmind-br/repodocs-go/internal/cache"
        "github.com/quantmind-br/repodocs-go/internal/converter"
        "github.com/quantmind-br/repodocs-go/internal/domain"
        "github.com/quantmind-br/repodocs-go/internal/fetcher"
        "github.com/quantmind-br/repodocs-go/internal/output"
        "github.com/quantmind-br/repodocs-go/internal/renderer"
        "github.com/quantmind-br/repodocs-go/internal/utils"
)

// Strategy defines the interface for documentation extraction strategies
type Strategy interface {
        // Name returns the strategy name
        Name() string
        // CanHandle returns true if this strategy can handle the given URL
        CanHandle(url string) bool
        // Execute runs the extraction strategy
        Execute(ctx context.Context, url string, opts Options) error
}

// Options contains common options for all strategies
type Options struct {
        Output          string
        Concurrency     int
        Limit           int
        MaxDepth        int
        Exclude         []string
        NoFolders       bool
        DryRun          bool
        Verbose         bool
        Force           bool
        RenderJS        bool
        Split           bool
        IncludeAssets   bool
        ContentSelector string
        CacheTTL        string
        FilterURL       string // Base URL filter - only crawl URLs starting with this path
}

// DefaultOptions returns default strategy options
func DefaultOptions() Options <span class="cov8" title="1">{
        return Options{
                Output:      "./docs",
                Concurrency: 5,
                Limit:       0,
                MaxDepth:    3,
                NoFolders:   false,
                DryRun:      false,
                Verbose:     false,
                Force:       false,
                RenderJS:    false,
                Split:       false,
        }
}</span>

// Dependencies contains shared dependencies for all strategies
type Dependencies struct {
        Fetcher   *fetcher.Client
        Renderer  domain.Renderer
        Cache     domain.Cache
        Converter *converter.Pipeline
        Writer    *output.Writer
        Logger    *utils.Logger
}

// NewDependencies creates new dependencies for strategies
func NewDependencies(opts DependencyOptions) (*Dependencies, error) <span class="cov8" title="1">{
        // Create fetcher
        fetcherClient, err := fetcher.NewClient(fetcher.ClientOptions{
                Timeout:     opts.Timeout,
                MaxRetries:  3,
                EnableCache: opts.EnableCache,
                CacheTTL:    opts.CacheTTL,
                UserAgent:   opts.UserAgent,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Create cache if enabled
        <span class="cov8" title="1">var cacheImpl domain.Cache
        if opts.EnableCache </span><span class="cov8" title="1">{
                cacheImpl, err = cache.NewBadgerCache(cache.Options{
                        Directory: opts.CacheDir,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">fetcherClient.SetCache(cacheImpl)</span>
        }

        // Create renderer if needed
        <span class="cov8" title="1">var rendererImpl domain.Renderer
        if opts.EnableRenderer </span><span class="cov8" title="1">{
                r, err := renderer.NewRenderer(renderer.RendererOptions{
                        Timeout:  opts.RendererTimeout,
                        MaxTabs:  opts.Concurrency,
                        Stealth:  true,
                        Headless: true,
                })
                if err != nil </span><span class="cov0" title="0">{
                        // Renderer is optional, continue without it
                        rendererImpl = nil
                }</span> else<span class="cov8" title="1"> {
                        rendererImpl = r
                }</span>
        }

        // Create converter
        <span class="cov8" title="1">converterPipeline := converter.NewPipeline(converter.PipelineOptions{
                BaseURL:         "",
                ContentSelector: opts.ContentSelector,
        })

        // Create writer
        writer := output.NewWriter(output.WriterOptions{
                BaseDir:      opts.OutputDir,
                Flat:         opts.Flat,
                JSONMetadata: opts.JSONMetadata,
                Force:        opts.Force,
                DryRun:       opts.DryRun,
        })

        // Create logger
        logger := utils.NewLogger(utils.LoggerOptions{
                Level:   "info",
                Format:  "pretty",
                Verbose: opts.Verbose,
        })

        return &amp;Dependencies{
                Fetcher:   fetcherClient,
                Renderer:  rendererImpl,
                Cache:     cacheImpl,
                Converter: converterPipeline,
                Writer:    writer,
                Logger:    logger,
        }, nil</span>
}

// Close releases all resources
func (d *Dependencies) Close() error <span class="cov8" title="1">{
        if d.Fetcher != nil </span><span class="cov8" title="1">{
                d.Fetcher.Close()
        }</span>
        <span class="cov8" title="1">if d.Renderer != nil </span><span class="cov0" title="0">{
                d.Renderer.Close()
        }</span>
        <span class="cov8" title="1">if d.Cache != nil </span><span class="cov8" title="1">{
                d.Cache.Close()
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// DependencyOptions contains options for creating dependencies
type DependencyOptions struct {
        Timeout         time.Duration
        EnableCache     bool
        CacheTTL        time.Duration
        CacheDir        string
        UserAgent       string
        EnableRenderer  bool
        RendererTimeout time.Duration
        Concurrency     int
        ContentSelector string
        OutputDir       string
        Flat            bool
        JSONMetadata    bool
        Force           bool
        DryRun          bool
        Verbose         bool
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package utils

import (
        "net/url"
        "os"
        "path/filepath"
        "regexp"
        "strings"
        "unicode"
)

// MaxFilenameLength is the maximum length for a filename
const MaxFilenameLength = 200

// Windows reserved names
var windowsReserved = map[string]bool{
        "CON": true, "PRN": true, "AUX": true, "NUL": true,
        "COM1": true, "COM2": true, "COM3": true, "COM4": true,
        "COM5": true, "COM6": true, "COM7": true, "COM8": true, "COM9": true,
        "LPT1": true, "LPT2": true, "LPT3": true, "LPT4": true,
        "LPT5": true, "LPT6": true, "LPT7": true, "LPT8": true, "LPT9": true,
}

// invalidCharsRegex matches invalid filename characters
var invalidCharsRegex = regexp.MustCompile(`[&lt;&gt;:"|?*\\/]`)

// multipleSpacesRegex matches multiple consecutive spaces/dashes
var multipleSpacesRegex = regexp.MustCompile(`[-_\s]+`)

// SanitizeFilename sanitizes a string for use as a filename
func SanitizeFilename(name string) string <span class="cov8" title="1">{
        // Remove invalid characters
        name = invalidCharsRegex.ReplaceAllString(name, "-")

        // Replace multiple spaces/dashes with single dash
        name = multipleSpacesRegex.ReplaceAllString(name, "-")

        // Trim leading/trailing dashes and spaces
        name = strings.Trim(name, "- ")

        // Check for Windows reserved names
        upper := strings.ToUpper(name)
        baseName := strings.TrimSuffix(upper, filepath.Ext(upper))
        if windowsReserved[baseName] </span><span class="cov8" title="1">{
                name = "_" + name
        }</span>

        // Limit length
        <span class="cov8" title="1">if len(name) &gt; MaxFilenameLength </span><span class="cov8" title="1">{
                ext := filepath.Ext(name)
                name = name[:MaxFilenameLength-len(ext)] + ext
        }</span>

        // Ensure the name is not empty
        <span class="cov8" title="1">if name == "" </span><span class="cov8" title="1">{
                name = "untitled"
        }</span>

        <span class="cov8" title="1">return name</span>
}

// URLToFilename converts a URL to a safe filename
func URLToFilename(rawURL string) string <span class="cov8" title="1">{
        u, err := url.Parse(rawURL)
        if err != nil </span><span class="cov0" title="0">{
                return SanitizeFilename(rawURL)
        }</span>

        // Get path and remove leading/trailing slashes
        <span class="cov8" title="1">path := strings.Trim(u.Path, "/")
        if path == "" </span><span class="cov8" title="1">{
                path = "index"
        }</span>

        // Replace path separators with dashes for flat structure
        <span class="cov8" title="1">path = strings.ReplaceAll(path, "/", "-")

        // Remove common file extensions
        path = strings.TrimSuffix(path, ".html")
        path = strings.TrimSuffix(path, ".htm")
        path = strings.TrimSuffix(path, ".php")

        // Sanitize and add .md extension
        filename := SanitizeFilename(path)
        if !strings.HasSuffix(filename, ".md") </span><span class="cov8" title="1">{
                filename += ".md"
        }</span>

        <span class="cov8" title="1">return filename</span>
}

// URLToPath converts a URL to a nested directory path
func URLToPath(rawURL string) string <span class="cov8" title="1">{
        u, err := url.Parse(rawURL)
        if err != nil </span><span class="cov0" title="0">{
                return SanitizeFilename(rawURL) + ".md"
        }</span>

        // Get path and remove leading/trailing slashes
        <span class="cov8" title="1">path := strings.Trim(u.Path, "/")
        if path == "" </span><span class="cov8" title="1">{
                path = "index"
        }</span>

        // Remove common file extensions
        <span class="cov8" title="1">path = strings.TrimSuffix(path, ".html")
        path = strings.TrimSuffix(path, ".htm")
        path = strings.TrimSuffix(path, ".php")

        // Split path and sanitize each component
        parts := strings.Split(path, "/")
        for i, part := range parts </span><span class="cov8" title="1">{
                parts[i] = SanitizeFilename(part)
        }</span>

        // Join with OS-specific separator
        <span class="cov8" title="1">result := filepath.Join(parts...)

        // Add .md extension if not present
        if !strings.HasSuffix(result, ".md") </span><span class="cov8" title="1">{
                result += ".md"
        }</span>

        <span class="cov8" title="1">return result</span>
}

// GeneratePath generates the output path for a URL
func GeneratePath(baseDir, rawURL string, flat bool) string <span class="cov8" title="1">{
        var relativePath string
        if flat </span><span class="cov8" title="1">{
                relativePath = URLToFilename(rawURL)
        }</span> else<span class="cov8" title="1"> {
                relativePath = URLToPath(rawURL)
        }</span>
        <span class="cov8" title="1">return filepath.Join(baseDir, relativePath)</span>
}

// GeneratePathFromRelative generates the output path from a relative file path
// Used for Git-sourced files to preserve the repository's directory structure
func GeneratePathFromRelative(baseDir, relPath string, flat bool) string <span class="cov8" title="1">{
        if flat </span><span class="cov0" title="0">{
                // For flat mode, use only the filename
                filename := filepath.Base(relPath)
                // Remove extension and add .md if needed
                ext := filepath.Ext(filename)
                name := strings.TrimSuffix(filename, ext)
                name = SanitizeFilename(name)
                if !strings.HasSuffix(name, ".md") </span><span class="cov0" title="0">{
                        name += ".md"
                }</span>
                <span class="cov0" title="0">return filepath.Join(baseDir, name)</span>
        }

        // For nested mode, preserve directory structure
        // Ensure path uses OS-specific separators
        <span class="cov8" title="1">relPath = filepath.FromSlash(relPath)

        // Sanitize each component
        parts := strings.Split(relPath, string(filepath.Separator))
        for i, part := range parts </span><span class="cov8" title="1">{
                parts[i] = SanitizeFilename(part)
        }</span>
        <span class="cov8" title="1">result := filepath.Join(parts...)

        // Add .md extension if not present
        if !strings.HasSuffix(result, ".md") </span><span class="cov0" title="0">{
                result += ".md"
        }</span>

        <span class="cov8" title="1">return filepath.Join(baseDir, result)</span>
}

// JSONPath returns the corresponding JSON metadata path for a markdown file
func JSONPath(mdPath string) string <span class="cov8" title="1">{
        return strings.TrimSuffix(mdPath, ".md") + ".json"
}</span>

// IsValidFilename checks if a filename is valid
func IsValidFilename(name string) bool <span class="cov8" title="1">{
        if name == "" || name == "." || name == ".." </span><span class="cov8" title="1">{
                return false
        }</span>

        // Check for invalid characters
        <span class="cov8" title="1">if invalidCharsRegex.MatchString(name) </span><span class="cov8" title="1">{
                return false
        }</span>

        // Check for Windows reserved names
        <span class="cov8" title="1">upper := strings.ToUpper(name)
        baseName := strings.TrimSuffix(upper, filepath.Ext(upper))
        if windowsReserved[baseName] </span><span class="cov8" title="1">{
                return false
        }</span>

        // Check for control characters
        <span class="cov8" title="1">for _, r := range name </span><span class="cov8" title="1">{
                if unicode.IsControl(r) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}

// EnsureDir ensures a directory exists, creating it if necessary
func EnsureDir(path string) error <span class="cov8" title="1">{
        dir := filepath.Dir(path)
        return os.MkdirAll(dir, 0755)
}</span>

// ExpandPath expands ~ to the user's home directory
func ExpandPath(path string) string <span class="cov8" title="1">{
        if strings.HasPrefix(path, "~/") </span><span class="cov0" title="0">{
                home, err := os.UserHomeDir()
                if err != nil </span><span class="cov0" title="0">{
                        return path
                }</span>
                <span class="cov0" title="0">return filepath.Join(home, path[2:])</span>
        }
        <span class="cov8" title="1">if path == "~" </span><span class="cov0" title="0">{
                home, err := os.UserHomeDir()
                if err != nil </span><span class="cov0" title="0">{
                        return path
                }</span>
                <span class="cov0" title="0">return home</span>
        }
        <span class="cov8" title="1">return path</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package utils

import (
        "io"
        "os"
        "time"

        "github.com/rs/zerolog"
)

// Logger is a wrapper around zerolog.Logger
type Logger struct {
        zerolog.Logger
}

// LoggerOptions contains options for creating a logger
type LoggerOptions struct {
        Level   string
        Format  string // "pretty" or "json"
        Output  io.Writer
        Verbose bool
}

// NewLogger creates a new logger with the given options
func NewLogger(opts LoggerOptions) *Logger <span class="cov8" title="1">{
        var output io.Writer = os.Stderr
        if opts.Output != nil </span><span class="cov8" title="1">{
                output = opts.Output
        }</span>

        // Set up pretty or JSON output
        <span class="cov8" title="1">if opts.Format == "pretty" </span><span class="cov8" title="1">{
                output = zerolog.ConsoleWriter{
                        Out:        output,
                        TimeFormat: time.RFC3339,
                }
        }</span>

        // Parse log level
        <span class="cov8" title="1">level := parseLogLevel(opts.Level)
        if opts.Verbose </span><span class="cov8" title="1">{
                level = zerolog.DebugLevel
        }</span>

        // Create logger
        <span class="cov8" title="1">logger := zerolog.New(output).
                Level(level).
                With().
                Timestamp().
                Logger()

        return &amp;Logger{Logger: logger}</span>
}

// NewDefaultLogger creates a logger with default settings
func NewDefaultLogger() *Logger <span class="cov8" title="1">{
        return NewLogger(LoggerOptions{
                Level:  "info",
                Format: "pretty",
        })
}</span>

// NewVerboseLogger creates a verbose logger
func NewVerboseLogger() *Logger <span class="cov8" title="1">{
        return NewLogger(LoggerOptions{
                Level:   "debug",
                Format:  "pretty",
                Verbose: true,
        })
}</span>

// parseLogLevel parses a log level string
func parseLogLevel(level string) zerolog.Level <span class="cov8" title="1">{
        switch level </span>{
        case "debug":<span class="cov8" title="1">
                return zerolog.DebugLevel</span>
        case "info":<span class="cov8" title="1">
                return zerolog.InfoLevel</span>
        case "warn":<span class="cov8" title="1">
                return zerolog.WarnLevel</span>
        case "error":<span class="cov8" title="1">
                return zerolog.ErrorLevel</span>
        default:<span class="cov8" title="1">
                return zerolog.InfoLevel</span>
        }
}

// WithComponent returns a logger with a component field
func (l *Logger) WithComponent(component string) *Logger <span class="cov8" title="1">{
        return &amp;Logger{
                Logger: l.Logger.With().Str("component", component).Logger(),
        }
}</span>

// WithURL returns a logger with a URL field
func (l *Logger) WithURL(url string) *Logger <span class="cov8" title="1">{
        return &amp;Logger{
                Logger: l.Logger.With().Str("url", url).Logger(),
        }
}</span>

// WithStrategy returns a logger with a strategy field
func (l *Logger) WithStrategy(strategy string) *Logger <span class="cov8" title="1">{
        return &amp;Logger{
                Logger: l.Logger.With().Str("strategy", strategy).Logger(),
        }
}</span>

// SetGlobalLevel sets the global log level
func SetGlobalLevel(level string) <span class="cov8" title="1">{
        zerolog.SetGlobalLevel(parseLogLevel(level))
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">package utils

import (
        "net/url"
        "path"
        "regexp"
        "strings"
)

// NormalizeURL normalizes a URL for consistent handling
func NormalizeURL(rawURL string) (string, error) <span class="cov8" title="1">{
        // If no scheme is present, prepend https:// before parsing
        // This ensures the host is correctly identified
        if !strings.Contains(rawURL, "://") &amp;&amp; !strings.HasPrefix(rawURL, "//") </span><span class="cov8" title="1">{
                rawURL = "https://" + rawURL
        }</span>

        <span class="cov8" title="1">u, err := url.Parse(rawURL)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Ensure scheme
        <span class="cov8" title="1">if u.Scheme == "" </span><span class="cov0" title="0">{
                u.Scheme = "https"
        }</span>

        // Normalize host to lowercase
        <span class="cov8" title="1">u.Host = strings.ToLower(u.Host)

        // Remove default ports
        if (u.Scheme == "http" &amp;&amp; u.Port() == "80") ||
                (u.Scheme == "https" &amp;&amp; u.Port() == "443") </span><span class="cov8" title="1">{
                u.Host = u.Hostname()
        }</span>

        // Clean path
        <span class="cov8" title="1">if u.Path == "" </span><span class="cov8" title="1">{
                u.Path = "/"
        }</span> else<span class="cov8" title="1"> {
                u.Path = path.Clean(u.Path)
        }</span>

        // Remove trailing slash (except for root)
        <span class="cov8" title="1">if u.Path != "/" &amp;&amp; strings.HasSuffix(u.Path, "/") </span><span class="cov0" title="0">{
                u.Path = strings.TrimSuffix(u.Path, "/")
        }</span>

        // Remove fragment
        <span class="cov8" title="1">u.Fragment = ""

        // Build the result manually to ensure trailing slash for root path
        result := u.String()
        
        // Ensure root path has trailing slash
        if u.Path == "/" &amp;&amp; u.RawQuery == "" &amp;&amp; !strings.HasSuffix(result, "/") </span><span class="cov0" title="0">{
                result += "/"
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}

// NormalizeURLWithoutQuery normalizes a URL and removes query parameters
func NormalizeURLWithoutQuery(rawURL string) (string, error) <span class="cov8" title="1">{
        normalized, err := NormalizeURL(rawURL)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">u, err := url.Parse(normalized)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">u.RawQuery = ""
        return u.String(), nil</span>
}

// ResolveURL resolves a relative URL against a base URL
func ResolveURL(base, ref string) (string, error) <span class="cov8" title="1">{
        baseURL, err := url.Parse(base)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">refURL, err := url.Parse(ref)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">resolved := baseURL.ResolveReference(refURL)
        return resolved.String(), nil</span>
}

// GetDomain extracts the domain from a URL
func GetDomain(rawURL string) string <span class="cov8" title="1">{
        u, err := url.Parse(rawURL)
        if err != nil </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">return u.Host</span>
}

// GetBaseDomain extracts the base domain (without subdomain) from a URL
func GetBaseDomain(rawURL string) string <span class="cov8" title="1">{
        host := GetDomain(rawURL)
        if host == "" </span><span class="cov8" title="1">{
                return ""
        }</span>

        // Only strip "www." prefix, keep other subdomains
        <span class="cov8" title="1">if strings.HasPrefix(strings.ToLower(host), "www.") </span><span class="cov8" title="1">{
                return host[4:]
        }</span>

        <span class="cov8" title="1">return host</span>
}

// IsSameDomain checks if two URLs have the same domain
func IsSameDomain(url1, url2 string) bool <span class="cov8" title="1">{
        return strings.EqualFold(GetDomain(url1), GetDomain(url2))
}</span>

// IsSameBaseDomain checks if two URLs have the same base domain
func IsSameBaseDomain(url1, url2 string) bool <span class="cov8" title="1">{
        return GetBaseDomain(url1) == GetBaseDomain(url2)
}</span>

// IsAbsoluteURL checks if a URL is absolute
func IsAbsoluteURL(rawURL string) bool <span class="cov8" title="1">{
        // Protocol-relative URLs (starting with //) are considered absolute
        if strings.HasPrefix(rawURL, "//") </span><span class="cov8" title="1">{
                return true
        }</span>
        
        <span class="cov8" title="1">u, err := url.Parse(rawURL)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">return u.IsAbs()</span>
}

// IsHTTPURL checks if a URL uses HTTP or HTTPS scheme
func IsHTTPURL(rawURL string) bool <span class="cov8" title="1">{
        u, err := url.Parse(rawURL)
        if err != nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return u.Scheme == "http" || u.Scheme == "https"</span>
}

// IsGitURL checks if a URL is a git repository URL
func IsGitURL(rawURL string) bool <span class="cov8" title="1">{
        return strings.HasPrefix(rawURL, "git@") ||
                strings.HasSuffix(rawURL, ".git") ||
                strings.Contains(rawURL, "github.com") ||
                strings.Contains(rawURL, "gitlab.com") ||
                strings.Contains(rawURL, "bitbucket.org")
}</span>

// IsSitemapURL checks if a URL points to a sitemap
func IsSitemapURL(rawURL string) bool <span class="cov8" title="1">{
        lower := strings.ToLower(rawURL)
        return strings.HasSuffix(lower, "sitemap.xml") ||
                strings.HasSuffix(lower, "sitemap.xml.gz") ||
                strings.Contains(lower, "sitemap")
}</span>

// IsLLMSURL checks if a URL points to an llms.txt file
func IsLLMSURL(rawURL string) bool <span class="cov8" title="1">{
        lower := strings.ToLower(rawURL)
        return strings.HasSuffix(lower, "/llms.txt") ||
                strings.HasSuffix(lower, "llms.txt")
}</span>

// IsPkgGoDevURL checks if a URL is a pkg.go.dev URL
func IsPkgGoDevURL(rawURL string) bool <span class="cov8" title="1">{
        return strings.Contains(rawURL, "pkg.go.dev")
}</span>

// ExtractLinks extracts all href links from HTML content
// This is a simple regex-based extraction, use goquery for more robust parsing
func ExtractLinks(html, baseURL string) []string <span class="cov8" title="1">{
        linkRegex := regexp.MustCompile(`href=["']([^"']+)["']`)
        matches := linkRegex.FindAllStringSubmatch(html, -1)

        links := make([]string, 0, len(matches))
        for _, match := range matches </span><span class="cov8" title="1">{
                if len(match) &gt; 1 </span><span class="cov8" title="1">{
                        link := match[1]
                        // Skip anchors, javascript, mailto, etc.
                        if strings.HasPrefix(link, "#") ||
                                strings.HasPrefix(link, "javascript:") ||
                                strings.HasPrefix(link, "mailto:") ||
                                strings.HasPrefix(link, "tel:") </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        // Resolve relative URLs
                        <span class="cov8" title="1">if !IsAbsoluteURL(link) </span><span class="cov8" title="1">{
                                resolved, err := ResolveURL(baseURL, link)
                                if err != nil </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov8" title="1">link = resolved</span>
                        }

                        <span class="cov8" title="1">links = append(links, link)</span>
                }
        }

        <span class="cov8" title="1">return links</span>
}

// GenerateOutputDirFromURL generates an output directory name from a URL
// Examples:
//   - https://github.com/QwenLM/qwen-code -&gt; docs_qwen-code
//   - https://docs.crawl4ai.com/sitemap.xml -&gt; docs_docscrawl4aicom
//   - https://docs.factory.ai/llms.txt -&gt; docs_docsfactoryai
//   - https://pkg.go.dev/github.com/user/package -&gt; docs_package
func GenerateOutputDirFromURL(rawURL string) string <span class="cov8" title="1">{
        u, err := url.Parse(rawURL)
        if err != nil </span><span class="cov0" title="0">{
                return "docs"
        }</span>

        <span class="cov8" title="1">host := strings.ToLower(u.Host)
        pathStr := strings.Trim(u.Path, "/")

        // Remove port if present
        if idx := strings.LastIndex(host, ":"); idx != -1 </span><span class="cov8" title="1">{
                host = host[:idx]
        }</span>

        <span class="cov8" title="1">var name string

        // Handle Git repository URLs (GitHub, GitLab, Bitbucket)
        if strings.Contains(host, "github.com") ||
                strings.Contains(host, "gitlab.com") ||
                strings.Contains(host, "bitbucket.org") </span><span class="cov8" title="1">{
                // Extract repository name from path
                parts := strings.Split(pathStr, "/")
                if len(parts) &gt;= 2 </span><span class="cov8" title="1">{
                        // Use the repo name (second part: owner/repo)
                        name = parts[1]
                        // Remove .git suffix if present
                        name = strings.TrimSuffix(name, ".git")
                }</span> else<span class="cov0" title="0"> if len(parts) == 1 &amp;&amp; parts[0] != "" </span><span class="cov0" title="0">{
                        name = parts[0]
                }</span>
        }

        // Handle pkg.go.dev URLs
        <span class="cov8" title="1">if name == "" &amp;&amp; strings.Contains(host, "pkg.go.dev") </span><span class="cov8" title="1">{
                // Path is like: /github.com/user/package or /package
                parts := strings.Split(pathStr, "/")
                if len(parts) &gt; 0 </span><span class="cov8" title="1">{
                        // Use the last significant part
                        for i := len(parts) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                                if parts[i] != "" &amp;&amp; !strings.Contains(parts[i], ".") </span><span class="cov8" title="1">{
                                        name = parts[i]
                                        break</span>
                                }
                        }
                        // Fallback to last part
                        <span class="cov8" title="1">if name == "" &amp;&amp; len(parts) &gt; 0 </span><span class="cov0" title="0">{
                                name = parts[len(parts)-1]
                        }</span>
                }
        }

        // For other URLs, use sanitized hostname
        <span class="cov8" title="1">if name == "" </span><span class="cov8" title="1">{
                // Remove common prefixes
                host = strings.TrimPrefix(host, "www.")

                // Remove dots and special characters to create a clean name
                name = sanitizeForDirName(host)
        }</span>

        // Ensure we have a valid name
        <span class="cov8" title="1">if name == "" </span><span class="cov8" title="1">{
                return "docs"
        }</span>

        // Sanitize the name for filesystem
        <span class="cov8" title="1">name = sanitizeForDirName(name)

        return "docs_" + name</span>
}

// sanitizeForDirName removes characters that are not safe for directory names
func sanitizeForDirName(s string) string <span class="cov8" title="1">{
        // Remove dots, spaces, and special characters
        var result strings.Builder
        for _, r := range strings.ToLower(s) </span><span class="cov8" title="1">{
                if (r &gt;= 'a' &amp;&amp; r &lt;= 'z') || (r &gt;= '0' &amp;&amp; r &lt;= '9') || r == '-' || r == '_' </span><span class="cov8" title="1">{
                        result.WriteRune(r)
                }</span>
        }
        <span class="cov8" title="1">return result.String()</span>
}

// HasBaseURL checks if a URL starts with the given base URL path
// Example: HasBaseURL("https://example.com/docs/api", "https://example.com/docs") returns true
// Example: HasBaseURL("https://example.com/blog", "https://example.com/docs") returns false
func HasBaseURL(targetURL, baseURL string) bool <span class="cov8" title="1">{
        if baseURL == "" </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">targetParsed, err := url.Parse(targetURL)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">baseParsed, err := url.Parse(baseURL)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Must be same host
        <span class="cov8" title="1">if strings.ToLower(targetParsed.Host) != strings.ToLower(baseParsed.Host) </span><span class="cov8" title="1">{
                return false
        }</span>

        // Normalize paths
        <span class="cov8" title="1">targetPath := strings.TrimSuffix(targetParsed.Path, "/")
        basePath := strings.TrimSuffix(baseParsed.Path, "/")

        // Target path must start with base path
        if basePath == "" || basePath == "/" </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">return targetPath == basePath || strings.HasPrefix(targetPath, basePath+"/")</span>
}

// FilterLinks filters links based on patterns
func FilterLinks(links []string, excludePatterns []string) []string <span class="cov8" title="1">{
        var regexps []*regexp.Regexp
        for _, pattern := range excludePatterns </span><span class="cov8" title="1">{
                re, err := regexp.Compile(pattern)
                if err != nil </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">regexps = append(regexps, re)</span>
        }

        <span class="cov8" title="1">filtered := make([]string, 0, len(links))
        for _, link := range links </span><span class="cov8" title="1">{
                excluded := false
                for _, re := range regexps </span><span class="cov8" title="1">{
                        if re.MatchString(link) </span><span class="cov8" title="1">{
                                excluded = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !excluded </span><span class="cov8" title="1">{
                        filtered = append(filtered, link)
                }</span>
        }

        <span class="cov8" title="1">return filtered</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package utils

import (
        "context"
        "sync"
)

// Task represents a unit of work
type Task[T any] struct {
        Data   T
        Result any
        Err    error
}

// Worker is a function that processes a task
type Worker[T any] func(ctx context.Context, data T) (any, error)

// Pool is a worker pool for concurrent task processing
type Pool[T any] struct {
        workers    int
        taskQueue  chan *Task[T]
        resultChan chan *Task[T]
        wg         sync.WaitGroup
        worker     Worker[T]
        stopOnce   sync.Once
}

// NewPool creates a new worker pool
func NewPool[T any](workers int, worker Worker[T]) *Pool[T] <span class="cov8" title="1">{
        return &amp;Pool[T]{
                workers:    workers,
                taskQueue:  make(chan *Task[T], workers*2),
                resultChan: make(chan *Task[T], workers*2),
                worker:     worker,
        }
}</span>

// Start starts the worker pool
func (p *Pool[T]) Start(ctx context.Context) <span class="cov8" title="1">{
        for i := 0; i &lt; p.workers; i++ </span><span class="cov8" title="1">{
                p.wg.Add(1)
                go p.runWorker(ctx)
        }</span>
}

// runWorker runs a single worker
func (p *Pool[T]) runWorker(ctx context.Context) <span class="cov8" title="1">{
        defer p.wg.Done()

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                case task, ok := &lt;-p.taskQueue:<span class="cov8" title="1">
                        if !ok </span><span class="cov8" title="1">{
                                return
                        }</span>
                        <span class="cov8" title="1">result, err := p.worker(ctx, task.Data)
                        task.Result = result
                        task.Err = err

                        select </span>{
                        case p.resultChan &lt;- task:<span class="cov8" title="1"></span>
                        case &lt;-ctx.Done():<span class="cov8" title="1">
                                return</span>
                        }
                }
        }
}

// Submit submits a task to the pool
func (p *Pool[T]) Submit(data T) <span class="cov8" title="1">{
        p.taskQueue &lt;- &amp;Task[T]{Data: data}
}</span>

// Results returns the results channel
func (p *Pool[T]) Results() &lt;-chan *Task[T] <span class="cov8" title="1">{
        return p.resultChan
}</span>

// Stop stops the pool and waits for workers to finish
func (p *Pool[T]) Stop() <span class="cov8" title="1">{
        p.stopOnce.Do(func() </span><span class="cov8" title="1">{
                close(p.taskQueue)
                p.wg.Wait()
                close(p.resultChan)
        }</span>)
}

// Process processes a slice of data items concurrently
func (p *Pool[T]) Process(ctx context.Context, items []T) ([]*Task[T], error) <span class="cov8" title="1">{
        // Handle empty slice case
        if len(items) == 0 </span><span class="cov8" title="1">{
                return []*Task[T]{}, nil
        }</span>

        <span class="cov8" title="1">p.Start(ctx)

        // Submit all items
        go func() </span><span class="cov8" title="1">{
                for _, item := range items </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        default:<span class="cov8" title="1">
                                p.Submit(item)</span>
                        }
                }
                <span class="cov8" title="1">close(p.taskQueue)</span>
        }()

        // Collect results with context awareness
        <span class="cov8" title="1">results := make([]*Task[T], 0, len(items))
        collectDone := false
        for !collectDone </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        collectDone = true</span>
                case task, ok := &lt;-p.resultChan:<span class="cov8" title="1">
                        if !ok </span><span class="cov0" title="0">{
                                collectDone = true
                        }</span> else<span class="cov8" title="1"> {
                                results = append(results, task)
                                if len(results) == len(items) </span><span class="cov8" title="1">{
                                        collectDone = true
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">p.wg.Wait()

        // Drain remaining results to avoid goroutine leak
        go func() </span><span class="cov8" title="1">{
                for range p.resultChan </span>{<span class="cov8" title="1">
                }</span>
        }()
        <span class="cov8" title="1">close(p.resultChan)

        // Check for context error
        if ctx.Err() != nil </span><span class="cov8" title="1">{
                return results, ctx.Err()
        }</span>

        <span class="cov8" title="1">return results, nil</span>
}

// SimplePool is a simpler worker pool without generics for basic use cases
type SimplePool struct {
        workers int
        wg      sync.WaitGroup
}

// NewSimplePool creates a new simple worker pool
func NewSimplePool(workers int) *SimplePool <span class="cov8" title="1">{
        return &amp;SimplePool{workers: workers}
}</span>

// Run runs tasks concurrently with the given function
func (p *SimplePool) Run(ctx context.Context, tasks []func(context.Context) error) []error <span class="cov8" title="1">{
        errors := make([]error, len(tasks))
        taskChan := make(chan int, len(tasks))
        var mu sync.Mutex

        // Start workers
        for i := 0; i &lt; p.workers; i++ </span><span class="cov8" title="1">{
                p.wg.Add(1)
                go func() </span><span class="cov8" title="1">{
                        defer p.wg.Done()
                        for </span><span class="cov8" title="1">{
                                select </span>{
                                case &lt;-ctx.Done():<span class="cov8" title="1">
                                        return</span>
                                case idx, ok := &lt;-taskChan:<span class="cov8" title="1">
                                        if !ok </span><span class="cov8" title="1">{
                                                return
                                        }</span>
                                        <span class="cov8" title="1">err := tasks[idx](ctx)
                                        mu.Lock()
                                        errors[idx] = err
                                        mu.Unlock()</span>
                                }
                        }
                }()
        }

        // Submit tasks
        <span class="cov8" title="1">for i := range tasks </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        close(taskChan)
                        p.wg.Wait()
                        return errors</span>
                case taskChan &lt;- i:<span class="cov8" title="1"></span>
                }
        }

        <span class="cov8" title="1">close(taskChan)
        p.wg.Wait()

        return errors</span>
}

// ParallelForEach executes a function for each item in parallel
func ParallelForEach[T any](ctx context.Context, items []T, workers int, fn func(context.Context, T) error) []error <span class="cov8" title="1">{
        if workers &lt;= 0 </span><span class="cov8" title="1">{
                workers = 1
        }</span>
        <span class="cov8" title="1">if workers &gt; len(items) </span><span class="cov8" title="1">{
                workers = len(items)
        }</span>

        <span class="cov8" title="1">errors := make([]error, len(items))
        taskChan := make(chan int, len(items))
        var wg sync.WaitGroup
        var mu sync.Mutex

        // Start workers
        for i := 0; i &lt; workers; i++ </span><span class="cov8" title="1">{
                wg.Add(1)
                go func() </span><span class="cov8" title="1">{
                        defer wg.Done()
                        for </span><span class="cov8" title="1">{
                                select </span>{
                                case &lt;-ctx.Done():<span class="cov8" title="1">
                                        return</span>
                                case idx, ok := &lt;-taskChan:<span class="cov8" title="1">
                                        if !ok </span><span class="cov8" title="1">{
                                                return
                                        }</span>
                                        <span class="cov8" title="1">err := fn(ctx, items[idx])
                                        mu.Lock()
                                        errors[idx] = err
                                        mu.Unlock()</span>
                                }
                        }
                }()
        }

        // Submit tasks
        <span class="cov8" title="1">for i := range items </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        close(taskChan)
                        wg.Wait()
                        return errors</span>
                case taskChan &lt;- i:<span class="cov8" title="1"></span>
                }
        }

        <span class="cov8" title="1">close(taskChan)
        wg.Wait()

        return errors</span>
}

// FirstError returns the first non-nil error from a slice of errors
func FirstError(errors []error) error <span class="cov8" title="1">{
        for _, err := range errors </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// CollectErrors collects all non-nil errors from a slice
func CollectErrors(errors []error) []error <span class="cov8" title="1">{
        var result []error
        for _, err := range errors </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov8" title="1">{
                        result = append(result, err)
                }</span>
        }
        <span class="cov8" title="1">return result</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
