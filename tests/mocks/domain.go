// Code generated by MockGen. DO NOT EDIT.
// Source: internal/domain/interfaces.go
//
// Generated by this command:
//
//	mockgen -source=internal/domain/interfaces.go -destination=tests/mocks/domain.go -package mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
	"bytes"
	context "context"
	"io"
	http "net/http"
	reflect "reflect"
	time "time"

	domain "github.com/quantmind-br/repodocs-go/internal/domain"
	gomock "go.uber.org/mock/gomock"
)

// MockStrategy is a mock of Strategy interface.
type MockStrategy struct {
	ctrl     *gomock.Controller
	recorder *MockStrategyMockRecorder
	isgomock struct{}
}

// MockStrategyMockRecorder is the mock recorder for MockStrategy.
type MockStrategyMockRecorder struct {
	mock *MockStrategy
}

// NewMockStrategy creates a new mock instance.
func NewMockStrategy(ctrl *gomock.Controller) *MockStrategy {
	mock := &MockStrategy{ctrl: ctrl}
	mock.recorder = &MockStrategyMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockStrategy) EXPECT() *MockStrategyMockRecorder {
	return m.recorder
}

// CanHandle mocks base method.
func (m *MockStrategy) CanHandle(url string) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CanHandle", url)
	ret0, _ := ret[0].(bool)
	return ret0
}

// CanHandle indicates an expected call of CanHandle.
func (mr *MockStrategyMockRecorder) CanHandle(url any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CanHandle", reflect.TypeOf((*MockStrategy)(nil).CanHandle), url)
}

// Execute mocks base method.
func (m *MockStrategy) Execute(ctx context.Context, url string, opts domain.StrategyOptions) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", ctx, url, opts)
	ret0, _ := ret[0].(error)
	return ret0
}

// Execute indicates an expected call of Execute.
func (mr *MockStrategyMockRecorder) Execute(ctx, url, opts any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockStrategy)(nil).Execute), ctx, url, opts)
}

// Name mocks base method.
func (m *MockStrategy) Name() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Name")
	ret0, _ := ret[0].(string)
	return ret0
}

// Name indicates an expected call of Name.
func (mr *MockStrategyMockRecorder) Name() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Name", reflect.TypeOf((*MockStrategy)(nil).Name))
}

// MockFetcher is a mock of Fetcher interface.
type MockFetcher struct {
	ctrl     *gomock.Controller
	recorder *MockFetcherMockRecorder
	isgomock struct{}
}

// MockFetcherMockRecorder is the mock recorder for MockFetcher.
type MockFetcherMockRecorder struct {
	mock *MockFetcher
}

// NewMockFetcher creates a new mock instance.
func NewMockFetcher(ctrl *gomock.Controller) *MockFetcher {
	mock := &MockFetcher{ctrl: ctrl}
	mock.recorder = &MockFetcherMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockFetcher) EXPECT() *MockFetcherMockRecorder {
	return m.recorder
}

// Close mocks base method.
func (m *MockFetcher) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockFetcherMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockFetcher)(nil).Close))
}

// Get mocks base method.
func (m *MockFetcher) Get(ctx context.Context, url string) (*domain.Response, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Get", ctx, url)
	ret0, _ := ret[0].(*domain.Response)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Get indicates an expected call of Get.
func (mr *MockFetcherMockRecorder) Get(ctx, url any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockFetcher)(nil).Get), ctx, url)
}

// GetCookies mocks base method.
func (m *MockFetcher) GetCookies(url string) []*http.Cookie {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCookies", url)
	ret0, _ := ret[0].([]*http.Cookie)
	return ret0
}

// GetCookies indicates an expected call of GetCookies.
func (mr *MockFetcherMockRecorder) GetCookies(url any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCookies", reflect.TypeOf((*MockFetcher)(nil).GetCookies), url)
}

// GetWithHeaders mocks base method.
func (m *MockFetcher) GetWithHeaders(ctx context.Context, url string, headers map[string]string) (*domain.Response, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetWithHeaders", ctx, url, headers)
	ret0, _ := ret[0].(*domain.Response)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetWithHeaders indicates an expected call of GetWithHeaders.
func (mr *MockFetcherMockRecorder) GetWithHeaders(ctx, url, headers any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetWithHeaders", reflect.TypeOf((*MockFetcher)(nil).GetWithHeaders), ctx, url, headers)
}

// Transport mocks base method.
func (m *MockFetcher) Transport() http.RoundTripper {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Transport")
	ret0, _ := ret[0].(http.RoundTripper)
	return ret0
}

// Transport indicates an expected call of Transport.
func (mr *MockFetcherMockRecorder) Transport() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Transport", reflect.TypeOf((*MockFetcher)(nil).Transport))
}

// MockRenderer is a mock of Renderer interface.
type MockRenderer struct {
	ctrl     *gomock.Controller
	recorder *MockRendererMockRecorder
	isgomock struct{}
}

// MockRendererMockRecorder is the mock recorder for MockRenderer.
type MockRendererMockRecorder struct {
	mock *MockRenderer
}

// NewMockRenderer creates a new mock instance.
func NewMockRenderer(ctrl *gomock.Controller) *MockRenderer {
	mock := &MockRenderer{ctrl: ctrl}
	mock.recorder = &MockRendererMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRenderer) EXPECT() *MockRendererMockRecorder {
	return m.recorder
}

// Close mocks base method.
func (m *MockRenderer) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockRendererMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockRenderer)(nil).Close))
}

// Render mocks base method.
func (m *MockRenderer) Render(ctx context.Context, url string, opts domain.RenderOptions) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Render", ctx, url, opts)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Render indicates an expected call of Render.
func (mr *MockRendererMockRecorder) Render(ctx, url, opts any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Render", reflect.TypeOf((*MockRenderer)(nil).Render), ctx, url, opts)
}

// MockCache is a mock of Cache interface.
type MockCache struct {
	ctrl     *gomock.Controller
	recorder *MockCacheMockRecorder
	isgomock struct{}
}

// MockCacheMockRecorder is the mock recorder for MockCache.
type MockCacheMockRecorder struct {
	mock *MockCache
}

// NewMockCache creates a new mock instance.
func NewMockCache(ctrl *gomock.Controller) *MockCache {
	mock := &MockCache{ctrl: ctrl}
	mock.recorder = &MockCacheMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCache) EXPECT() *MockCacheMockRecorder {
	return m.recorder
}

// Close mocks base method.
func (m *MockCache) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockCacheMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockCache)(nil).Close))
}

// Delete mocks base method.
func (m *MockCache) Delete(ctx context.Context, key string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Delete", ctx, key)
	ret0, _ := ret[0].(error)
	return ret0
}

// Delete indicates an expected call of Delete.
func (mr *MockCacheMockRecorder) Delete(ctx, key any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockCache)(nil).Delete), ctx, key)
}

// Get mocks base method.
func (m *MockCache) Get(ctx context.Context, key string) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Get", ctx, key)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Get indicates an expected call of Get.
func (mr *MockCacheMockRecorder) Get(ctx, key any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockCache)(nil).Get), ctx, key)
}

// Has mocks base method.
func (m *MockCache) Has(ctx context.Context, key string) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Has", ctx, key)
	ret0, _ := ret[0].(bool)
	return ret0
}

// Has indicates an expected call of Has.
func (mr *MockCacheMockRecorder) Has(ctx, key any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Has", reflect.TypeOf((*MockCache)(nil).Has), ctx, key)
}

// Set mocks base method.
func (m *MockCache) Set(ctx context.Context, key string, value []byte, ttl time.Duration) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Set", ctx, key, value, ttl)
	ret0, _ := ret[0].(error)
	return ret0
}

// Set indicates an expected call of Set.
func (mr *MockCacheMockRecorder) Set(ctx, key, value, ttl any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Set", reflect.TypeOf((*MockCache)(nil).Set), ctx, key, value, ttl)
}

// MockConverter is a mock of Converter interface.
type MockConverter struct {
	ctrl     *gomock.Controller
	recorder *MockConverterMockRecorder
	isgomock struct{}
}

// MockConverterMockRecorder is the mock recorder for MockConverter.
type MockConverterMockRecorder struct {
	mock *MockConverter
}

// NewMockConverter creates a new mock instance.
func NewMockConverter(ctrl *gomock.Controller) *MockConverter {
	mock := &MockConverter{ctrl: ctrl}
	mock.recorder = &MockConverterMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockConverter) EXPECT() *MockConverterMockRecorder {
	return m.recorder
}

// Convert mocks base method.
func (m *MockConverter) Convert(ctx context.Context, html, sourceURL string) (*domain.Document, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Convert", ctx, html, sourceURL)
	ret0, _ := ret[0].(*domain.Document)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Convert indicates an expected call of Convert.
func (mr *MockConverterMockRecorder) Convert(ctx, html, sourceURL any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Convert", reflect.TypeOf((*MockConverter)(nil).Convert), ctx, html, sourceURL)
}

// MockWriter is a mock of Writer interface.
type MockWriter struct {
	ctrl     *gomock.Controller
	recorder *MockWriterMockRecorder
	isgomock struct{}
}

// MockWriterMockRecorder is the mock recorder for MockWriter.
type MockWriterMockRecorder struct {
	mock *MockWriter
}

// NewMockWriter creates a new mock instance.
func NewMockWriter(ctrl *gomock.Controller) *MockWriter {
	mock := &MockWriter{ctrl: ctrl}
	mock.recorder = &MockWriterMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockWriter) EXPECT() *MockWriterMockRecorder {
	return m.recorder
}

// Write mocks base method.
func (m *MockWriter) Write(ctx context.Context, doc *domain.Document) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Write", ctx, doc)
	ret0, _ := ret[0].(error)
	return ret0
}

// Write indicates an expected call of Write.
func (mr *MockWriterMockRecorder) Write(ctx, doc any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Write", reflect.TypeOf((*MockWriter)(nil).Write), ctx, doc)
}

// SimpleMockCache is a simple in-memory cache for testing without gomock
type SimpleMockCache struct {
	data map[string][]byte
}

// NewSimpleMockCache creates a new SimpleMockCache
func NewSimpleMockCache() *SimpleMockCache {
	return &SimpleMockCache{
		data: make(map[string][]byte),
	}
}

// Get retrieves a value from the cache
func (m *SimpleMockCache) Get(ctx context.Context, key string) ([]byte, error) {
	value, ok := m.data[key]
	if !ok {
		return nil, domain.ErrCacheMiss
	}
	return value, nil
}

// Set stores a value in the cache
func (m *SimpleMockCache) Set(ctx context.Context, key string, value []byte, ttl time.Duration) error {
	m.data[key] = value
	return nil
}

// Has checks if a key exists in the cache
func (m *SimpleMockCache) Has(ctx context.Context, key string) bool {
	_, ok := m.data[key]
	return ok
}

// Delete removes a key from the cache
func (m *SimpleMockCache) Delete(ctx context.Context, key string) error {
	delete(m.data, key)
	return nil
}

// Close releases cache resources
func (m *SimpleMockCache) Close() error {
	m.data = nil
	return nil
}

// MockLLMProvider is a mock of LLMProvider interface
type MockLLMProvider struct {
	ctrl     *gomock.Controller
	recorder *MockLLMProviderMockRecorder
	isgomock struct{}
}

// MockLLMProviderMockRecorder is the mock recorder for MockLLMProvider
type MockLLMProviderMockRecorder struct {
	mock *MockLLMProvider
}

// NewMockLLMProvider creates a new mock instance
func NewMockLLMProvider(ctrl *gomock.Controller) *MockLLMProvider {
	mock := &MockLLMProvider{ctrl: ctrl}
	mock.recorder = &MockLLMProviderMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockLLMProvider) EXPECT() *MockLLMProviderMockRecorder {
	return m.recorder
}

// Name mocks base method
func (m *MockLLMProvider) Name() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Name")
	ret0, _ := ret[0].(string)
	return ret0
}

// Name indicates an expected call of Name
func (mr *MockLLMProviderMockRecorder) Name() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Name", reflect.TypeOf((*MockLLMProvider)(nil).Name))
}

// Complete mocks base method
func (m *MockLLMProvider) Complete(ctx context.Context, req *domain.LLMRequest) (*domain.LLMResponse, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Complete", ctx, req)
	ret0, _ := ret[0].(*domain.LLMResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Complete indicates an expected call of Complete
func (mr *MockLLMProviderMockRecorder) Complete(ctx, req any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Complete", reflect.TypeOf((*MockLLMProvider)(nil).Complete), ctx, req)
}

// Close mocks base method
func (m *MockLLMProvider) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close
func (mr *MockLLMProviderMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockLLMProvider)(nil).Close))
}

// SimpleMockFetcher is a simple fetcher for testing without gomock
type SimpleMockFetcher struct {
	Response      *domain.Response
	Error         error
	Requests      []string
	MockTransport http.RoundTripper
}

// NewSimpleMockFetcher creates a new SimpleMockFetcher
func NewSimpleMockFetcher() *SimpleMockFetcher {
	return &SimpleMockFetcher{
		Requests: make([]string, 0),
	}
}

func (m *SimpleMockFetcher) Get(ctx context.Context, url string) (*domain.Response, error) {
	m.Requests = append(m.Requests, url)
	if m.Error != nil {
		return nil, m.Error
	}
	return m.Response, nil
}

func (m *SimpleMockFetcher) GetWithHeaders(ctx context.Context, url string, headers map[string]string) (*domain.Response, error) {
	return m.Get(ctx, url)
}

func (m *SimpleMockFetcher) GetCookies(url string) []*http.Cookie {
	return nil
}

func (m *SimpleMockFetcher) Transport() http.RoundTripper {
	if m.MockTransport != nil {
		return m.MockTransport
	}
	return &MockRoundTripper{Fetcher: m}
}

func (m *SimpleMockFetcher) Close() error {
	return nil
}

// MockRoundTripper implements http.RoundTripper using SimpleMockFetcher
type MockRoundTripper struct {
	Fetcher *SimpleMockFetcher
}

func (t *MockRoundTripper) RoundTrip(req *http.Request) (*http.Response, error) {
	resp, err := t.Fetcher.GetWithHeaders(req.Context(), req.URL.String(), nil)
	if err != nil {
		return nil, err
	}

	return &http.Response{
		Status:        http.StatusText(resp.StatusCode),
		StatusCode:    resp.StatusCode,
		Proto:         "HTTP/1.1",
		ProtoMajor:    1,
		ProtoMinor:    1,
		Header:        resp.Headers,
		Body:          io.NopCloser(bytes.NewReader(resp.Body)),
		ContentLength: int64(len(resp.Body)),
		Request:       req,
	}, nil
}

type MultiResponseMockFetcher struct {
	Responses map[string]*domain.Response
	Errors    map[string]error
	Requests  []string
}

func NewMultiResponseMockFetcher() *MultiResponseMockFetcher {
	return &MultiResponseMockFetcher{
		Responses: make(map[string]*domain.Response),
		Errors:    make(map[string]error),
		Requests:  make([]string, 0),
	}
}

func (m *MultiResponseMockFetcher) Get(ctx context.Context, url string) (*domain.Response, error) {
	m.Requests = append(m.Requests, url)
	if err, ok := m.Errors[url]; ok {
		return nil, err
	}
	if resp, ok := m.Responses[url]; ok {
		return resp, nil
	}
	return &domain.Response{StatusCode: 404, Body: []byte("Not Found")}, nil
}

func (m *MultiResponseMockFetcher) GetWithHeaders(ctx context.Context, url string, headers map[string]string) (*domain.Response, error) {
	return m.Get(ctx, url)
}

func (m *MultiResponseMockFetcher) GetCookies(url string) []*http.Cookie {
	return nil
}

func (m *MultiResponseMockFetcher) Transport() http.RoundTripper {
	return &MultiResponseRoundTripper{Fetcher: m}
}

func (m *MultiResponseMockFetcher) Close() error {
	return nil
}

type MultiResponseRoundTripper struct {
	Fetcher *MultiResponseMockFetcher
}

func (t *MultiResponseRoundTripper) RoundTrip(req *http.Request) (*http.Response, error) {
	resp, err := t.Fetcher.GetWithHeaders(req.Context(), req.URL.String(), nil)
	if err != nil {
		return nil, err
	}

	headers := resp.Headers
	if headers == nil {
		headers = make(http.Header)
	}
	if headers.Get("Content-Type") == "" {
		headers.Set("Content-Type", "text/html")
	}

	return &http.Response{
		Status:        http.StatusText(resp.StatusCode),
		StatusCode:    resp.StatusCode,
		Proto:         "HTTP/1.1",
		ProtoMajor:    1,
		ProtoMinor:    1,
		Header:        headers,
		Body:          io.NopCloser(bytes.NewReader(resp.Body)),
		ContentLength: int64(len(resp.Body)),
		Request:       req,
	}, nil
}
